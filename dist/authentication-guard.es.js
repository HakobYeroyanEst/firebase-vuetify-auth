(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode('.v-icon{--v-icon-size-multiplier: 1;align-items:center;display:inline-flex;font-feature-settings:"liga";height:1em;justify-content:center;letter-spacing:normal;line-height:1;position:relative;text-indent:0;user-select:none;vertical-align:middle;width:1em}.v-icon--clickable{cursor:pointer}.v-icon--size-x-small{font-size:calc(var(--v-icon-size-multiplier) * 1em)}.v-icon--size-small{font-size:calc(var(--v-icon-size-multiplier) * 1.25em)}.v-icon--size-default{font-size:calc(var(--v-icon-size-multiplier) * 1.5em)}.v-icon--size-large{font-size:calc(var(--v-icon-size-multiplier) * 1.75em)}.v-icon--size-x-large{font-size:calc(var(--v-icon-size-multiplier) * 2em)}.v-icon__svg{fill:currentColor;width:100%;height:100%}.v-icon--start{margin-inline-end:8px}.v-icon--end{margin-inline-start:8px}.v-list{overflow:auto;padding:8px 0;position:relative;border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0;box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12));border-radius:0;background:rgba(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-list--border{border-width:thin;box-shadow:none}.v-list--disabled{pointer-events:none;user-select:none}.v-list--nav{padding-inline-start:8px;padding-inline-end:8px}.v-navigation-drawer--rail:not(.v-navigation-drawer--is-hovering) .v-list .v-avatar{--v-avatar-height: 24px}.v-list--rounded{border-radius:4px}.v-list--subheader{padding-top:0}.v-list-img{border-radius:inherit;display:flex;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:-1}.v-list-subheader{align-items:center;background:inherit;color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));display:flex;font-size:.875rem;font-weight:400;line-height:1.375rem;padding-inline-end:16px;min-height:40px;transition:.2s min-height cubic-bezier(.4,0,.2,1)}.v-list-subheader__text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-list--density-default .v-list-subheader{min-height:40px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list--density-comfortable .v-list-subheader{min-height:36px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list--density-compact .v-list-subheader{min-height:32px;padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list-subheader--inset{--indent-padding: 56px}.v-list--nav .v-list-subheader{font-size:.75rem}.v-list-subheader--sticky{background:inherit;left:0;position:sticky;top:0;z-index:1}.v-list__overlay{background-color:currentColor;border-radius:inherit;bottom:0;left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:opacity .2s ease-in-out}.v-divider{display:block;flex:1 1 100%;height:0px;max-height:0px;opacity:var(--v-border-opacity);transition:inherit;border-style:solid;border-width:thin 0 0 0}.v-divider--vertical{align-self:stretch;border-width:0 thin 0 0;display:inline-flex;height:inherit;margin-left:-1px;max-height:100%;max-width:0px;vertical-align:text-bottom;width:0px}.v-divider--inset:not(.v-divider--vertical){max-width:calc(100% - 72px);margin-inline-start:72px}.v-divider--inset.v-divider--vertical{margin-bottom:8px;margin-top:8px;max-height:calc(100% - 16px)}.v-list-item{align-items:center;display:grid;flex:none;grid-template-areas:"prepend content append";grid-template-columns:max-content auto max-content;outline:none;max-width:100%;padding:4px 16px;position:relative;text-decoration:none;border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0;border-radius:0}.v-list-item--border{border-width:thin;box-shadow:none}.v-list-item:hover>.v-list-item__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-list-item:focus-visible>.v-list-item__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-list-item:focus>.v-list-item__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}}.v-list-item--active>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]>.v-list-item__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-list-item--active:hover>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:hover>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-list-item--active:focus-visible>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-list-item--active:focus>.v-list-item__overlay,.v-list-item[aria-haspopup=menu][aria-expanded=true]:focus>.v-list-item__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-list-item--variant-plain,.v-list-item--variant-outlined,.v-list-item--variant-text,.v-list-item--variant-tonal{background:transparent;color:inherit}.v-list-item--variant-plain{opacity:.62}.v-list-item--variant-plain:focus,.v-list-item--variant-plain:hover{opacity:1}.v-list-item--variant-plain .v-list-item__overlay{display:none}.v-list-item--variant-elevated,.v-list-item--variant-flat{background:rgba(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-list-item--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-list-item--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-list-item--variant-outlined{border:thin solid currentColor}.v-list-item--variant-text .v-list-item__overlay{background:currentColor}.v-list-item--variant-tonal .v-list-item__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-list-item__prepend>.v-icon,.v-list-item__append>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-list-item--active .v-list-item__prepend>.v-icon,.v-list-item--active .v-list-item__append>.v-icon{opacity:1}.v-list-item--rounded{border-radius:4px}.v-list-item--disabled{pointer-events:none;user-select:none;opacity:.6}.v-list-item--link{cursor:pointer}.v-list-item__prepend{align-items:center;align-self:center;display:flex;grid-area:prepend}.v-list-item__prepend>.v-avatar{margin-inline-end:16px}.v-list-item__prepend>.v-icon{margin-inline-end:32px}.v-list-item--three-line .v-list-item__prepend{align-self:start}.v-list-item__append{align-self:center;display:flex;align-items:center;grid-area:append}.v-list-item__append>.v-avatar{margin-inline-start:16px}.v-list-item__append>.v-icon{margin-inline-start:32px}.v-list-item--three-line .v-list-item__append{align-self:start}.v-list-item__content{align-self:center;grid-area:content;overflow:hidden}.v-list-item-action{align-self:center;display:flex;align-items:center;grid-area:prepend;flex:none;transition:inherit;transition-property:height,width}.v-list-item-action--start{margin-inline-end:12px}.v-list-item-action--end{margin-inline-start:12px}.v-list-item-media{margin-top:0;margin-bottom:0}.v-list-item-media--start{margin-inline-end:16px}.v-list-item-media--end{margin-inline-start:16px}.v-list-item--two-line .v-list-item-media{margin-top:-4px;margin-bottom:-4px}.v-list-item--three-line .v-list-item-media{margin-top:0;margin-bottom:0}.v-list-item-subtitle{-webkit-box-orient:vertical;display:-webkit-box;opacity:var(--v-medium-emphasis-opacity);overflow:hidden;padding:0;text-overflow:ellipsis;font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;line-height:1rem;text-transform:none}.v-list-item--one-line .v-list-item-subtitle{-webkit-line-clamp:1}.v-list-item--two-line .v-list-item-subtitle{-webkit-line-clamp:2}.v-list-item--three-line .v-list-item-subtitle{-webkit-line-clamp:3}.v-list-item--nav .v-list-item-subtitle{font-size:.75rem;font-weight:400;letter-spacing:.0178571429em;line-height:1rem}.v-list-item-title{hyphens:auto;overflow-wrap:normal;overflow:hidden;padding:0;white-space:nowrap;text-overflow:ellipsis;word-break:normal;word-wrap:break-word;font-size:1rem;font-weight:400;letter-spacing:.009375em;line-height:1.5rem;text-transform:none}.v-list-item--nav .v-list-item-title{font-size:.8125rem;font-weight:500;letter-spacing:normal;line-height:1rem}.v-list-item--density-default{min-height:40px}.v-list-item--density-default.v-list-item--one-line{min-height:48px;padding-top:4px;padding-bottom:4px}.v-list-item--density-default.v-list-item--two-line{min-height:64px;padding-top:12px;padding-bottom:12px}.v-list-item--density-default.v-list-item--three-line{min-height:88px;padding-top:16px;padding-bottom:16px}.v-list-item--density-default:not(.v-list-item--nav).v-list-item--one-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--density-default:not(.v-list-item--nav).v-list-item--two-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--density-default:not(.v-list-item--nav).v-list-item--three-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--density-comfortable{min-height:36px}.v-list-item--density-comfortable.v-list-item--one-line{min-height:44px}.v-list-item--density-comfortable.v-list-item--two-line{min-height:60px;padding-top:8px;padding-bottom:8px}.v-list-item--density-comfortable.v-list-item--three-line{min-height:84px;padding-top:12px;padding-bottom:12px}.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--one-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--two-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--density-comfortable:not(.v-list-item--nav).v-list-item--three-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--density-compact{min-height:32px}.v-list-item--density-compact.v-list-item--one-line{min-height:40px}.v-list-item--density-compact.v-list-item--two-line{min-height:56px;padding-top:4px;padding-bottom:4px}.v-list-item--density-compact.v-list-item--three-line{min-height:80px;padding-top:8px;padding-bottom:8px}.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--one-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--two-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--density-compact:not(.v-list-item--nav).v-list-item--three-line{padding-inline-start:16px;padding-inline-end:16px}.v-list-item--nav{padding-inline-start:8px;padding-inline-end:8px}.v-list .v-list-item--nav:not(:only-child){margin-bottom:4px}.v-list-item__underlay{position:absolute}.v-list-item__overlay{background-color:currentColor;border-radius:inherit;bottom:0;left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:opacity .2s ease-in-out}.v-list-item--active.v-list-item--variant-elevated .v-list-item__overlay{--v-theme-overlay-multiplier: 0}.v-list{--indent-padding: 0px}.v-list--nav{--indent-padding: -8px}.v-list-group{--list-indent-size: 16px;--parent-padding: var(--indent-padding);--prepend-width: 40px}.v-list-group--fluid{--list-indent-size: 0px}.v-list-group--prepend{--parent-padding: calc(var(--indent-padding) + var(--prepend-width))}.v-list-group--fluid.v-list-group--prepend{--parent-padding: var(--indent-padding)}.v-list-group__items{--indent-padding: calc(var(--parent-padding) + var(--list-indent-size))}.v-list-group__items .v-list-item{padding-inline-start:calc(16px + var(--indent-padding))!important}.v-list-group__header.v-list-item--active:not(:focus-visible) .v-list-item__overlay{opacity:0}.v-avatar{flex:none;align-items:center;display:inline-flex;justify-content:center;line-height:normal;overflow:hidden;position:relative;text-align:center;transition:.2s cubic-bezier(.4,0,.2,1);transition-property:width,height;vertical-align:middle;border-radius:50%}.v-avatar.v-avatar--size-x-small{--v-avatar-height: 24px}.v-avatar.v-avatar--size-small{--v-avatar-height: 32px}.v-avatar.v-avatar--size-default{--v-avatar-height: 40px}.v-avatar.v-avatar--size-large{--v-avatar-height: 48px}.v-avatar.v-avatar--size-x-large{--v-avatar-height: 56px}.v-avatar.v-avatar--density-default{height:calc(var(--v-avatar-height) + 0px);width:calc(var(--v-avatar-height) + 0px)}.v-avatar.v-avatar--density-comfortable{height:calc(var(--v-avatar-height) + -4px);width:calc(var(--v-avatar-height) + -4px)}.v-avatar.v-avatar--density-compact{height:calc(var(--v-avatar-height) + -8px);width:calc(var(--v-avatar-height) + -8px)}.v-avatar--variant-plain,.v-avatar--variant-outlined,.v-avatar--variant-text,.v-avatar--variant-tonal{background:transparent;color:inherit}.v-avatar--variant-plain{opacity:.62}.v-avatar--variant-plain:focus,.v-avatar--variant-plain:hover{opacity:1}.v-avatar--variant-plain .v-avatar__overlay{display:none}.v-avatar--variant-elevated,.v-avatar--variant-flat{background:var(--v-theme-surface);color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity))}.v-avatar--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-avatar--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-avatar--variant-outlined{border:thin solid currentColor}.v-avatar--variant-text .v-avatar__overlay{background:currentColor}.v-avatar--variant-tonal .v-avatar__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-avatar--rounded{border-radius:4px}.v-avatar .v-img{height:100%;width:100%}.v-img{--v-theme-overlay-multiplier: 3;z-index:0}.v-img--booting .v-responsive__sizer{transition:none}.v-img__img,.v-img__picture,.v-img__gradient,.v-img__placeholder,.v-img__error{z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%}.v-img__img--preload{filter:blur(4px)}.v-img__img--contain{object-fit:contain}.v-img__img--cover{object-fit:cover}.v-img__gradient{background-repeat:no-repeat}.v-responsive{display:flex;flex:1 0 auto;max-height:100%;max-width:100%;overflow:hidden;position:relative}.v-responsive__content{flex:1 0 0px;max-width:100%}.v-responsive__sizer~.v-responsive__content{margin-inline-start:-100%}.v-responsive__sizer{flex:1 0 0px;transition:padding-bottom .2s cubic-bezier(.4,0,.2,1);pointer-events:none}.v-ripple__container{color:inherit;border-radius:inherit;position:absolute;width:100%;height:100%;left:0;top:0;overflow:hidden;z-index:0;pointer-events:none;contain:strict}.v-ripple__animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;background:currentColor;opacity:0;pointer-events:none;overflow:hidden;will-change:transform,opacity}.v-ripple__animation--enter{transition:none;opacity:0}.v-ripple__animation--in{transition:transform .25s cubic-bezier(0,0,.2,1),opacity .1s cubic-bezier(0,0,.2,1);opacity:calc(.25 * var(--v-theme-overlay-multiplier))}.v-ripple__animation--out{transition:opacity .3s cubic-bezier(0,0,.2,1);opacity:0}.v-alert{display:grid;flex:1 1;grid-template-areas:"prepend content append close" ". content . .";grid-template-columns:max-content auto max-content max-content;position:relative;padding:16px;overflow:hidden;--v-border-color: currentColor;border-radius:4px}.v-alert--absolute{position:absolute}.v-alert--fixed{position:fixed}.v-alert--sticky{position:sticky}.v-alert--variant-plain,.v-alert--variant-outlined,.v-alert--variant-text,.v-alert--variant-tonal{background:transparent;color:inherit}.v-alert--variant-plain{opacity:.62}.v-alert--variant-plain:focus,.v-alert--variant-plain:hover{opacity:1}.v-alert--variant-plain .v-alert__overlay{display:none}.v-alert--variant-elevated,.v-alert--variant-flat{background:rgb(var(--v-theme-on-surface-variant));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-alert--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-alert--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-alert--variant-outlined{border:thin solid currentColor}.v-alert--variant-text .v-alert__overlay{background:currentColor}.v-alert--variant-tonal .v-alert__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-alert--prominent{grid-template-areas:"prepend content append close" "prepend content . ."}.v-alert.v-alert--border{--v-border-opacity: .38}.v-alert.v-alert--border.v-alert--border-start{padding-inline-start:24px}.v-alert.v-alert--border.v-alert--border-end{padding-inline-end:24px}.v-alert--variant-plain{transition:.2s opacity cubic-bezier(.4,0,.2,1)}.v-alert--density-default{padding-bottom:16px;padding-top:16px}.v-alert--density-default.v-alert--border-top{padding-top:24px}.v-alert--density-default.v-alert--border-bottom{padding-bottom:24px}.v-alert--density-comfortable{padding-bottom:12px;padding-top:12px}.v-alert--density-comfortable.v-alert--border-top{padding-top:20px}.v-alert--density-comfortable.v-alert--border-bottom{padding-bottom:20px}.v-alert--density-compact{padding-bottom:8px;padding-top:8px}.v-alert--density-compact.v-alert--border-top{padding-top:16px}.v-alert--density-compact.v-alert--border-bottom{padding-bottom:16px}.v-alert__border{border-radius:inherit;bottom:0;left:0;opacity:var(--v-border-opacity);position:absolute;pointer-events:none;right:0;top:0;width:100%;border-color:currentColor;border-style:solid;border-width:0}.v-alert__border--border{border-width:8px;box-shadow:none}.v-alert--border-start .v-alert__border{border-inline-start-width:8px}.v-alert--border-end .v-alert__border{border-inline-end-width:8px}.v-alert--border-top .v-alert__border{border-top-width:8px}.v-alert--border-bottom .v-alert__border{border-bottom-width:8px}.v-alert__close{flex:0 1 auto;grid-area:close}.v-alert__content{align-self:center;grid-area:content;overflow:hidden}.v-alert__append,.v-alert__close{align-self:flex-start;margin-inline-start:16px}.v-alert__append{align-self:flex-start;grid-area:append}.v-alert__append+.v-alert__close{margin-inline-start:16px}.v-alert__prepend{align-self:flex-start;display:flex;align-items:center;grid-area:prepend;margin-inline-end:16px}.v-alert--prominent .v-alert__prepend{align-self:center}.v-alert__underlay{grid-area:none;position:absolute}.v-alert--border-start .v-alert__underlay{border-top-left-radius:0;border-bottom-left-radius:0}.v-alert--border-end .v-alert__underlay{border-top-right-radius:0;border-bottom-right-radius:0}.v-alert--border-top .v-alert__underlay{border-top-left-radius:0;border-top-right-radius:0}.v-alert--border-bottom .v-alert__underlay{border-bottom-left-radius:0;border-bottom-right-radius:0}.v-alert-title{align-items:center;align-self:center;display:flex;font-size:1.25rem;font-weight:500;hyphens:auto;letter-spacing:.0125em;line-height:1.75rem;overflow-wrap:normal;text-transform:none;word-break:normal;word-wrap:break-word}.v-btn{align-items:center;border-radius:4px;display:inline-grid;grid-template-areas:"prepend content append";grid-template-columns:max-content auto max-content;font-weight:500;justify-content:center;letter-spacing:.0892857143em;line-height:normal;max-width:100%;outline:none;position:relative;text-decoration:none;text-indent:.0892857143em;text-transform:uppercase;transition-property:box-shadow,transform,opacity,background;transition-duration:.28s;transition-timing-function:cubic-bezier(.4,0,.2,1);user-select:none;vertical-align:middle;flex-shrink:0;border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0}.v-btn--size-x-small{--v-btn-size: .625rem;--v-btn-height: 20px;font-size:.625rem;min-width:36px;padding:0 8px}.v-btn--size-small{--v-btn-size: .75rem;--v-btn-height: 28px;font-size:.75rem;min-width:50px;padding:0 12px}.v-btn--size-default{--v-btn-size: .875rem;--v-btn-height: 36px;font-size:.875rem;min-width:64px;padding:0 16px}.v-btn--size-large{--v-btn-size: 1rem;--v-btn-height: 44px;font-size:1rem;min-width:78px;padding:0 20px}.v-btn--size-x-large{--v-btn-size: 1.125rem;--v-btn-height: 52px;font-size:1.125rem;min-width:92px;padding:0 24px}.v-btn.v-btn--density-default{height:calc(var(--v-btn-height) + 0px)}.v-btn.v-btn--density-comfortable{height:calc(var(--v-btn-height) + -8px)}.v-btn.v-btn--density-compact{height:calc(var(--v-btn-height) + -12px)}.v-btn--border{border-width:thin;box-shadow:none}.v-btn--absolute{position:absolute}.v-btn--fixed{position:fixed}.v-btn:hover>.v-btn__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-btn:focus-visible>.v-btn__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-btn:focus>.v-btn__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}}.v-btn--active>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]>.v-btn__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-btn--active:hover>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:hover>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-btn--active:focus-visible>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-btn--active:focus>.v-btn__overlay,.v-btn[aria-haspopup=menu][aria-expanded=true]:focus>.v-btn__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-btn--variant-plain,.v-btn--variant-outlined,.v-btn--variant-text,.v-btn--variant-tonal{background:transparent;color:inherit}.v-btn--variant-plain{opacity:.62}.v-btn--variant-plain:focus,.v-btn--variant-plain:hover{opacity:1}.v-btn--variant-plain .v-btn__overlay{display:none}.v-btn--variant-elevated,.v-btn--variant-flat{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-btn--variant-elevated{box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 5px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-btn--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-btn--variant-outlined{border:thin solid currentColor}.v-btn--variant-text .v-btn__overlay{background:currentColor}.v-btn--variant-tonal .v-btn__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}@supports selector(:focus-visible){.v-btn:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;border:2px solid currentColor;border-radius:inherit;opacity:0;transition:opacity .2s ease-in-out}.v-btn:focus-visible:after{opacity:calc(.25 * var(--v-theme-overlay-multiplier))}}.v-btn--icon{border-radius:50%;min-width:0;padding:0}.v-btn--icon.v-btn--size-default{font-size:1rem}.v-btn--icon.v-btn--density-default{width:calc(var(--v-btn-height) + 12px);height:calc(var(--v-btn-height) + 12px)}.v-btn--icon.v-btn--density-comfortable{width:calc(var(--v-btn-height) + 0px);height:calc(var(--v-btn-height) + 0px)}.v-btn--icon.v-btn--density-compact{width:calc(var(--v-btn-height) + -8px);height:calc(var(--v-btn-height) + -8px)}.v-btn--elevated:hover,.v-btn--elevated:focus{box-shadow:0 2px 4px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 4px 5px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 10px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-btn--elevated:active{box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 3px 14px 2px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-btn--flat{box-shadow:none}.v-btn--block{display:flex;flex:1 0 auto;min-width:100%}.v-btn--disabled{pointer-events:none;opacity:.26}.v-btn--disabled.v-btn--variant-elevated,.v-btn--disabled.v-btn--variant-flat{box-shadow:none;opacity:1;color:rgba(var(--v-theme-on-surface),.26);background:rgb(var(--v-theme-surface))}.v-btn--disabled.v-btn--variant-elevated .v-btn__overlay,.v-btn--disabled.v-btn--variant-flat .v-btn__overlay{opacity:.4615384615}.v-btn--loading{pointer-events:none}.v-btn--loading .v-btn__content,.v-btn--loading .v-btn__prepend,.v-btn--loading .v-btn__append{opacity:0}.v-btn--stacked{grid-template-areas:"prepend" "content" "append";grid-template-columns:auto;grid-template-rows:max-content max-content max-content;justify-items:center;align-content:center}.v-btn--stacked .v-btn__content{flex-direction:column;line-height:1.25}.v-btn--stacked .v-btn__prepend,.v-btn--stacked .v-btn__append,.v-btn--stacked .v-btn__content>.v-icon--start,.v-btn--stacked .v-btn__content>.v-icon--end{margin-inline-start:0;margin-inline-end:0}.v-btn--stacked .v-btn__prepend,.v-btn--stacked .v-btn__content>.v-icon--start{margin-bottom:4px}.v-btn--stacked .v-btn__append,.v-btn--stacked .v-btn__content>.v-icon--end{margin-top:4px}.v-btn--stacked.v-btn--size-x-small{--v-btn-size: .625rem;--v-btn-height: 56px;font-size:.625rem;min-width:56px;padding:0 12px}.v-btn--stacked.v-btn--size-small{--v-btn-size: .75rem;--v-btn-height: 64px;font-size:.75rem;min-width:64px;padding:0 14px}.v-btn--stacked.v-btn--size-default{--v-btn-size: .875rem;--v-btn-height: 72px;font-size:.875rem;min-width:72px;padding:0 16px}.v-btn--stacked.v-btn--size-large{--v-btn-size: 1rem;--v-btn-height: 80px;font-size:1rem;min-width:80px;padding:0 18px}.v-btn--stacked.v-btn--size-x-large{--v-btn-size: 1.125rem;--v-btn-height: 88px;font-size:1.125rem;min-width:88px;padding:0 20px}.v-btn--stacked.v-btn--density-default{height:calc(var(--v-btn-height) + 0px)}.v-btn--stacked.v-btn--density-comfortable{height:calc(var(--v-btn-height) + -16px)}.v-btn--stacked.v-btn--density-compact{height:calc(var(--v-btn-height) + -24px)}.v-btn--rounded{border-radius:24px}.v-btn .v-icon{--v-icon-size-multiplier: .8571428571}.v-btn--icon .v-icon{--v-icon-size-multiplier: 1}.v-btn--stacked .v-icon{--v-icon-size-multiplier: 1.1428571429}.v-btn__loader{align-items:center;display:flex;height:100%;justify-content:center;left:0;position:absolute;top:0;width:100%}.v-btn__content,.v-btn__prepend,.v-btn__append{align-items:center;display:flex;transition:transform,opacity .2s cubic-bezier(.4,0,.2,1)}.v-btn__prepend{grid-area:prepend;margin-inline-start:calc(var(--v-btn-height) / -9);margin-inline-end:calc(var(--v-btn-height) / 4.5)}.v-btn__append{grid-area:append;margin-inline-start:calc(var(--v-btn-height) / 4.5);margin-inline-end:calc(var(--v-btn-height) / -9)}.v-btn__content{grid-area:content;justify-content:center;white-space:nowrap}.v-btn__content>.v-icon--start{margin-inline-start:calc(var(--v-btn-height) / -9);margin-inline-end:calc(var(--v-btn-height) / 4.5)}.v-btn__content>.v-icon--end{margin-inline-start:calc(var(--v-btn-height) / 4.5);margin-inline-end:calc(var(--v-btn-height) / -9)}.v-btn--stacked .v-btn__content{white-space:normal}.v-btn__overlay{background-color:currentColor;border-radius:inherit;opacity:0;transition:opacity .2s ease-in-out}.v-btn__overlay,.v-btn__underlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.v-card-actions .v-btn{padding:0 8px}.v-card-actions .v-btn~.v-btn{margin-inline-start:.5rem}.v-banner-actions .v-btn{padding:0 8px}.v-pagination .v-btn{border-radius:4px}.v-btn__overlay{transition:none}.v-pagination__item--is-active .v-btn__overlay{opacity:var(--v-border-opacity)}.v-snackbar-actions .v-btn{padding:0 8px}.v-btn-toggle .v-btn.v-btn--selected:not(.v-btn--disabled) .v-btn__overlay{opacity:var(--v-activated-opacity)}.v-btn-group{display:inline-flex;flex-wrap:nowrap;max-width:100%;min-width:0;overflow:hidden;vertical-align:middle;border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0;box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12));border-radius:4px;background:transparent;color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-btn-group--border{border-width:thin;box-shadow:none}.v-btn-group--density-default.v-btn-group{height:48px}.v-btn-group--density-comfortable.v-btn-group{height:40px}.v-btn-group--density-compact.v-btn-group{height:36px}.v-btn-group .v-btn{border-radius:0;border-color:inherit}.v-btn-group .v-btn:not(:last-child){border-inline-end:none}.v-btn-group .v-btn:not(:first-child){border-inline-start:none}.v-btn-group .v-btn:first-child{border-start-start-radius:inherit;border-end-start-radius:inherit}.v-btn-group .v-btn:last-child{border-start-end-radius:inherit;border-end-end-radius:inherit}.v-btn-group--divided .v-btn:not(:last-child){border-inline-end-width:thin;border-inline-end-style:solid;border-inline-end-color:rgba(var(--v-border-color),var(--v-border-opacity))}.v-btn-group--tile{border-radius:0}.v-progress-circular{align-items:center;display:inline-flex;justify-content:center;position:relative;vertical-align:middle}.v-progress-circular>svg{width:100%;height:100%;margin:auto;position:absolute;top:0;bottom:0;left:0;right:0;z-index:0}.v-progress-circular__content{align-items:center;display:flex;justify-content:center}.v-progress-circular__underlay{color:rgba(var(--v-border-color),var(--v-border-opacity));stroke:currentColor;z-index:1}.v-progress-circular__overlay{stroke:currentColor;transition:all .2s ease-in-out,stroke-width 0s;z-index:2}.v-progress-circular--size-x-small{height:16px;width:16px}.v-progress-circular--size-small{height:24px;width:24px}.v-progress-circular--size-default{height:32px;width:32px}.v-progress-circular--size-large{height:48px;width:48px}.v-progress-circular--size-x-large{height:64px;width:64px}.v-progress-circular--indeterminate>svg{animation:progress-circular-rotate 1.4s linear infinite;transform-origin:center center;transition:all .2s ease-in-out}.v-progress-circular--indeterminate .v-progress-circular__overlay{animation:progress-circular-dash 1.4s ease-in-out infinite;stroke-dasharray:25,200;stroke-dashoffset:0;stroke-linecap:round}.v-progress-circular--disable-shrink>svg{animation-duration:.7s}.v-progress-circular--disable-shrink .v-progress-circular__overlay{animation:none}.v-progress-circular--indeterminate:not(.v-progress-circular--visible)>svg,.v-progress-circular--indeterminate:not(.v-progress-circular--visible) .v-progress-circular__overlay{animation-play-state:paused!important}@keyframes progress-circular-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0px}50%{stroke-dasharray:100,200;stroke-dashoffset:-15px}to{stroke-dasharray:100,200;stroke-dashoffset:-124px}}@keyframes progress-circular-rotate{to{transform:rotate(270deg)}}.v-progress-linear{background:transparent;overflow:hidden;position:relative;transition:.2s cubic-bezier(.4,0,.2,1);width:100%}.v-progress-linear__background{background:currentColor;bottom:0;left:0;opacity:var(--v-border-opacity);position:absolute;top:0;transition-property:width,left,right;transition:inherit}.v-progress-linear__content{align-items:center;display:flex;height:100%;justify-content:center;left:0;pointer-events:none;position:absolute;top:0;width:100%}.v-progress-linear__determinate,.v-progress-linear__indeterminate{background:currentColor}.v-progress-linear__determinate{height:inherit;left:0;position:absolute;transition:inherit;transition-property:width,left,right}.v-progress-linear__indeterminate .long,.v-progress-linear__indeterminate .short{animation-play-state:paused;animation-duration:2.2s;animation-iteration-count:infinite;bottom:0;height:inherit;left:0;position:absolute;right:auto;top:0;width:auto;will-change:left,right}.v-progress-linear__indeterminate .long{animation-name:indeterminate-ltr}.v-progress-linear__indeterminate .short{animation-name:indeterminate-short-ltr}.v-progress-linear__stream{animation:stream .25s infinite linear;animation-play-state:paused;bottom:0;left:auto;opacity:.3;pointer-events:none;position:absolute;transition:inherit;transition-property:width,left,right}.v-progress-linear--reverse .v-progress-linear__background,.v-progress-linear--reverse .v-progress-linear__determinate,.v-progress-linear--reverse .v-progress-linear__content,.v-progress-linear--reverse .v-progress-linear__indeterminate .long,.v-progress-linear--reverse .v-progress-linear__indeterminate .short{left:auto;right:0}.v-progress-linear--reverse .v-progress-linear__indeterminate .long{animation-name:indeterminate-rtl}.v-progress-linear--reverse .v-progress-linear__indeterminate .short{animation-name:indeterminate-short-rtl}.v-progress-linear--reverse .v-progress-linear__stream{right:auto}.v-progress-linear--absolute,.v-progress-linear--fixed{left:0;z-index:1}.v-progress-linear--absolute{position:absolute}.v-progress-linear--fixed{position:fixed}.v-progress-linear--rounded{border-radius:4px}.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__determinate,.v-progress-linear--rounded.v-progress-linear--rounded-bar .v-progress-linear__indeterminate{border-radius:inherit}.v-progress-linear--striped .v-progress-linear__determinate{animation:progress-linear-stripes 1s infinite linear;background-image:linear-gradient(135deg,hsla(0,0%,100%,.25) 25%,transparent 0,transparent 50%,hsla(0,0%,100%,.25) 0,hsla(0,0%,100%,.25) 75%,transparent 0,transparent);background-repeat:repeat;background-size:var(--v-progress-linear-height)}.v-progress-linear--active .v-progress-linear__indeterminate .long,.v-progress-linear--active .v-progress-linear__indeterminate .short,.v-progress-linear--active .v-progress-linear__stream{animation-play-state:running}.v-progress-linear--rounded-bar .v-progress-linear__determinate,.v-progress-linear--rounded-bar .v-progress-linear__indeterminate,.v-progress-linear--rounded-bar .v-progress-linear__stream+.v-progress-linear__background{border-radius:4px}.v-progress-linear--rounded-bar .v-progress-linear__determinate.v-locale--is-ltr,.v-locale--is-ltr .v-progress-linear--rounded-bar .v-progress-linear__determinate{border-top-left-radius:0;border-bottom-left-radius:0}.v-progress-linear--rounded-bar .v-progress-linear__determinate.v-locale--is-rtl,.v-locale--is-rtl .v-progress-linear--rounded-bar .v-progress-linear__determinate{border-top-right-radius:0;border-bottom-right-radius:0}@keyframes indeterminate-ltr{0%{left:-90%;right:100%}60%{left:-90%;right:100%}to{left:100%;right:-35%}}@keyframes indeterminate-rtl{0%{left:100%;right:-90%}60%{left:100%;right:-90%}to{left:-35%;right:100%}}@keyframes indeterminate-short-ltr{0%{left:-200%;right:100%}60%{left:107%;right:-8%}to{left:107%;right:-8%}}@keyframes indeterminate-short-rtl{0%{left:100%;right:-200%}60%{left:-8%;right:107%}to{left:-8%;right:107%}}@keyframes stream{to{transform:translate(var(--v-progress-linear-stream-to))}}@keyframes progress-linear-stripes{0%{background-position-x:var(--v-progress-linear-height)}}.v-card{display:block;overflow:hidden;overflow-wrap:break-word;position:relative;padding:0;text-decoration:none;transition-duration:.28s;transition-property:box-shadow,opacity,background;transition-timing-function:cubic-bezier(.4,0,.2,1);z-index:0;border-color:rgba(var(--v-border-color),var(--v-border-opacity));border-style:solid;border-width:0;border-radius:4px}.v-card--border{border-width:thin;box-shadow:none}.v-card--absolute{position:absolute}.v-card--fixed{position:fixed}.v-card:hover>.v-card__overlay{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-card:focus-visible>.v-card__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-card:focus>.v-card__overlay{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}}.v-card--active>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]>.v-card__overlay{opacity:calc(var(--v-activated-opacity) * var(--v-theme-overlay-multiplier))}.v-card--active:hover>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:hover>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}.v-card--active:focus-visible>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:focus-visible>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}@supports not selector(:focus-visible){.v-card--active:focus>.v-card__overlay,.v-card[aria-haspopup=menu][aria-expanded=true]:focus>.v-card__overlay{opacity:calc((var(--v-activated-opacity) + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}}.v-card--variant-plain,.v-card--variant-outlined,.v-card--variant-text,.v-card--variant-tonal{background:transparent;color:inherit}.v-card--variant-plain{opacity:.62}.v-card--variant-plain:focus,.v-card--variant-plain:hover{opacity:1}.v-card--variant-plain .v-card__overlay{display:none}.v-card--variant-elevated,.v-card--variant-flat{background:rgb(var(--v-theme-surface));color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity))}.v-card--variant-elevated{box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-card--variant-flat{box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-card--variant-outlined{border:thin solid currentColor}.v-card--variant-text .v-card__overlay{background:currentColor}.v-card--variant-tonal .v-card__underlay{background:currentColor;opacity:var(--v-activated-opacity);border-radius:inherit;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.v-card--disabled{pointer-events:none;user-select:none}.v-card--disabled>:not(.v-card__loader){opacity:.6}.v-card--flat{box-shadow:none}.v-card--hover{cursor:pointer;box-shadow:0 0 0 0 var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 0 0 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-card--hover:before,.v-card--hover:after{border-radius:inherit;bottom:0;content:"";display:block;left:0;pointer-events:none;position:absolute;right:0;top:0;transition:inherit}.v-card--hover:before{opacity:1;z-index:-1;box-shadow:0 2px 1px -1px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 1px 1px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 3px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-card--hover:after{z-index:1;opacity:0;box-shadow:0 5px 5px -3px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 8px 10px 1px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 3px 14px 2px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-card--hover:hover:after{opacity:1}.v-card--hover:hover:before{opacity:0}.v-card--link{cursor:pointer}.v-card-actions{align-items:center;display:flex;flex:none;min-height:52px;padding:.5rem}.v-card-item{align-items:center;display:grid;flex:none;grid-template-areas:"prepend content append";grid-template-columns:max-content auto max-content;padding:.625rem 1rem}.v-card-item+.v-card-text{padding-top:0}.v-card-item__prepend{grid-area:prepend;padding-inline-end:1rem}.v-card-item__append{grid-area:append;padding-inline-start:1rem}.v-card-item__content{align-self:center;grid-area:content;overflow:hidden}.v-card-title{display:block;flex:none;font-size:1.25rem;font-weight:500;hyphens:auto;letter-spacing:.0125em;min-width:0;overflow-wrap:normal;overflow:hidden;padding:.5rem 1rem;text-overflow:ellipsis;text-transform:none;white-space:nowrap;word-break:normal;word-wrap:break-word}.v-card .v-card-title{line-height:2rem}.v-card--density-comfortable .v-card-title{line-height:1.75rem}.v-card--density-compact .v-card-title{line-height:1.55rem}.v-card-item .v-card-title{padding:0}.v-card-title+.v-card-text,.v-card-title+.v-card-actions{padding-top:0}.v-card-subtitle{display:block;flex:none;font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;opacity:var(--v-medium-emphasis-opacity);overflow:hidden;padding:0 1rem;text-overflow:ellipsis;text-transform:none;white-space:nowrap}.v-card .v-card-subtitle{line-height:1.25rem}.v-card--density-comfortable .v-card-subtitle{line-height:1.125rem}.v-card--density-compact .v-card-subtitle{line-height:1rem}.v-card-item .v-card-subtitle{padding:0 0 .25rem}.v-card-text{flex:1 1 auto;font-size:.875rem;font-weight:400;letter-spacing:.0178571429em;padding:1rem;text-transform:none}.v-card .v-card-text{line-height:1.25rem}.v-card--density-comfortable .v-card-text{line-height:1.2rem}.v-card--density-compact .v-card-text{line-height:1.15rem}.v-card__image{display:flex;height:100%;flex:1 1 auto;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:-1}.v-card__content{border-radius:inherit;overflow:hidden;position:relative}.v-card__loader{bottom:auto;top:0;left:0;position:absolute;right:0;width:100%;z-index:1}.v-card__overlay{background-color:currentColor;border-radius:inherit;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;opacity:0;transition:opacity .2s ease-in-out}.v-checkbox .v-selection-control{min-height:var(--v-input-control-height)}.v-input{display:grid;flex:1 1 auto;font-size:1rem;font-weight:400;line-height:1.5}.v-input--disabled{pointer-events:none}.v-input--density-default{--v-input-control-height: 56px;--v-input-padding-top: 16px}.v-input--density-comfortable{--v-input-control-height: 48px;--v-input-padding-top: 12px}.v-input--density-compact{--v-input-control-height: 40px;--v-input-padding-top: 8px}.v-input--vertical{grid-template-areas:"append" "control" "prepend";grid-template-rows:max-content auto max-content;grid-template-columns:min-content}.v-input--vertical .v-input__prepend{margin-block-start:16px}.v-input--vertical .v-input__append{margin-block-end:16px}.v-input--horizontal{grid-template-areas:"prepend control append" "a messages b";grid-template-columns:max-content minmax(0,1fr) max-content;grid-template-rows:auto auto}.v-input--horizontal .v-input__prepend{margin-inline-end:16px}.v-input--horizontal .v-input__append{margin-inline-start:16px}.v-input__details{align-items:flex-end;display:flex;font-size:.75rem;font-weight:400;grid-area:messages;letter-spacing:.0333333333em;line-height:normal;min-height:22px;padding-top:6px;overflow:hidden;justify-content:space-between}.v-input__details>.v-icon,.v-input__prepend>.v-icon,.v-input__append>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-input--disabled .v-input__details>.v-icon,.v-input--disabled .v-input__details .v-messages,.v-input--error .v-input__details>.v-icon,.v-input--error .v-input__details .v-messages,.v-input--disabled .v-input__prepend>.v-icon,.v-input--disabled .v-input__prepend .v-messages,.v-input--error .v-input__prepend>.v-icon,.v-input--error .v-input__prepend .v-messages,.v-input--disabled .v-input__append>.v-icon,.v-input--disabled .v-input__append .v-messages,.v-input--error .v-input__append>.v-icon,.v-input--error .v-input__append .v-messages{opacity:1}.v-input--disabled .v-input__details,.v-input--disabled .v-input__prepend,.v-input--disabled .v-input__append{opacity:var(--v-disabled-opacity)}.v-input--error:not(.v-input--disabled) .v-input__details>.v-icon,.v-input--error:not(.v-input--disabled) .v-input__details .v-messages,.v-input--error:not(.v-input--disabled) .v-input__prepend>.v-icon,.v-input--error:not(.v-input--disabled) .v-input__prepend .v-messages,.v-input--error:not(.v-input--disabled) .v-input__append>.v-icon,.v-input--error:not(.v-input--disabled) .v-input__append .v-messages{color:rgb(var(--v-theme-error))}.v-input__prepend,.v-input__append{display:flex;padding-top:var(--v-input-padding-top)}.v-input__prepend{grid-area:prepend}.v-input__append{grid-area:append}.v-input__control{display:flex;grid-area:control}.v-messages{flex:1 1 auto;font-size:12px;min-height:14px;min-width:1px;opacity:var(--v-medium-emphasis-opacity);position:relative}.v-messages__message{line-height:12px;word-break:break-word;overflow-wrap:break-word;word-wrap:break-word;hyphens:auto;transition-duration:.15s}.v-selection-control{align-items:center;contain:layout;display:flex;flex:1 0;grid-area:control;position:relative;user-select:none}.v-selection-control .v-label{white-space:normal;word-break:break-word;height:100%;width:100%}.v-selection-control--disabled{opacity:var(--v-disabled-opacity);pointer-events:none}.v-selection-control--error .v-label,.v-selection-control--disabled .v-label{opacity:1}.v-selection-control--error:not(.v-selection-control--disabled) .v-label{color:rgb(var(--v-theme-error))}.v-selection-control--inline{display:inline-flex;flex:0 0 auto;min-width:0;max-width:100%}.v-selection-control--inline .v-label{width:auto}.v-selection-control--density-default{--v-selection-control-size: 40px}.v-selection-control--density-comfortable{--v-selection-control-size: 36px}.v-selection-control--density-compact{--v-selection-control-size: 28px}.v-selection-control__wrapper{width:var(--v-selection-control-size);height:var(--v-selection-control-size);display:inline-flex;align-items:center;position:relative;justify-content:center;flex:none}.v-selection-control__input{width:var(--v-selection-control-size);height:var(--v-selection-control-size);align-items:center;display:flex;flex:none;justify-content:center;position:relative;border-radius:50%}.v-selection-control__input input{cursor:pointer;position:absolute;left:0;top:0;width:100%;height:100%;opacity:0}.v-selection-control__input:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:100%;background-color:currentColor;opacity:0;pointer-events:none}.v-selection-control__input:hover:before{opacity:calc(var(--v-hover-opacity) * var(--v-theme-overlay-multiplier))}.v-selection-control__input>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-selection-control--disabled .v-selection-control__input>.v-icon,.v-selection-control--dirty .v-selection-control__input>.v-icon,.v-selection-control--error .v-selection-control__input>.v-icon{opacity:1}.v-selection-control--error:not(.v-selection-control--disabled) .v-selection-control__input>.v-icon{color:rgb(var(--v-theme-error))}.v-selection-control--focus-visible .v-selection-control__input:before{opacity:calc(var(--v-focus-opacity) * var(--v-theme-overlay-multiplier))}.v-label{align-items:center;display:inline-flex;font-size:1rem;letter-spacing:.009375em;min-width:0;opacity:var(--v-medium-emphasis-opacity);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.v-label--clickable{cursor:pointer}.v-selection-control-group{grid-area:control;display:flex;flex-direction:column}.v-selection-control-group--inline{flex-direction:row;flex-wrap:wrap}.v-container{width:100%;padding:16px;margin-right:auto;margin-left:auto}@media (min-width: 960px){.v-container{max-width:900px}}@media (min-width: 1280px){.v-container{max-width:1200px}}@media (min-width: 1920px){.v-container{max-width:1800px}}@media (min-width: 2560px){.v-container{max-width:2400px}}.v-container--fluid{max-width:100%}.v-container.fill-height{align-items:center;display:flex;flex-wrap:wrap}.v-row{display:flex;flex-wrap:wrap;flex:1 1 auto;margin:-12px}.v-row+.v-row{margin-top:12px}.v-row+.v-row--dense{margin-top:4px}.v-row--dense{margin:-4px}.v-row--dense>.v-col,.v-row--dense>[class*=v-col-]{padding:4px}.v-row.v-row--no-gutters{margin:0}.v-row.v-row--no-gutters>.v-col,.v-row.v-row--no-gutters>[class*=v-col-]{padding:0}.v-col-xxl,.v-col-xxl-auto,.v-col-xxl-12,.v-col-xxl-11,.v-col-xxl-10,.v-col-xxl-9,.v-col-xxl-8,.v-col-xxl-7,.v-col-xxl-6,.v-col-xxl-5,.v-col-xxl-4,.v-col-xxl-3,.v-col-xxl-2,.v-col-xxl-1,.v-col-xl,.v-col-xl-auto,.v-col-xl-12,.v-col-xl-11,.v-col-xl-10,.v-col-xl-9,.v-col-xl-8,.v-col-xl-7,.v-col-xl-6,.v-col-xl-5,.v-col-xl-4,.v-col-xl-3,.v-col-xl-2,.v-col-xl-1,.v-col-lg,.v-col-lg-auto,.v-col-lg-12,.v-col-lg-11,.v-col-lg-10,.v-col-lg-9,.v-col-lg-8,.v-col-lg-7,.v-col-lg-6,.v-col-lg-5,.v-col-lg-4,.v-col-lg-3,.v-col-lg-2,.v-col-lg-1,.v-col-md,.v-col-md-auto,.v-col-md-12,.v-col-md-11,.v-col-md-10,.v-col-md-9,.v-col-md-8,.v-col-md-7,.v-col-md-6,.v-col-md-5,.v-col-md-4,.v-col-md-3,.v-col-md-2,.v-col-md-1,.v-col-sm,.v-col-sm-auto,.v-col-sm-12,.v-col-sm-11,.v-col-sm-10,.v-col-sm-9,.v-col-sm-8,.v-col-sm-7,.v-col-sm-6,.v-col-sm-5,.v-col-sm-4,.v-col-sm-3,.v-col-sm-2,.v-col-sm-1,.v-col,.v-col-auto,.v-col-12,.v-col-11,.v-col-10,.v-col-9,.v-col-8,.v-col-7,.v-col-6,.v-col-5,.v-col-4,.v-col-3,.v-col-2,.v-col-1{width:100%;padding:12px}.v-col{flex-basis:0;flex-grow:1;max-width:100%}.v-col-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-3{flex:0 0 25%;max-width:25%}.v-col-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-6{flex:0 0 50%;max-width:50%}.v-col-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-9{flex:0 0 75%;max-width:75%}.v-col-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-12{flex:0 0 100%;max-width:100%}.offset-1.v-locale--is-ltr,.v-locale--is-ltr .offset-1{margin-left:8.3333333333%}.offset-1.v-locale--is-rtl,.v-locale--is-rtl .offset-1{margin-right:8.3333333333%}.offset-2.v-locale--is-ltr,.v-locale--is-ltr .offset-2{margin-left:16.6666666667%}.offset-2.v-locale--is-rtl,.v-locale--is-rtl .offset-2{margin-right:16.6666666667%}.offset-3.v-locale--is-ltr,.v-locale--is-ltr .offset-3{margin-left:25%}.offset-3.v-locale--is-rtl,.v-locale--is-rtl .offset-3{margin-right:25%}.offset-4.v-locale--is-ltr,.v-locale--is-ltr .offset-4{margin-left:33.3333333333%}.offset-4.v-locale--is-rtl,.v-locale--is-rtl .offset-4{margin-right:33.3333333333%}.offset-5.v-locale--is-ltr,.v-locale--is-ltr .offset-5{margin-left:41.6666666667%}.offset-5.v-locale--is-rtl,.v-locale--is-rtl .offset-5{margin-right:41.6666666667%}.offset-6.v-locale--is-ltr,.v-locale--is-ltr .offset-6{margin-left:50%}.offset-6.v-locale--is-rtl,.v-locale--is-rtl .offset-6{margin-right:50%}.offset-7.v-locale--is-ltr,.v-locale--is-ltr .offset-7{margin-left:58.3333333333%}.offset-7.v-locale--is-rtl,.v-locale--is-rtl .offset-7{margin-right:58.3333333333%}.offset-8.v-locale--is-ltr,.v-locale--is-ltr .offset-8{margin-left:66.6666666667%}.offset-8.v-locale--is-rtl,.v-locale--is-rtl .offset-8{margin-right:66.6666666667%}.offset-9.v-locale--is-ltr,.v-locale--is-ltr .offset-9{margin-left:75%}.offset-9.v-locale--is-rtl,.v-locale--is-rtl .offset-9{margin-right:75%}.offset-10.v-locale--is-ltr,.v-locale--is-ltr .offset-10{margin-left:83.3333333333%}.offset-10.v-locale--is-rtl,.v-locale--is-rtl .offset-10{margin-right:83.3333333333%}.offset-11.v-locale--is-ltr,.v-locale--is-ltr .offset-11{margin-left:91.6666666667%}.offset-11.v-locale--is-rtl,.v-locale--is-rtl .offset-11{margin-right:91.6666666667%}@media (min-width: 600px){.v-col-sm{flex-basis:0;flex-grow:1;max-width:100%}.v-col-sm-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-sm-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-sm-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-sm-3{flex:0 0 25%;max-width:25%}.v-col-sm-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-sm-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-sm-6{flex:0 0 50%;max-width:50%}.v-col-sm-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-sm-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-sm-9{flex:0 0 75%;max-width:75%}.v-col-sm-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-sm-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-sm-12{flex:0 0 100%;max-width:100%}.offset-sm-0.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-0{margin-left:0}.offset-sm-0.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-0{margin-right:0}.offset-sm-1.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-1{margin-left:8.3333333333%}.offset-sm-1.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-1{margin-right:8.3333333333%}.offset-sm-2.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-2{margin-left:16.6666666667%}.offset-sm-2.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-2{margin-right:16.6666666667%}.offset-sm-3.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-3{margin-left:25%}.offset-sm-3.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-3{margin-right:25%}.offset-sm-4.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-4{margin-left:33.3333333333%}.offset-sm-4.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-4{margin-right:33.3333333333%}.offset-sm-5.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-5{margin-left:41.6666666667%}.offset-sm-5.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-5{margin-right:41.6666666667%}.offset-sm-6.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-6{margin-left:50%}.offset-sm-6.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-6{margin-right:50%}.offset-sm-7.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-7{margin-left:58.3333333333%}.offset-sm-7.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-7{margin-right:58.3333333333%}.offset-sm-8.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-8{margin-left:66.6666666667%}.offset-sm-8.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-8{margin-right:66.6666666667%}.offset-sm-9.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-9{margin-left:75%}.offset-sm-9.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-9{margin-right:75%}.offset-sm-10.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-10{margin-left:83.3333333333%}.offset-sm-10.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-10{margin-right:83.3333333333%}.offset-sm-11.v-locale--is-ltr,.v-locale--is-ltr .offset-sm-11{margin-left:91.6666666667%}.offset-sm-11.v-locale--is-rtl,.v-locale--is-rtl .offset-sm-11{margin-right:91.6666666667%}}@media (min-width: 960px){.v-col-md{flex-basis:0;flex-grow:1;max-width:100%}.v-col-md-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-md-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-md-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-md-3{flex:0 0 25%;max-width:25%}.v-col-md-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-md-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-md-6{flex:0 0 50%;max-width:50%}.v-col-md-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-md-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-md-9{flex:0 0 75%;max-width:75%}.v-col-md-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-md-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-md-12{flex:0 0 100%;max-width:100%}.offset-md-0.v-locale--is-ltr,.v-locale--is-ltr .offset-md-0{margin-left:0}.offset-md-0.v-locale--is-rtl,.v-locale--is-rtl .offset-md-0{margin-right:0}.offset-md-1.v-locale--is-ltr,.v-locale--is-ltr .offset-md-1{margin-left:8.3333333333%}.offset-md-1.v-locale--is-rtl,.v-locale--is-rtl .offset-md-1{margin-right:8.3333333333%}.offset-md-2.v-locale--is-ltr,.v-locale--is-ltr .offset-md-2{margin-left:16.6666666667%}.offset-md-2.v-locale--is-rtl,.v-locale--is-rtl .offset-md-2{margin-right:16.6666666667%}.offset-md-3.v-locale--is-ltr,.v-locale--is-ltr .offset-md-3{margin-left:25%}.offset-md-3.v-locale--is-rtl,.v-locale--is-rtl .offset-md-3{margin-right:25%}.offset-md-4.v-locale--is-ltr,.v-locale--is-ltr .offset-md-4{margin-left:33.3333333333%}.offset-md-4.v-locale--is-rtl,.v-locale--is-rtl .offset-md-4{margin-right:33.3333333333%}.offset-md-5.v-locale--is-ltr,.v-locale--is-ltr .offset-md-5{margin-left:41.6666666667%}.offset-md-5.v-locale--is-rtl,.v-locale--is-rtl .offset-md-5{margin-right:41.6666666667%}.offset-md-6.v-locale--is-ltr,.v-locale--is-ltr .offset-md-6{margin-left:50%}.offset-md-6.v-locale--is-rtl,.v-locale--is-rtl .offset-md-6{margin-right:50%}.offset-md-7.v-locale--is-ltr,.v-locale--is-ltr .offset-md-7{margin-left:58.3333333333%}.offset-md-7.v-locale--is-rtl,.v-locale--is-rtl .offset-md-7{margin-right:58.3333333333%}.offset-md-8.v-locale--is-ltr,.v-locale--is-ltr .offset-md-8{margin-left:66.6666666667%}.offset-md-8.v-locale--is-rtl,.v-locale--is-rtl .offset-md-8{margin-right:66.6666666667%}.offset-md-9.v-locale--is-ltr,.v-locale--is-ltr .offset-md-9{margin-left:75%}.offset-md-9.v-locale--is-rtl,.v-locale--is-rtl .offset-md-9{margin-right:75%}.offset-md-10.v-locale--is-ltr,.v-locale--is-ltr .offset-md-10{margin-left:83.3333333333%}.offset-md-10.v-locale--is-rtl,.v-locale--is-rtl .offset-md-10{margin-right:83.3333333333%}.offset-md-11.v-locale--is-ltr,.v-locale--is-ltr .offset-md-11{margin-left:91.6666666667%}.offset-md-11.v-locale--is-rtl,.v-locale--is-rtl .offset-md-11{margin-right:91.6666666667%}}@media (min-width: 1280px){.v-col-lg{flex-basis:0;flex-grow:1;max-width:100%}.v-col-lg-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-lg-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-lg-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-lg-3{flex:0 0 25%;max-width:25%}.v-col-lg-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-lg-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-lg-6{flex:0 0 50%;max-width:50%}.v-col-lg-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-lg-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-lg-9{flex:0 0 75%;max-width:75%}.v-col-lg-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-lg-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-lg-12{flex:0 0 100%;max-width:100%}.offset-lg-0.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-0{margin-left:0}.offset-lg-0.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-0{margin-right:0}.offset-lg-1.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-1{margin-left:8.3333333333%}.offset-lg-1.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-1{margin-right:8.3333333333%}.offset-lg-2.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-2{margin-left:16.6666666667%}.offset-lg-2.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-2{margin-right:16.6666666667%}.offset-lg-3.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-3{margin-left:25%}.offset-lg-3.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-3{margin-right:25%}.offset-lg-4.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-4{margin-left:33.3333333333%}.offset-lg-4.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-4{margin-right:33.3333333333%}.offset-lg-5.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-5{margin-left:41.6666666667%}.offset-lg-5.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-5{margin-right:41.6666666667%}.offset-lg-6.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-6{margin-left:50%}.offset-lg-6.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-6{margin-right:50%}.offset-lg-7.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-7{margin-left:58.3333333333%}.offset-lg-7.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-7{margin-right:58.3333333333%}.offset-lg-8.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-8{margin-left:66.6666666667%}.offset-lg-8.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-8{margin-right:66.6666666667%}.offset-lg-9.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-9{margin-left:75%}.offset-lg-9.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-9{margin-right:75%}.offset-lg-10.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-10{margin-left:83.3333333333%}.offset-lg-10.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-10{margin-right:83.3333333333%}.offset-lg-11.v-locale--is-ltr,.v-locale--is-ltr .offset-lg-11{margin-left:91.6666666667%}.offset-lg-11.v-locale--is-rtl,.v-locale--is-rtl .offset-lg-11{margin-right:91.6666666667%}}@media (min-width: 1920px){.v-col-xl{flex-basis:0;flex-grow:1;max-width:100%}.v-col-xl-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-xl-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-xl-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-xl-3{flex:0 0 25%;max-width:25%}.v-col-xl-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-xl-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-xl-6{flex:0 0 50%;max-width:50%}.v-col-xl-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-xl-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-xl-9{flex:0 0 75%;max-width:75%}.v-col-xl-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-xl-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-xl-12{flex:0 0 100%;max-width:100%}.offset-xl-0.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-0{margin-left:0}.offset-xl-0.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-0{margin-right:0}.offset-xl-1.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-1{margin-left:8.3333333333%}.offset-xl-1.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-1{margin-right:8.3333333333%}.offset-xl-2.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-2{margin-left:16.6666666667%}.offset-xl-2.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-2{margin-right:16.6666666667%}.offset-xl-3.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-3{margin-left:25%}.offset-xl-3.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-3{margin-right:25%}.offset-xl-4.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-4{margin-left:33.3333333333%}.offset-xl-4.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-4{margin-right:33.3333333333%}.offset-xl-5.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-5{margin-left:41.6666666667%}.offset-xl-5.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-5{margin-right:41.6666666667%}.offset-xl-6.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-6{margin-left:50%}.offset-xl-6.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-6{margin-right:50%}.offset-xl-7.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-7{margin-left:58.3333333333%}.offset-xl-7.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-7{margin-right:58.3333333333%}.offset-xl-8.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-8{margin-left:66.6666666667%}.offset-xl-8.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-8{margin-right:66.6666666667%}.offset-xl-9.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-9{margin-left:75%}.offset-xl-9.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-9{margin-right:75%}.offset-xl-10.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-10{margin-left:83.3333333333%}.offset-xl-10.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-10{margin-right:83.3333333333%}.offset-xl-11.v-locale--is-ltr,.v-locale--is-ltr .offset-xl-11{margin-left:91.6666666667%}.offset-xl-11.v-locale--is-rtl,.v-locale--is-rtl .offset-xl-11{margin-right:91.6666666667%}}@media (min-width: 2560px){.v-col-xxl{flex-basis:0;flex-grow:1;max-width:100%}.v-col-xxl-auto{flex:0 0 auto;width:auto;max-width:100%}.v-col-xxl-1{flex:0 0 8.3333333333%;max-width:8.3333333333%}.v-col-xxl-2{flex:0 0 16.6666666667%;max-width:16.6666666667%}.v-col-xxl-3{flex:0 0 25%;max-width:25%}.v-col-xxl-4{flex:0 0 33.3333333333%;max-width:33.3333333333%}.v-col-xxl-5{flex:0 0 41.6666666667%;max-width:41.6666666667%}.v-col-xxl-6{flex:0 0 50%;max-width:50%}.v-col-xxl-7{flex:0 0 58.3333333333%;max-width:58.3333333333%}.v-col-xxl-8{flex:0 0 66.6666666667%;max-width:66.6666666667%}.v-col-xxl-9{flex:0 0 75%;max-width:75%}.v-col-xxl-10{flex:0 0 83.3333333333%;max-width:83.3333333333%}.v-col-xxl-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}.v-col-xxl-12{flex:0 0 100%;max-width:100%}.offset-xxl-0.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-0{margin-left:0}.offset-xxl-0.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-0{margin-right:0}.offset-xxl-1.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-1{margin-left:8.3333333333%}.offset-xxl-1.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-1{margin-right:8.3333333333%}.offset-xxl-2.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-2{margin-left:16.6666666667%}.offset-xxl-2.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-2{margin-right:16.6666666667%}.offset-xxl-3.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-3{margin-left:25%}.offset-xxl-3.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-3{margin-right:25%}.offset-xxl-4.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-4{margin-left:33.3333333333%}.offset-xxl-4.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-4{margin-right:33.3333333333%}.offset-xxl-5.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-5{margin-left:41.6666666667%}.offset-xxl-5.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-5{margin-right:41.6666666667%}.offset-xxl-6.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-6{margin-left:50%}.offset-xxl-6.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-6{margin-right:50%}.offset-xxl-7.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-7{margin-left:58.3333333333%}.offset-xxl-7.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-7{margin-right:58.3333333333%}.offset-xxl-8.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-8{margin-left:66.6666666667%}.offset-xxl-8.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-8{margin-right:66.6666666667%}.offset-xxl-9.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-9{margin-left:75%}.offset-xxl-9.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-9{margin-right:75%}.offset-xxl-10.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-10{margin-left:83.3333333333%}.offset-xxl-10.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-10{margin-right:83.3333333333%}.offset-xxl-11.v-locale--is-ltr,.v-locale--is-ltr .offset-xxl-11{margin-left:91.6666666667%}.offset-xxl-11.v-locale--is-rtl,.v-locale--is-rtl .offset-xxl-11{margin-right:91.6666666667%}}.v-text-field input{color:inherit;opacity:0;flex:1;transition:.15s opacity cubic-bezier(.4,0,.2,1);min-width:0}.v-text-field input:focus,.v-text-field input:active{outline:none}.v-text-field input:invalid{box-shadow:none}.v-text-field .v-field{cursor:text}.v-text-field--prefixed.v-text-field .v-field__input{--v-field-padding-start: 6px}.v-text-field--suffixed.v-text-field .v-field__input{--v-field-padding-end: 0}.v-text-field .v-input__details{padding-inline-start:16px;padding-inline-end:16px}.v-text-field .v-field--no-label input,.v-text-field .v-field--active input{opacity:1}.v-text-field .v-field--single-line input{transition:none}.v-text-field__prefix,.v-text-field__suffix{align-items:center;color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));cursor:default;display:flex;opacity:0;transition:inherit;white-space:nowrap;padding-top:calc(var(--v-field-padding-top, 4px) + var(--v-input-padding-top, 0));padding-bottom:var(--v-field-padding-bottom, 6px)}.v-field--active .v-text-field__prefix,.v-field--active .v-text-field__suffix{opacity:1}.v-field--disabled .v-text-field__prefix,.v-field--disabled .v-text-field__suffix{color:rgba(var(--v-theme-on-surface),var(--v-disabled-opacity))}.v-text-field__prefix{padding-inline-start:var(--v-field-padding-start)}.v-text-field__suffix{padding-inline-end:var(--v-field-padding-end)}.v-text-field--flush-details .v-input__details{padding:0}.v-field{display:grid;grid-template-areas:"prepend-inner field clear append-inner";grid-template-columns:min-content minmax(0,1fr) min-content min-content;font-size:16px;letter-spacing:.009375em;max-width:100%;border-radius:4px;contain:layout;flex:1 0;grid-area:control;position:relative;--v-field-padding-start: 16px;--v-field-padding-end: 16px;--v-field-padding-top: 10px;--v-field-padding-bottom: 6px}.v-field--disabled{opacity:var(--v-disabled-opacity);pointer-events:none}.v-field--prepended{padding-inline-start:12px}.v-field--appended{padding-inline-end:12px}.v-field--variant-solo{background:rgb(var(--v-theme-surface));border-color:transparent;color:rgba(var(--v-theme-on-surface),var(--v-high-emphasis-opacity));box-shadow:0 3px 1px -2px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 2px 2px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 1px 5px 0 var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-field--variant-filled{border-bottom-left-radius:0;border-bottom-right-radius:0}.v-input--density-default .v-field--variant-solo,.v-input--density-default .v-field--variant-filled{--v-input-control-height: 56px;--v-field-padding-bottom: 6px}.v-input--density-comfortable .v-field--variant-solo,.v-input--density-comfortable .v-field--variant-filled{--v-input-control-height: 48px;--v-field-padding-bottom: 2px}.v-input--density-compact .v-field--variant-solo,.v-input--density-compact .v-field--variant-filled{--v-input-control-height: 40px;--v-field-padding-bottom: -2px}.v-field--variant-outlined,.v-field--single-line,.v-field--no-label{--v-field-padding-top: 0px}.v-input--density-default .v-field--variant-outlined,.v-input--density-default .v-field--single-line,.v-input--density-default .v-field--no-label{--v-field-padding-bottom: 16px}.v-input--density-comfortable .v-field--variant-outlined,.v-input--density-comfortable .v-field--single-line,.v-input--density-comfortable .v-field--no-label{--v-field-padding-bottom: 12px}.v-input--density-compact .v-field--variant-outlined,.v-input--density-compact .v-field--single-line,.v-input--density-compact .v-field--no-label{--v-field-padding-bottom: 8px}.v-field--variant-plain,.v-field--variant-underlined{border-radius:0;padding:0}.v-field--variant-plain.v-field,.v-field--variant-underlined.v-field{--v-field-padding-start: 0px;--v-field-padding-end: 0px;--v-field-padding-top: 6px;--v-field-padding-bottom: 2px}.v-input--density-default .v-field--variant-plain,.v-input--density-default .v-field--variant-underlined{--v-input-control-height: 48px}.v-input--density-comfortable .v-field--variant-plain,.v-input--density-comfortable .v-field--variant-underlined{--v-input-control-height: 40px}.v-input--density-compact .v-field--variant-plain,.v-input--density-compact .v-field--variant-underlined{--v-input-control-height: 32px}.v-field.v-field--prepended{--v-field-padding-start: 6px}.v-field.v-field--appended{--v-field-padding-end: 6px}.v-field__input{color:inherit;display:flex;flex-wrap:wrap;letter-spacing:.009375em;opacity:var(--v-high-emphasis-opacity);min-height:var(--v-input-control-height, 56px);padding-inline-start:var(--v-field-padding-start);padding-inline-end:var(--v-field-padding-end);padding-top:calc(var(--v-field-padding-top, 10px) + var(--v-input-padding-top, 0));padding-bottom:var(--v-field-padding-bottom, 6px);width:100%}.v-field__input input{letter-spacing:inherit}.v-field__input input::placeholder,input.v-field__input::placeholder,textarea.v-field__input::placeholder{color:currentColor;opacity:var(--v-disabled-opacity)}.v-field__input:focus,.v-field__input:active{outline:none}.v-field__input:invalid{box-shadow:none}.v-field__field{flex:1 0;grid-area:field;position:relative;align-items:flex-start;display:flex}.v-field__prepend-inner{grid-area:prepend-inner;padding-inline-end:var(--v-field-padding-after)}.v-field__clearable{grid-area:clear}.v-field__append-inner{grid-area:append-inner;padding-inline-start:var(--v-field-padding-after)}.v-field__prepend-inner,.v-field__append-inner,.v-field__clearable{align-items:flex-start;display:flex;padding-top:var(--v-input-padding-top, 10px)}.v-field--focused .v-field__prepend-inner,.v-field--focused .v-field__append-inner{opacity:1}.v-field__prepend-inner>.v-icon,.v-field__append-inner>.v-icon,.v-field__clearable>.v-icon{opacity:var(--v-medium-emphasis-opacity)}.v-field--disabled .v-field__prepend-inner>.v-icon,.v-field--error .v-field__prepend-inner>.v-icon,.v-field--disabled .v-field__append-inner>.v-icon,.v-field--error .v-field__append-inner>.v-icon,.v-field--disabled .v-field__clearable>.v-icon,.v-field--error .v-field__clearable>.v-icon{opacity:1}.v-field--error:not(.v-field--disabled) .v-field__prepend-inner>.v-icon,.v-field--error:not(.v-field--disabled) .v-field__append-inner>.v-icon,.v-field--error:not(.v-field--disabled) .v-field__clearable>.v-icon{color:rgb(var(--v-theme-error))}.v-field__clearable{cursor:pointer;opacity:0;margin-inline-start:4px;margin-inline-end:4px;transition:.15s cubic-bezier(.4,0,.2,1);transition-property:opacity,transform,width}.v-field--focused .v-field__clearable,.v-field--persistent-clear .v-field__clearable{opacity:1}@media (hover: hover){.v-field:hover .v-field__clearable{opacity:1}}.v-label.v-field-label{contain:layout paint;margin-inline-start:var(--v-field-padding-start);margin-inline-end:var(--v-field-padding-end);max-width:calc(100% - var(--v-field-padding-start) - var(--v-field-padding-end));pointer-events:none;position:absolute;top:var(--v-input-padding-top, 10px);transform-origin:left center;transition:.15s cubic-bezier(.4,0,.2,1);transition-property:opacity,transform}.v-field--active .v-label.v-field-label{visibility:hidden}.v-field--focused .v-label.v-field-label,.v-field--error .v-label.v-field-label{opacity:1}.v-field--error:not(.v-field--disabled) .v-label.v-field-label{color:rgb(var(--v-theme-error))}.v-label.v-field-label--floating{--v-field-label-scale: .75em;font-size:var(--v-field-label-scale);visibility:hidden;max-width:100%}.v-field.v-field--active .v-label.v-field-label--floating{visibility:visible}.v-input--density-default .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-default .v-field--variant-filled .v-label.v-field-label--floating{top:7px}.v-input--density-comfortable .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-comfortable .v-field--variant-filled .v-label.v-field-label--floating{top:5px}.v-input--density-compact .v-field--variant-solo .v-label.v-field-label--floating,.v-input--density-compact .v-field--variant-filled .v-label.v-field-label--floating{top:3px}.v-field--variant-plain .v-label.v-field-label--floating,.v-field--variant-underlined .v-label.v-field-label--floating{transform:translateY(-16px);margin:0}.v-field--variant-outlined .v-label.v-field-label--floating{transform:translateY(-50%);transform-origin:center;position:static;margin:0 4px}.v-field__outline{--v-field-border-width: 1px;--v-field-border-opacity: .38;align-items:stretch;contain:layout;display:flex;height:100%;left:0;pointer-events:none;position:absolute;right:0;width:100%}@media (hover: hover){.v-field:hover .v-field__outline{--v-field-border-opacity: var(--v-high-emphasis-opacity)}}.v-field--error:not(.v-field--disabled) .v-field__outline{color:rgb(var(--v-theme-error))}.v-field.v-field--focused .v-field__outline,.v-input.v-input--error .v-field__outline{--v-field-border-opacity: 1}.v-field--variant-outlined.v-field--focused .v-field__outline{--v-field-border-width: 2px}.v-field--variant-filled .v-field__outline:before,.v-field--variant-underlined .v-field__outline:before{border-style:solid;border-width:0 0 var(--v-field-border-width);opacity:var(--v-field-border-opacity);transition:opacity .25s cubic-bezier(.4,0,.2,1);content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-field--variant-filled .v-field__outline:after,.v-field--variant-underlined .v-field__outline:after{border-color:currentColor;border-style:solid;border-width:0 0 2px;transform:scaleX(0);transition:transform .15s cubic-bezier(.4,0,.2,1);content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-field--focused.v-field--variant-filled .v-field__outline:after,.v-field--focused.v-field--variant-underlined .v-field__outline:after{transform:scaleX(1)}.v-field--variant-outlined .v-field__outline{border-radius:inherit}.v-field--variant-outlined .v-field__outline__start,.v-field--variant-outlined .v-field__outline__notch:before,.v-field--variant-outlined .v-field__outline__notch:after,.v-field--variant-outlined .v-field__outline__end{border:0 solid currentColor;opacity:var(--v-field-border-opacity);transition:opacity .25s cubic-bezier(.4,0,.2,1)}.v-field--variant-outlined .v-field__outline__start{flex:0 0 12px;border-top-width:var(--v-field-border-width);border-bottom-width:var(--v-field-border-width);border-inline-start-width:var(--v-field-border-width)}.v-field--variant-outlined .v-field__outline__start.v-locale--is-ltr,.v-locale--is-ltr .v-field--variant-outlined .v-field__outline__start{border-radius:4px 0 0 4px}.v-field--variant-outlined .v-field__outline__start.v-locale--is-rtl,.v-locale--is-rtl .v-field--variant-outlined .v-field__outline__start{border-radius:0 4px 4px 0}.v-field--variant-outlined .v-field__outline__notch{flex:none;position:relative;border-width:0 0 var(--v-field-border-width)}.v-field--variant-outlined .v-field__outline__notch:before,.v-field--variant-outlined .v-field__outline__notch:after{opacity:var(--v-field-border-opacity);transition:opacity .25s cubic-bezier(.4,0,.2,1);content:"";position:absolute;top:0;left:0;width:100%;height:100%}.v-field--variant-outlined .v-field__outline__notch:before{border-width:var(--v-field-border-width) 0 0}.v-field--variant-outlined .v-field__outline__notch:after{bottom:0;border-width:0 0 var(--v-field-border-width)}.v-field--active.v-field--variant-outlined .v-field__outline__notch:before{opacity:0}.v-field--variant-outlined .v-field__outline__end{flex:1;border-top-width:var(--v-field-border-width);border-bottom-width:var(--v-field-border-width);border-inline-end-width:var(--v-field-border-width)}.v-field--variant-outlined .v-field__outline__end.v-locale--is-ltr,.v-locale--is-ltr .v-field--variant-outlined .v-field__outline__end{border-radius:0 4px 4px 0}.v-field--variant-outlined .v-field__outline__end.v-locale--is-rtl,.v-locale--is-rtl .v-field--variant-outlined .v-field__outline__end{border-radius:4px 0 0 4px}.v-field__loader{bottom:0;left:0;position:absolute;right:0;width:100%}.v-field--variant-filled .v-field__overlay{background-color:currentColor;border-radius:inherit;opacity:.04;pointer-events:none;transition:opacity .25s cubic-bezier(.4,0,.2,1);position:absolute;top:0;left:0;width:100%;height:100%}.v-field--variant-filled.v-field--has-background .v-field__overlay{opacity:0}@media (hover: hover){.v-field--variant-filled:hover .v-field__overlay{opacity:calc((.04 + var(--v-hover-opacity)) * var(--v-theme-overlay-multiplier))}}.v-field--variant-filled.v-field--focused .v-field__overlay{opacity:calc((.04 + var(--v-focus-opacity)) * var(--v-theme-overlay-multiplier))}.v-field--reverse .v-field__input.v-locale--is-ltr,.v-locale--is-ltr .v-field--reverse .v-field__input{text-align:right}.v-field--reverse .v-field__input.v-locale--is-rtl,.v-locale--is-rtl .v-field--reverse .v-field__input{text-align:left}.v-input--disabled .v-field--variant-filled .v-field__outline:before,.v-input--disabled .v-field--variant-underlined .v-field__outline:before{border-image:repeating-linear-gradient(to right,rgba(var(--v-theme-on-surface),var(--v-disabled-opacity)) 0px,rgba(var(--v-theme-on-surface),var(--v-disabled-opacity)) 2px,transparent 2px,transparent 4px) 1 repeat}.v-field--loading .v-field__outline:after,.v-field--loading .v-field__outline:before{opacity:0}.v-counter{color:rgba(var(--v-theme-on-surface),var(--v-medium-emphasis-opacity));flex:0 1 auto;font-size:12px;transition-duration:.15s}.large-font>input[data-v-be9a84d5]{font-size:1.5rem}.centered-input>input[data-v-be9a84d5]{text-align:center;font-weight:700;font-size:1.5rem}.v-tooltip>.v-overlay__content{background:rgba(var(--v-theme-surface-variant),.7);color:rgb(var(--v-theme-on-surface-variant));border-radius:4px;font-size:.875rem;line-height:1.6;display:inline-block;padding:5px 16px;text-transform:initial;width:auto;opacity:1;pointer-events:none;transition-property:opacity,transform}.v-tooltip>.v-overlay__content[class*=enter-active]{transition-timing-function:cubic-bezier(0,0,.2,1);transition-duration:.15s}.v-tooltip>.v-overlay__content[class*=leave-active]{transition-timing-function:cubic-bezier(.4,0,1,1);transition-duration:75ms}.v-overlay-container{contain:layout;left:0;pointer-events:none;position:absolute;top:0;display:contents}.v-overlay-scroll-blocked{padding-inline-end:var(--v-scrollbar-offset);overflow-y:hidden!important}html.v-overlay-scroll-blocked{position:fixed;top:var(--v-body-scroll-y);left:var(--v-body-scroll-x);width:100%;height:100%}.v-overlay{border-radius:inherit;display:flex;left:0;pointer-events:none;position:fixed;top:0;bottom:0;right:0}.v-overlay__content{outline:none;position:absolute;pointer-events:auto;contain:layout}.v-overlay__scrim{pointer-events:auto;background:rgb(var(--v-theme-on-surface));border-radius:inherit;bottom:0;left:0;opacity:.32;position:fixed;right:0;top:0}.v-overlay--absolute,.v-overlay--contained .v-overlay__scrim{position:absolute}.v-overlay--scroll-blocked{padding-inline-end:var(--v-scrollbar-offset)}.v-dialog{align-items:center;justify-content:center;margin:auto}.v-dialog>.v-overlay__content{max-height:calc(100% - 48px);width:calc(100% - 48px);max-width:calc(100% - 48px);margin:24px;display:flex;flex-direction:column}.v-dialog>.v-overlay__content>.v-card,.v-dialog>.v-overlay__content>.v-sheet{--v-scrollbar-offset: 0px;border-radius:4px;overflow-y:auto;box-shadow:0 11px 15px -7px var(--v-shadow-key-umbra-opacity, rgba(0, 0, 0, .2)),0 24px 38px 3px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .14)),0 9px 46px 8px var(--v-shadow-key-penumbra-opacity, rgba(0, 0, 0, .12))}.v-dialog>.v-overlay__content>.v-card{display:flex;flex-direction:column}.v-dialog>.v-overlay__content>.v-card>.v-card-item{padding:14px 24px 0}.v-dialog>.v-overlay__content>.v-card>.v-card-item+.v-card-text{padding-top:10px}.v-dialog>.v-overlay__content>.v-card>.v-card-text{font-size:inherit;letter-spacing:.03125em;line-height:inherit;padding:16px 24px 10px}.v-dialog--fullscreen{--v-scrollbar-offset: 0px}.v-dialog--fullscreen>.v-overlay__content{border-radius:0;margin:0;padding:0;width:100%;height:100%;max-width:100%;max-height:100%;overflow-y:auto;top:0;left:0}.v-dialog--fullscreen>.v-overlay__content>.v-card,.v-dialog--fullscreen>.v-overlay__content>.v-sheet{min-height:100%;min-width:100%;border-radius:0}.v-dialog--scrollable>.v-overlay__content,.v-dialog--scrollable>.v-overlay__content>form{display:flex}.v-dialog--scrollable>.v-overlay__content>.v-card,.v-dialog--scrollable>.v-overlay__content>form>.v-card{display:flex;flex:1 1 100%;flex-direction:column;max-height:100%;max-width:100%}.v-dialog--scrollable>.v-overlay__content>.v-card>.v-card-text,.v-dialog--scrollable>.v-overlay__content>form>.v-card>.v-card-text{backface-visibility:hidden;overflow-y:auto}.v-tabs{display:flex;height:var(--v-tabs-height)}.v-tabs--density-default{--v-tabs-height: 48px}.v-tabs--density-default.v-tabs--stacked{--v-tabs-height: 72px}.v-tabs--density-comfortable{--v-tabs-height: 44px}.v-tabs--density-comfortable.v-tabs--stacked{--v-tabs-height: 68px}.v-tabs--density-compact{--v-tabs-height: 36px}.v-tabs--density-compact.v-tabs--stacked{--v-tabs-height: 60px}.v-tabs.v-slide-group--vertical{height:auto;--v-tabs-height: 48px}.v-tabs--align-tabs-title:not(.v-slide-group--has-affixes) .v-tab:first-child{margin-inline-start:42px}.v-tabs--fixed-tabs .v-slide-group__content>*:last-child,.v-tabs--align-tabs-center .v-slide-group__content>*:last-child{margin-inline-end:auto}.v-tabs--fixed-tabs .v-slide-group__content>*:first-child,.v-tabs--align-tabs-center .v-slide-group__content>*:first-child{margin-inline-start:auto}.v-tabs--grow{flex-grow:1}.v-tabs--grow .v-tab{flex:1 0 auto;max-width:none}.v-tabs--align-tabs-end .v-tab:first-child{margin-inline-start:auto}.v-tabs--align-tabs-end .v-tab:last-child{margin-inline-end:0}@media (max-width: 1279.98px){.v-tabs.v-slide-group--is-overflowing.v-slide-group--horizontal:not(.v-slide-group--has-affixes) .v-tab:first-child{margin-inline-start:52px}.v-tabs.v-slide-group--is-overflowing.v-slide-group--horizontal:not(.v-slide-group--has-affixes) .v-tab:last-child{margin-inline-end:52px}}.v-slide-group{display:flex;overflow:hidden}.v-slide-group__next,.v-slide-group__prev{align-items:center;display:flex;flex:0 1 52px;justify-content:center;min-width:52px;cursor:pointer}.v-slide-group__next--disabled,.v-slide-group__prev--disabled{pointer-events:none;opacity:var(--v-disabled-opacity)}.v-slide-group__content{display:flex;flex:1 0 auto;position:relative;transition:.2s all cubic-bezier(.4,0,.2,1);white-space:nowrap}.v-slide-group__content>*{white-space:initial}.v-slide-group__container{contain:content;display:flex;flex:1 1 auto;overflow:hidden}.v-slide-group--vertical,.v-slide-group--vertical .v-slide-group__container,.v-slide-group--vertical .v-slide-group__content{flex-direction:column}.v-tab.v-tab{--v-btn-height: var(--v-tabs-height);min-width:90px}.v-slide-group--horizontal .v-tab{max-width:360px}.v-slide-group--vertical .v-tab{justify-content:start}.v-tab__slider{position:absolute;bottom:0;left:0;height:2px;width:100%;background:currentColor;pointer-events:none;opacity:0}.v-tab--selected .v-tab__slider{opacity:1}.v-slide-group--vertical .v-tab__slider{top:0;height:100%;width:2px}.v-window{overflow:hidden}.v-window__container{display:flex;flex-direction:column;height:inherit;position:relative;transition:.3s cubic-bezier(.25,.8,.5,1)}.v-window__controls{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:space-between;padding:0 16px;pointer-events:none}.v-window__controls *{pointer-events:auto}.v-window--show-arrows-on-hover{overflow:hidden}.v-window--show-arrows-on-hover .v-window__left{transform:translate(-200%)}.v-window--show-arrows-on-hover .v-window__right{transform:translate(200%)}.v-window--show-arrows-on-hover:hover .v-window__left,.v-window--show-arrows-on-hover:hover .v-window__right{transform:translate(0)}.v-window-x-transition-enter-active,.v-window-x-transition-leave-active,.v-window-x-reverse-transition-enter-active,.v-window-x-reverse-transition-leave-active,.v-window-y-transition-enter-active,.v-window-y-transition-leave-active,.v-window-y-reverse-transition-enter-active,.v-window-y-reverse-transition-leave-active{transition:.3s cubic-bezier(.25,.8,.5,1)}.v-window-x-transition-leave-from,.v-window-x-transition-leave-to,.v-window-x-reverse-transition-leave-from,.v-window-x-reverse-transition-leave-to,.v-window-y-transition-leave-from,.v-window-y-transition-leave-to,.v-window-y-reverse-transition-leave-from,.v-window-y-reverse-transition-leave-to{position:absolute!important;top:0;width:100%}.v-window-x-transition-enter-from{transform:translate(100%)}.v-window-x-transition-leave-to,.v-window-x-reverse-transition-enter-from{transform:translate(-100%)}.v-window-x-reverse-transition-leave-to{transform:translate(100%)}.v-window-y-transition-enter-from{transform:translateY(100%)}.v-window-y-transition-leave-to,.v-window-y-reverse-transition-enter-from{transform:translateY(-100%)}.v-window-y-reverse-transition-leave-to{transform:translateY(100%)}')),document.head.appendChild(e)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
function Qf(e, t) {
  const n = /* @__PURE__ */ Object.create(null), r = e.split(",");
  for (let i = 0; i < r.length; i++)
    n[r[i]] = !0;
  return t ? (i) => !!n[i.toLowerCase()] : (i) => !!n[i];
}
function go(e) {
  if (ne(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const r = e[n], i = Se(r) ? nh(r) : go(r);
      if (i)
        for (const s in i)
          t[s] = i[s];
    }
    return t;
  } else {
    if (Se(e))
      return e;
    if (fe(e))
      return e;
  }
}
const Zf = /;(?![^(]*\))/g, eh = /:([^]+)/, th = /\/\*.*?\*\//gs;
function nh(e) {
  const t = {};
  return e.replace(th, "").split(Zf).forEach((n) => {
    if (n) {
      const r = n.split(eh);
      r.length > 1 && (t[r[0].trim()] = r[1].trim());
    }
  }), t;
}
function po(e) {
  let t = "";
  if (Se(e))
    t = e;
  else if (ne(e))
    for (let n = 0; n < e.length; n++) {
      const r = po(e[n]);
      r && (t += r + " ");
    }
  else if (fe(e))
    for (const n in e)
      e[n] && (t += n + " ");
  return t.trim();
}
const it = (e) => Se(e) ? e : e == null ? "" : ne(e) || fe(e) && (e.toString === hc || !ue(e.toString)) ? JSON.stringify(e, dc, 2) : String(e), dc = (e, t) => t && t.__v_isRef ? dc(e, t.value) : un(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce((n, [r, i]) => (n[`${r} =>`] = i, n), {})
} : fc(t) ? {
  [`Set(${t.size})`]: [...t.values()]
} : fe(t) && !ne(t) && !mc(t) ? String(t) : t, tt = {}.NODE_ENV !== "production" ? Object.freeze({}) : {}, rh = {}.NODE_ENV !== "production" ? Object.freeze([]) : [], yo = () => {
}, ih = /^on[^a-z]/, sh = (e) => ih.test(e), Re = Object.assign, oh = (e, t) => {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}, ah = Object.prototype.hasOwnProperty, de = (e, t) => ah.call(e, t), ne = Array.isArray, un = (e) => Gi(e) === "[object Map]", fc = (e) => Gi(e) === "[object Set]", ue = (e) => typeof e == "function", Se = (e) => typeof e == "string", _o = (e) => typeof e == "symbol", fe = (e) => e !== null && typeof e == "object", lh = (e) => fe(e) && ue(e.then) && ue(e.catch), hc = Object.prototype.toString, Gi = (e) => hc.call(e), vc = (e) => Gi(e).slice(8, -1), mc = (e) => Gi(e) === "[object Object]", bo = (e) => Se(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, wo = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, ch = /-(\w)/g, Hn = wo((e) => e.replace(ch, (t, n) => n ? n.toUpperCase() : "")), ht = wo((e) => e.charAt(0).toUpperCase() + e.slice(1)), gc = wo((e) => e ? `on${ht(e)}` : ""), yr = (e, t) => !Object.is(e, t), uh = (e, t, n) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    value: n
  });
}, dh = (e) => {
  const t = Se(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t;
};
let Ta;
const fh = () => Ta || (Ta = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Si(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t);
}
let Le;
class hh {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Le, !t && Le && (this.index = (Le.scopes || (Le.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(t) {
    if (this._active) {
      const n = Le;
      try {
        return Le = this, t();
      } finally {
        Le = n;
      }
    } else
      ({}).NODE_ENV !== "production" && Si("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    Le = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    Le = this.parent;
  }
  stop(t) {
    if (this._active) {
      let n, r;
      for (n = 0, r = this.effects.length; n < r; n++)
        this.effects[n].stop();
      for (n = 0, r = this.cleanups.length; n < r; n++)
        this.cleanups[n]();
      if (this.scopes)
        for (n = 0, r = this.scopes.length; n < r; n++)
          this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !t) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function Lr(e) {
  return new hh(e);
}
function vh(e, t = Le) {
  t && t.active && t.effects.push(e);
}
function pc() {
  return Le;
}
function xe(e) {
  Le ? Le.cleanups.push(e) : {}.NODE_ENV !== "production" && Si("onScopeDispose() is called when there is no active effect scope to be associated with.");
}
const _r = (e) => {
  const t = new Set(e);
  return t.w = 0, t.n = 0, t;
}, yc = (e) => (e.w & jt) > 0, _c = (e) => (e.n & jt) > 0, mh = ({ deps: e }) => {
  if (e.length)
    for (let t = 0; t < e.length; t++)
      e[t].w |= jt;
}, gh = (e) => {
  const { deps: t } = e;
  if (t.length) {
    let n = 0;
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      yc(i) && !_c(i) ? i.delete(e) : t[n++] = i, i.w &= ~jt, i.n &= ~jt;
    }
    t.length = n;
  }
}, Ei = /* @__PURE__ */ new WeakMap();
let ir = 0, jt = 1;
const Ls = 30;
let ke;
const dn = Symbol({}.NODE_ENV !== "production" ? "iterate" : ""), $s = Symbol({}.NODE_ENV !== "production" ? "Map key iterate" : "");
class bc {
  constructor(t, n = null, r) {
    this.fn = t, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, vh(this, r);
  }
  run() {
    if (!this.active)
      return this.fn();
    let t = ke, n = $t;
    for (; t; ) {
      if (t === this)
        return;
      t = t.parent;
    }
    try {
      return this.parent = ke, ke = this, $t = !0, jt = 1 << ++ir, ir <= Ls ? mh(this) : Oa(this), this.fn();
    } finally {
      ir <= Ls && gh(this), jt = 1 << --ir, ke = this.parent, $t = n, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    ke === this ? this.deferStop = !0 : this.active && (Oa(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function Oa(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let n = 0; n < t.length; n++)
      t[n].delete(e);
    t.length = 0;
  }
}
let $t = !0;
const wc = [];
function So() {
  wc.push($t), $t = !1;
}
function Eo() {
  const e = wc.pop();
  $t = e === void 0 ? !0 : e;
}
function Be(e, t, n) {
  if ($t && ke) {
    let r = Ei.get(e);
    r || Ei.set(e, r = /* @__PURE__ */ new Map());
    let i = r.get(n);
    i || r.set(n, i = _r());
    const s = {}.NODE_ENV !== "production" ? { effect: ke, target: e, type: t, key: n } : void 0;
    Ms(i, s);
  }
}
function Ms(e, t) {
  let n = !1;
  ir <= Ls ? _c(e) || (e.n |= jt, n = !yc(e)) : n = !e.has(ke), n && (e.add(ke), ke.deps.push(e), {}.NODE_ENV !== "production" && ke.onTrack && ke.onTrack(Object.assign({ effect: ke }, t)));
}
function Wt(e, t, n, r, i, s) {
  const o = Ei.get(e);
  if (!o)
    return;
  let a = [];
  if (t === "clear")
    a = [...o.values()];
  else if (n === "length" && ne(e)) {
    const c = Number(r);
    o.forEach((d, u) => {
      (u === "length" || u >= c) && a.push(d);
    });
  } else
    switch (n !== void 0 && a.push(o.get(n)), t) {
      case "add":
        ne(e) ? bo(n) && a.push(o.get("length")) : (a.push(o.get(dn)), un(e) && a.push(o.get($s)));
        break;
      case "delete":
        ne(e) || (a.push(o.get(dn)), un(e) && a.push(o.get($s)));
        break;
      case "set":
        un(e) && a.push(o.get(dn));
        break;
    }
  const l = {}.NODE_ENV !== "production" ? { target: e, type: t, key: n, newValue: r, oldValue: i, oldTarget: s } : void 0;
  if (a.length === 1)
    a[0] && ({}.NODE_ENV !== "production" ? Dn(a[0], l) : Dn(a[0]));
  else {
    const c = [];
    for (const d of a)
      d && c.push(...d);
    ({}).NODE_ENV !== "production" ? Dn(_r(c), l) : Dn(_r(c));
  }
}
function Dn(e, t) {
  const n = ne(e) ? e : [...e];
  for (const r of n)
    r.computed && Aa(r, t);
  for (const r of n)
    r.computed || Aa(r, t);
}
function Aa(e, t) {
  (e !== ke || e.allowRecurse) && ({}.NODE_ENV !== "production" && e.onTrigger && e.onTrigger(Re({ effect: e }, t)), e.scheduler ? e.scheduler() : e.run());
}
function ph(e, t) {
  var n;
  return (n = Ei.get(e)) === null || n === void 0 ? void 0 : n.get(t);
}
const yh = /* @__PURE__ */ Qf("__proto__,__v_isRef,__isVue"), Sc = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(_o)
), _h = /* @__PURE__ */ Io(), bh = /* @__PURE__ */ Io(!0), wh = /* @__PURE__ */ Io(!0, !0), Na = /* @__PURE__ */ Sh();
function Sh() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
    e[t] = function(...n) {
      const r = B(this);
      for (let s = 0, o = this.length; s < o; s++)
        Be(r, "get", s + "");
      const i = r[t](...n);
      return i === -1 || i === !1 ? r[t](...n.map(B)) : i;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
    e[t] = function(...n) {
      So();
      const r = B(this)[t].apply(this, n);
      return Eo(), r;
    };
  }), e;
}
function Eh(e) {
  const t = B(this);
  return Be(t, "has", e), t.hasOwnProperty(e);
}
function Io(e = !1, t = !1) {
  return function(r, i, s) {
    if (i === "__v_isReactive")
      return !e;
    if (i === "__v_isReadonly")
      return e;
    if (i === "__v_isShallow")
      return t;
    if (i === "__v_raw" && s === (e ? t ? Tc : kc : t ? Bh : Cc).get(r))
      return r;
    const o = ne(r);
    if (!e) {
      if (o && de(Na, i))
        return Reflect.get(Na, i, s);
      if (i === "hasOwnProperty")
        return Eh;
    }
    const a = Reflect.get(r, i, s);
    return (_o(i) ? Sc.has(i) : yh(i)) || (e || Be(r, "get", i), t) ? a : K(a) ? o && bo(i) ? a : a.value : fe(a) ? e ? $r(a) : In(a) : a;
  };
}
const Ih = /* @__PURE__ */ Ch();
function Ch(e = !1) {
  return function(n, r, i, s) {
    let o = n[r];
    if (zt(o) && K(o) && !K(i))
      return !1;
    if (!e && (!Ii(i) && !zt(i) && (o = B(o), i = B(i)), !ne(n) && K(o) && !K(i)))
      return o.value = i, !0;
    const a = ne(n) && bo(r) ? Number(r) < n.length : de(n, r), l = Reflect.set(n, r, i, s);
    return n === B(s) && (a ? yr(i, o) && Wt(n, "set", r, i, o) : Wt(n, "add", r, i)), l;
  };
}
function kh(e, t) {
  const n = de(e, t), r = e[t], i = Reflect.deleteProperty(e, t);
  return i && n && Wt(e, "delete", t, void 0, r), i;
}
function Th(e, t) {
  const n = Reflect.has(e, t);
  return (!_o(t) || !Sc.has(t)) && Be(e, "has", t), n;
}
function Oh(e) {
  return Be(e, "iterate", ne(e) ? "length" : dn), Reflect.ownKeys(e);
}
const Ah = {
  get: _h,
  set: Ih,
  deleteProperty: kh,
  has: Th,
  ownKeys: Oh
}, Ec = {
  get: bh,
  set(e, t) {
    return {}.NODE_ENV !== "production" && Si(`Set operation on key "${String(t)}" failed: target is readonly.`, e), !0;
  },
  deleteProperty(e, t) {
    return {}.NODE_ENV !== "production" && Si(`Delete operation on key "${String(t)}" failed: target is readonly.`, e), !0;
  }
}, Nh = /* @__PURE__ */ Re({}, Ec, {
  get: wh
}), Co = (e) => e, qi = (e) => Reflect.getPrototypeOf(e);
function Xr(e, t, n = !1, r = !1) {
  e = e.__v_raw;
  const i = B(e), s = B(t);
  n || (t !== s && Be(i, "get", t), Be(i, "get", s));
  const { has: o } = qi(i), a = r ? Co : n ? Oo : br;
  if (o.call(i, t))
    return a(e.get(t));
  if (o.call(i, s))
    return a(e.get(s));
  e !== i && e.get(t);
}
function Qr(e, t = !1) {
  const n = this.__v_raw, r = B(n), i = B(e);
  return t || (e !== i && Be(r, "has", e), Be(r, "has", i)), e === i ? n.has(e) : n.has(e) || n.has(i);
}
function Zr(e, t = !1) {
  return e = e.__v_raw, !t && Be(B(e), "iterate", dn), Reflect.get(e, "size", e);
}
function Pa(e) {
  e = B(e);
  const t = B(this);
  return qi(t).has.call(t, e) || (t.add(e), Wt(t, "add", e, e)), this;
}
function Ra(e, t) {
  t = B(t);
  const n = B(this), { has: r, get: i } = qi(n);
  let s = r.call(n, e);
  s ? {}.NODE_ENV !== "production" && Ic(n, r, e) : (e = B(e), s = r.call(n, e));
  const o = i.call(n, e);
  return n.set(e, t), s ? yr(t, o) && Wt(n, "set", e, t, o) : Wt(n, "add", e, t), this;
}
function xa(e) {
  const t = B(this), { has: n, get: r } = qi(t);
  let i = n.call(t, e);
  i ? {}.NODE_ENV !== "production" && Ic(t, n, e) : (e = B(e), i = n.call(t, e));
  const s = r ? r.call(t, e) : void 0, o = t.delete(e);
  return i && Wt(t, "delete", e, void 0, s), o;
}
function Va() {
  const e = B(this), t = e.size !== 0, n = {}.NODE_ENV !== "production" ? un(e) ? new Map(e) : new Set(e) : void 0, r = e.clear();
  return t && Wt(e, "clear", void 0, void 0, n), r;
}
function ei(e, t) {
  return function(r, i) {
    const s = this, o = s.__v_raw, a = B(o), l = t ? Co : e ? Oo : br;
    return !e && Be(a, "iterate", dn), o.forEach((c, d) => r.call(i, l(c), l(d), s));
  };
}
function ti(e, t, n) {
  return function(...r) {
    const i = this.__v_raw, s = B(i), o = un(s), a = e === "entries" || e === Symbol.iterator && o, l = e === "keys" && o, c = i[e](...r), d = n ? Co : t ? Oo : br;
    return !t && Be(s, "iterate", l ? $s : dn), {
      // iterator protocol
      next() {
        const { value: u, done: f } = c.next();
        return f ? { value: u, done: f } : {
          value: a ? [d(u[0]), d(u[1])] : d(u),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function At(e) {
  return function(...t) {
    if ({}.NODE_ENV !== "production") {
      const n = t[0] ? `on key "${t[0]}" ` : "";
      console.warn(`${ht(e)} operation ${n}failed: target is readonly.`, B(this));
    }
    return e === "delete" ? !1 : this;
  };
}
function Ph() {
  const e = {
    get(s) {
      return Xr(this, s);
    },
    get size() {
      return Zr(this);
    },
    has: Qr,
    add: Pa,
    set: Ra,
    delete: xa,
    clear: Va,
    forEach: ei(!1, !1)
  }, t = {
    get(s) {
      return Xr(this, s, !1, !0);
    },
    get size() {
      return Zr(this);
    },
    has: Qr,
    add: Pa,
    set: Ra,
    delete: xa,
    clear: Va,
    forEach: ei(!1, !0)
  }, n = {
    get(s) {
      return Xr(this, s, !0);
    },
    get size() {
      return Zr(this, !0);
    },
    has(s) {
      return Qr.call(this, s, !0);
    },
    add: At(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: At(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: At(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: At(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: ei(!0, !1)
  }, r = {
    get(s) {
      return Xr(this, s, !0, !0);
    },
    get size() {
      return Zr(this, !0);
    },
    has(s) {
      return Qr.call(this, s, !0);
    },
    add: At(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: At(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: At(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: At(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: ei(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
    e[s] = ti(s, !1, !1), n[s] = ti(s, !0, !1), t[s] = ti(s, !1, !0), r[s] = ti(s, !0, !0);
  }), [
    e,
    n,
    t,
    r
  ];
}
const [Rh, xh, Vh, Dh] = /* @__PURE__ */ Ph();
function ko(e, t) {
  const n = t ? e ? Dh : Vh : e ? xh : Rh;
  return (r, i, s) => i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? r : Reflect.get(de(n, i) && i in r ? n : r, i, s);
}
const Lh = {
  get: /* @__PURE__ */ ko(!1, !1)
}, $h = {
  get: /* @__PURE__ */ ko(!0, !1)
}, Mh = {
  get: /* @__PURE__ */ ko(!0, !0)
};
function Ic(e, t, n) {
  const r = B(n);
  if (r !== n && t.call(e, r)) {
    const i = vc(e);
    console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const Cc = /* @__PURE__ */ new WeakMap(), Bh = /* @__PURE__ */ new WeakMap(), kc = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakMap();
function Fh(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Uh(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Fh(vc(e));
}
function In(e) {
  return zt(e) ? e : To(e, !1, Ah, Lh, Cc);
}
function $r(e) {
  return To(e, !0, Ec, $h, kc);
}
function ni(e) {
  return To(e, !0, Nh, Mh, Tc);
}
function To(e, t, n, r, i) {
  if (!fe(e))
    return {}.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(e)}`), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const s = i.get(e);
  if (s)
    return s;
  const o = Uh(e);
  if (o === 0)
    return e;
  const a = new Proxy(e, o === 2 ? r : n);
  return i.set(e, a), a;
}
function st(e) {
  return zt(e) ? st(e.__v_raw) : !!(e && e.__v_isReactive);
}
function zt(e) {
  return !!(e && e.__v_isReadonly);
}
function Ii(e) {
  return !!(e && e.__v_isShallow);
}
function Ci(e) {
  return st(e) || zt(e);
}
function B(e) {
  const t = e && e.__v_raw;
  return t ? B(t) : e;
}
function dt(e) {
  return uh(e, "__v_skip", !0), e;
}
const br = (e) => fe(e) ? In(e) : e, Oo = (e) => fe(e) ? $r(e) : e;
function Oc(e) {
  $t && ke && (e = B(e), {}.NODE_ENV !== "production" ? Ms(e.dep || (e.dep = _r()), {
    target: e,
    type: "get",
    key: "value"
  }) : Ms(e.dep || (e.dep = _r())));
}
function Ac(e, t) {
  e = B(e);
  const n = e.dep;
  n && ({}.NODE_ENV !== "production" ? Dn(n, {
    target: e,
    type: "set",
    key: "value",
    newValue: t
  }) : Dn(n));
}
function K(e) {
  return !!(e && e.__v_isRef === !0);
}
function D(e) {
  return Nc(e, !1);
}
function Hh(e) {
  return Nc(e, !0);
}
function Nc(e, t) {
  return K(e) ? e : new jh(e, t);
}
class jh {
  constructor(t, n) {
    this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : B(t), this._value = n ? t : br(t);
  }
  get value() {
    return Oc(this), this._value;
  }
  set value(t) {
    const n = this.__v_isShallow || Ii(t) || zt(t);
    t = n ? t : B(t), yr(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : br(t), Ac(this, t));
  }
}
function T(e) {
  return K(e) ? e.value : e;
}
const Wh = {
  get: (e, t, n) => T(Reflect.get(e, t, n)),
  set: (e, t, n, r) => {
    const i = e[t];
    return K(i) && !K(n) ? (i.value = n, !0) : Reflect.set(e, t, n, r);
  }
};
function zh(e) {
  return st(e) ? e : new Proxy(e, Wh);
}
function ki(e) {
  ({}).NODE_ENV !== "production" && !Ci(e) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const t = ne(e) ? new Array(e.length) : {};
  for (const n in e)
    t[n] = U(e, n);
  return t;
}
class Gh {
  constructor(t, n, r) {
    this._object = t, this._key = n, this._defaultValue = r, this.__v_isRef = !0;
  }
  get value() {
    const t = this._object[this._key];
    return t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return ph(B(this._object), this._key);
  }
}
function U(e, t, n) {
  const r = e[t];
  return K(r) ? r : new Gh(e, t, n);
}
var Pc;
class qh {
  constructor(t, n, r, i) {
    this._setter = n, this.dep = void 0, this.__v_isRef = !0, this[Pc] = !1, this._dirty = !0, this.effect = new bc(t, () => {
      this._dirty || (this._dirty = !0, Ac(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = r;
  }
  get value() {
    const t = B(this);
    return Oc(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value;
  }
  set value(t) {
    this._setter(t);
  }
}
Pc = "__v_isReadonly";
function Kh(e, t, n = !1) {
  let r, i;
  const s = ue(e);
  s ? (r = e, i = {}.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : yo) : (r = e.get, i = e.set);
  const o = new qh(r, i, s || !i, n);
  return {}.NODE_ENV !== "production" && t && !n && (o.effect.onTrack = t.onTrack, o.effect.onTrigger = t.onTrigger), o;
}
const fn = [];
function Jh(e) {
  fn.push(e);
}
function Yh() {
  fn.pop();
}
function Q(e, ...t) {
  if ({}.NODE_ENV === "production")
    return;
  So();
  const n = fn.length ? fn[fn.length - 1].component : null, r = n && n.appContext.config.warnHandler, i = Xh();
  if (r)
    hn(r, n, 11, [
      e + t.join(""),
      n && n.proxy,
      i.map(({ vnode: s }) => `at <${ru(n, s.type)}>`).join(`
`),
      i
    ]);
  else {
    const s = [`[Vue warn]: ${e}`, ...t];
    i.length && s.push(`
`, ...Qh(i)), console.warn(...s);
  }
  Eo();
}
function Xh() {
  let e = fn[fn.length - 1];
  if (!e)
    return [];
  const t = [];
  for (; e; ) {
    const n = t[0];
    n && n.vnode === e ? n.recurseCount++ : t.push({
      vnode: e,
      recurseCount: 0
    });
    const r = e.component && e.component.parent;
    e = r && r.vnode;
  }
  return t;
}
function Qh(e) {
  const t = [];
  return e.forEach((n, r) => {
    t.push(...r === 0 ? [] : [`
`], ...Zh(n));
  }), t;
}
function Zh({ vnode: e, recurseCount: t }) {
  const n = t > 0 ? `... (${t} recursive calls)` : "", r = e.component ? e.component.parent == null : !1, i = ` at <${ru(e.component, e.type, r)}`, s = ">" + n;
  return e.props ? [i, ...ev(e.props), s] : [i + s];
}
function ev(e) {
  const t = [], n = Object.keys(e);
  return n.slice(0, 3).forEach((r) => {
    t.push(...Rc(r, e[r]));
  }), n.length > 3 && t.push(" ..."), t;
}
function Rc(e, t, n) {
  return Se(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : K(t) ? (t = Rc(e, B(t.value), !0), n ? t : [`${e}=Ref<`, t, ">"]) : ue(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = B(t), n ? t : [`${e}=`, t]);
}
function tv(e, t) {
  ({}).NODE_ENV !== "production" && e !== void 0 && (typeof e != "number" ? Q(`${t} is not a valid number - got ${JSON.stringify(e)}.`) : isNaN(e) && Q(`${t} is NaN - the duration expression might be incorrect.`));
}
const Ao = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [
    0
    /* ErrorCodes.SETUP_FUNCTION */
  ]: "setup function",
  [
    1
    /* ErrorCodes.RENDER_FUNCTION */
  ]: "render function",
  [
    2
    /* ErrorCodes.WATCH_GETTER */
  ]: "watcher getter",
  [
    3
    /* ErrorCodes.WATCH_CALLBACK */
  ]: "watcher callback",
  [
    4
    /* ErrorCodes.WATCH_CLEANUP */
  ]: "watcher cleanup function",
  [
    5
    /* ErrorCodes.NATIVE_EVENT_HANDLER */
  ]: "native event handler",
  [
    6
    /* ErrorCodes.COMPONENT_EVENT_HANDLER */
  ]: "component event handler",
  [
    7
    /* ErrorCodes.VNODE_HOOK */
  ]: "vnode hook",
  [
    8
    /* ErrorCodes.DIRECTIVE_HOOK */
  ]: "directive hook",
  [
    9
    /* ErrorCodes.TRANSITION_HOOK */
  ]: "transition hook",
  [
    10
    /* ErrorCodes.APP_ERROR_HANDLER */
  ]: "app errorHandler",
  [
    11
    /* ErrorCodes.APP_WARN_HANDLER */
  ]: "app warnHandler",
  [
    12
    /* ErrorCodes.FUNCTION_REF */
  ]: "ref function",
  [
    13
    /* ErrorCodes.ASYNC_COMPONENT_LOADER */
  ]: "async component loader",
  [
    14
    /* ErrorCodes.SCHEDULER */
  ]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function hn(e, t, n, r) {
  let i;
  try {
    i = r ? e(...r) : e();
  } catch (s) {
    xc(s, t, n);
  }
  return i;
}
function wr(e, t, n, r) {
  if (ue(e)) {
    const s = hn(e, t, n, r);
    return s && lh(s) && s.catch((o) => {
      xc(o, t, n);
    }), s;
  }
  const i = [];
  for (let s = 0; s < e.length; s++)
    i.push(wr(e[s], t, n, r));
  return i;
}
function xc(e, t, n, r = !0) {
  const i = t ? t.vnode : null;
  if (t) {
    let s = t.parent;
    const o = t.proxy, a = {}.NODE_ENV !== "production" ? Ao[n] : n;
    for (; s; ) {
      const c = s.ec;
      if (c) {
        for (let d = 0; d < c.length; d++)
          if (c[d](e, o, a) === !1)
            return;
      }
      s = s.parent;
    }
    const l = t.appContext.config.errorHandler;
    if (l) {
      hn(l, null, 10, [e, o, a]);
      return;
    }
  }
  nv(e, n, i, r);
}
function nv(e, t, n, r = !0) {
  if ({}.NODE_ENV !== "production") {
    const i = Ao[t];
    if (n && Jh(n), Q(`Unhandled error${i ? ` during execution of ${i}` : ""}`), n && Yh(), r)
      throw e;
    console.error(e);
  } else
    console.error(e);
}
let Ti = !1, Bs = !1;
const nt = [];
let Vt = 0;
const Mn = [];
let ut = null, xt = 0;
const Vc = /* @__PURE__ */ Promise.resolve();
let No = null;
const rv = 100;
function Oe(e) {
  const t = No || Vc;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function iv(e) {
  let t = Vt + 1, n = nt.length;
  for (; t < n; ) {
    const r = t + n >>> 1;
    Sr(nt[r]) < e ? t = r + 1 : n = r;
  }
  return t;
}
function Po(e) {
  (!nt.length || !nt.includes(e, Ti && e.allowRecurse ? Vt + 1 : Vt)) && (e.id == null ? nt.push(e) : nt.splice(iv(e.id), 0, e), Dc());
}
function Dc() {
  !Ti && !Bs && (Bs = !0, No = Vc.then($c));
}
function Lc(e) {
  ne(e) ? Mn.push(...e) : (!ut || !ut.includes(e, e.allowRecurse ? xt + 1 : xt)) && Mn.push(e), Dc();
}
function sv(e) {
  if (Mn.length) {
    const t = [...new Set(Mn)];
    if (Mn.length = 0, ut) {
      ut.push(...t);
      return;
    }
    for (ut = t, {}.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), ut.sort((n, r) => Sr(n) - Sr(r)), xt = 0; xt < ut.length; xt++)
      ({}).NODE_ENV !== "production" && Mc(e, ut[xt]) || ut[xt]();
    ut = null, xt = 0;
  }
}
const Sr = (e) => e.id == null ? 1 / 0 : e.id, ov = (e, t) => {
  const n = Sr(e) - Sr(t);
  if (n === 0) {
    if (e.pre && !t.pre)
      return -1;
    if (t.pre && !e.pre)
      return 1;
  }
  return n;
};
function $c(e) {
  Bs = !1, Ti = !0, {}.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), nt.sort(ov);
  const t = {}.NODE_ENV !== "production" ? (n) => Mc(e, n) : yo;
  try {
    for (Vt = 0; Vt < nt.length; Vt++) {
      const n = nt[Vt];
      if (n && n.active !== !1) {
        if ({}.NODE_ENV !== "production" && t(n))
          continue;
        hn(
          n,
          null,
          14
          /* ErrorCodes.SCHEDULER */
        );
      }
    }
  } finally {
    Vt = 0, nt.length = 0, sv(e), Ti = !1, No = null, (nt.length || Mn.length) && $c(e);
  }
}
function Mc(e, t) {
  if (!e.has(t))
    e.set(t, 1);
  else {
    const n = e.get(t);
    if (n > rv) {
      const r = t.ownerInstance, i = r && Lo(r.type);
      return Q(`Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0;
    } else
      e.set(t, n + 1);
  }
}
let Fs = !1;
const Vn = /* @__PURE__ */ new Set();
({}).NODE_ENV !== "production" && (fh().__VUE_HMR_RUNTIME__ = {
  createRecord: fs(av),
  rerender: fs(lv),
  reload: fs(cv)
});
const Oi = /* @__PURE__ */ new Map();
function av(e, t) {
  return Oi.has(e) ? !1 : (Oi.set(e, {
    initialDef: ur(t),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function ur(e) {
  return iu(e) ? e.__vccOpts : e;
}
function lv(e, t) {
  const n = Oi.get(e);
  n && (n.initialDef.render = t, [...n.instances].forEach((r) => {
    t && (r.render = t, ur(r.type).render = t), r.renderCache = [], Fs = !0, r.update(), Fs = !1;
  }));
}
function cv(e, t) {
  const n = Oi.get(e);
  if (!n)
    return;
  t = ur(t), Da(n.initialDef, t);
  const r = [...n.instances];
  for (const i of r) {
    const s = ur(i.type);
    Vn.has(s) || (s !== n.initialDef && Da(s, t), Vn.add(s)), i.appContext.optionsCache.delete(i.type), i.ceReload ? (Vn.add(s), i.ceReload(t.styles), Vn.delete(s)) : i.parent ? Po(i.parent.update) : i.appContext.reload ? i.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
  }
  Lc(() => {
    for (const i of r)
      Vn.delete(ur(i.type));
  });
}
function Da(e, t) {
  Re(e, t);
  for (const n in e)
    n !== "__file" && !(n in t) && delete e[n];
}
function fs(e) {
  return (t, n) => {
    try {
      return e(t, n);
    } catch (r) {
      console.error(r), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
    }
  };
}
function uv(e, ...t) {
}
const dv = /* @__PURE__ */ fv(
  "component:updated"
  /* DevtoolsHooks.COMPONENT_UPDATED */
);
function fv(e) {
  return (t) => {
    uv(e, t.appContext.app, t.uid, t.parent ? t.parent.uid : void 0, t);
  };
}
let Te = null, Ki = null;
function La(e) {
  const t = Te;
  return Te = e, Ki = e && e.type.__scopeId || null, t;
}
function hv(e) {
  Ki = e;
}
function vv() {
  Ki = null;
}
function V(e, t = Te, n) {
  if (!t || e._n)
    return e;
  const r = (...i) => {
    r._d && ja(-1);
    const s = La(t);
    let o;
    try {
      o = e(...i);
    } finally {
      La(s), r._d && ja(1);
    }
    return {}.NODE_ENV !== "production" && dv(t), o;
  };
  return r._n = !0, r._c = !0, r._d = !0, r;
}
const mv = (e) => e.__isSuspense;
function gv(e, t) {
  t && t.pendingBranch ? ne(e) ? t.effects.push(...e) : t.effects.push(e) : Lc(e);
}
function Je(e, t) {
  if (!ve)
    ({}).NODE_ENV !== "production" && Q("provide() can only be used inside setup().");
  else {
    let n = ve.provides;
    const r = ve.parent && ve.parent.provides;
    r === n && (n = ve.provides = Object.create(r)), n[e] = t;
  }
}
function me(e, t, n = !1) {
  const r = ve || Te;
  if (r) {
    const i = r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides;
    if (i && e in i)
      return i[e];
    if (arguments.length > 1)
      return n && ue(t) ? t.call(r.proxy) : t;
    ({}).NODE_ENV !== "production" && Q(`injection "${String(e)}" not found.`);
  } else
    ({}).NODE_ENV !== "production" && Q("inject() can only be used inside setup() or functional components.");
}
function Gn(e, t) {
  return Ro(e, null, t);
}
const ri = {};
function te(e, t, n) {
  return {}.NODE_ENV !== "production" && !ue(t) && Q("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), Ro(e, t, n);
}
function Ro(e, t, { immediate: n, deep: r, flush: i, onTrack: s, onTrigger: o } = tt) {
  ({}).NODE_ENV !== "production" && !t && (n !== void 0 && Q('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), r !== void 0 && Q('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
  const a = (p) => {
    Q("Invalid watch source: ", p, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
  }, l = pc() === (ve == null ? void 0 : ve.scope) ? ve : null;
  let c, d = !1, u = !1;
  if (K(e) ? (c = () => e.value, d = Ii(e)) : st(e) ? (c = () => e, r = !0) : ne(e) ? (u = !0, d = e.some((p) => st(p) || Ii(p)), c = () => e.map((p) => {
    if (K(p))
      return p.value;
    if (st(p))
      return ln(p);
    if (ue(p))
      return hn(
        p,
        l,
        2
        /* ErrorCodes.WATCH_GETTER */
      );
    ({}).NODE_ENV !== "production" && a(p);
  })) : ue(e) ? t ? c = () => hn(
    e,
    l,
    2
    /* ErrorCodes.WATCH_GETTER */
  ) : c = () => {
    if (!(l && l.isUnmounted))
      return f && f(), wr(e, l, 3, [h]);
  } : (c = yo, {}.NODE_ENV !== "production" && a(e)), t && r) {
    const p = c;
    c = () => ln(p());
  }
  let f, h = (p) => {
    f = C.onStop = () => {
      hn(
        p,
        l,
        4
        /* ErrorCodes.WATCH_CLEANUP */
      );
    };
  }, m = u ? new Array(e.length).fill(ri) : ri;
  const g = () => {
    if (C.active)
      if (t) {
        const p = C.run();
        (r || d || (u ? p.some((O, A) => yr(O, m[A])) : yr(p, m))) && (f && f(), wr(t, l, 3, [
          p,
          // pass undefined as the old value when it's changed for the first time
          m === ri ? void 0 : u && m[0] === ri ? [] : m,
          h
        ]), m = p);
      } else
        C.run();
  };
  g.allowRecurse = !!t;
  let w;
  i === "sync" ? w = g : i === "post" ? w = () => Ua(g, l && l.suspense) : (g.pre = !0, l && (g.id = l.uid), w = () => Po(g));
  const C = new bc(c, w);
  return {}.NODE_ENV !== "production" && (C.onTrack = s, C.onTrigger = o), t ? n ? g() : m = C.run() : i === "post" ? Ua(C.run.bind(C), l && l.suspense) : C.run(), () => {
    C.stop(), l && l.scope && oh(l.scope.effects, C);
  };
}
function pv(e, t, n) {
  const r = this.proxy, i = Se(e) ? e.includes(".") ? yv(r, e) : () => r[e] : e.bind(r, r);
  let s;
  ue(t) ? s = t : (s = t.handler, n = t);
  const o = ve;
  zs(this);
  const a = Ro(i, s.bind(r), n);
  return o ? zs(o) : tu(), a;
}
function yv(e, t) {
  const n = t.split(".");
  return () => {
    let r = e;
    for (let i = 0; i < n.length && r; i++)
      r = r[n[i]];
    return r;
  };
}
function ln(e, t) {
  if (!fe(e) || e.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(e)))
    return e;
  if (t.add(e), K(e))
    ln(e.value, t);
  else if (ne(e))
    for (let n = 0; n < e.length; n++)
      ln(e[n], t);
  else if (fc(e) || un(e))
    e.forEach((n) => {
      ln(n, t);
    });
  else if (mc(e))
    for (const n in e)
      ln(e[n], t);
  return e;
}
function Bc() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return qt(() => {
    e.isMounted = !0;
  }), Kt(() => {
    e.isUnmounting = !0;
  }), e;
}
const We = [Function, Array], _v = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: We,
    onEnter: We,
    onAfterEnter: We,
    onEnterCancelled: We,
    // leave
    onBeforeLeave: We,
    onLeave: We,
    onAfterLeave: We,
    onLeaveCancelled: We,
    // appear
    onBeforeAppear: We,
    onAppear: We,
    onAfterAppear: We,
    onAppearCancelled: We
  },
  setup(e, { slots: t }) {
    const n = Cn(), r = Bc();
    let i;
    return () => {
      const s = t.default && xo(t.default(), !0);
      if (!s || !s.length)
        return;
      let o = s[0];
      if (s.length > 1) {
        let g = !1;
        for (const w of s)
          if (w.type !== Mt) {
            if ({}.NODE_ENV !== "production" && g) {
              Q("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            if (o = w, g = !0, {}.NODE_ENV === "production")
              break;
          }
      }
      const a = B(e), { mode: l } = a;
      if ({}.NODE_ENV !== "production" && l && l !== "in-out" && l !== "out-in" && l !== "default" && Q(`invalid <transition> mode: ${l}`), r.isLeaving)
        return hs(o);
      const c = $a(o);
      if (!c)
        return hs(o);
      const d = Er(c, a, r, n);
      Ir(c, d);
      const u = n.subTree, f = u && $a(u);
      let h = !1;
      const { getTransitionKey: m } = c.type;
      if (m) {
        const g = m();
        i === void 0 ? i = g : g !== i && (i = g, h = !0);
      }
      if (f && f.type !== Mt && (!Yc(c, f) || h)) {
        const g = Er(f, a, r, n);
        if (Ir(f, g), l === "out-in")
          return r.isLeaving = !0, g.afterLeave = () => {
            r.isLeaving = !1, n.update.active !== !1 && n.update();
          }, hs(o);
        l === "in-out" && c.type !== Mt && (g.delayLeave = (w, C, E) => {
          const p = Uc(r, f);
          p[String(f.key)] = f, w._leaveCb = () => {
            C(), w._leaveCb = void 0, delete d.delayedLeave;
          }, d.delayedLeave = E;
        });
      }
      return o;
    };
  }
}, Fc = _v;
function Uc(e, t) {
  const { leavingVNodes: n } = e;
  let r = n.get(t.type);
  return r || (r = /* @__PURE__ */ Object.create(null), n.set(t.type, r)), r;
}
function Er(e, t, n, r) {
  const { appear: i, mode: s, persisted: o = !1, onBeforeEnter: a, onEnter: l, onAfterEnter: c, onEnterCancelled: d, onBeforeLeave: u, onLeave: f, onAfterLeave: h, onLeaveCancelled: m, onBeforeAppear: g, onAppear: w, onAfterAppear: C, onAppearCancelled: E } = t, p = String(e.key), O = Uc(n, e), A = (_, b) => {
    _ && wr(_, r, 9, b);
  }, N = (_, b) => {
    const S = b[1];
    A(_, b), ne(_) ? _.every((P) => P.length <= 1) && S() : _.length <= 1 && S();
  }, I = {
    mode: s,
    persisted: o,
    beforeEnter(_) {
      let b = a;
      if (!n.isMounted)
        if (i)
          b = g || a;
        else
          return;
      _._leaveCb && _._leaveCb(
        !0
        /* cancelled */
      );
      const S = O[p];
      S && Yc(e, S) && S.el._leaveCb && S.el._leaveCb(), A(b, [_]);
    },
    enter(_) {
      let b = l, S = c, P = d;
      if (!n.isMounted)
        if (i)
          b = w || l, S = C || c, P = E || d;
        else
          return;
      let k = !1;
      const R = _._enterCb = (x) => {
        k || (k = !0, x ? A(P, [_]) : A(S, [_]), I.delayedLeave && I.delayedLeave(), _._enterCb = void 0);
      };
      b ? N(b, [_, R]) : R();
    },
    leave(_, b) {
      const S = String(e.key);
      if (_._enterCb && _._enterCb(
        !0
        /* cancelled */
      ), n.isUnmounting)
        return b();
      A(u, [_]);
      let P = !1;
      const k = _._leaveCb = (R) => {
        P || (P = !0, b(), R ? A(m, [_]) : A(h, [_]), _._leaveCb = void 0, O[S] === e && delete O[S]);
      };
      O[S] = e, f ? N(f, [_, k]) : k();
    },
    clone(_) {
      return Er(_, t, n, r);
    }
  };
  return I;
}
function hs(e) {
  if (Hc(e))
    return e = Gt(e), e.children = null, e;
}
function $a(e) {
  return Hc(e) ? e.children ? e.children[0] : void 0 : e;
}
function Ir(e, t) {
  e.shapeFlag & 6 && e.component ? Ir(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function xo(e, t = !1, n) {
  let r = [], i = 0;
  for (let s = 0; s < e.length; s++) {
    let o = e[s];
    const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
    o.type === Pe ? (o.patchFlag & 128 && i++, r = r.concat(xo(o.children, t, a))) : (t || o.type !== Mt) && r.push(a != null ? Gt(o, { key: a }) : o);
  }
  if (i > 1)
    for (let s = 0; s < r.length; s++)
      r[s].patchFlag = -2;
  return r;
}
function bv(e) {
  return ue(e) ? { setup: e, name: e.name } : e;
}
const Hc = (e) => e.type.__isKeepAlive;
function wv(e, t, n = ve, r = !1) {
  if (n) {
    const i = n[e] || (n[e] = []), s = t.__weh || (t.__weh = (...o) => {
      if (n.isUnmounted)
        return;
      So(), zs(n);
      const a = wr(t, n, e, o);
      return tu(), Eo(), a;
    });
    return r ? i.unshift(s) : i.push(s), s;
  } else if ({}.NODE_ENV !== "production") {
    const i = gc(Ao[e].replace(/ hook$/, ""));
    Q(`${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const Mr = (e) => (t, n = ve) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  wv(e, (...r) => t(...r), n)
), jc = Mr(
  "bm"
  /* LifecycleHooks.BEFORE_MOUNT */
), qt = Mr(
  "m"
  /* LifecycleHooks.MOUNTED */
), Sv = Mr(
  "bu"
  /* LifecycleHooks.BEFORE_UPDATE */
), Wc = Mr(
  "u"
  /* LifecycleHooks.UPDATED */
), Kt = Mr(
  "bum"
  /* LifecycleHooks.BEFORE_UNMOUNT */
);
function Ae(e, t) {
  const n = Te;
  if (n === null)
    return {}.NODE_ENV !== "production" && Q("withDirectives can only be used inside render functions."), e;
  const r = nu(n) || n.proxy, i = e.dirs || (e.dirs = []);
  for (let s = 0; s < t.length; s++) {
    let [o, a, l, c = tt] = t[s];
    o && (ue(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && ln(a), i.push({
      dir: o,
      instance: r,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: c
    }));
  }
  return e;
}
const Us = "components", Ev = "directives", zc = Symbol();
function Iv(e) {
  return Se(e) ? Gc(Us, e, !1) || e : e || zc;
}
function Tt(e) {
  return Gc(Ev, e);
}
function Gc(e, t, n = !0, r = !1) {
  const i = Te || ve;
  if (i) {
    const s = i.type;
    if (e === Us) {
      const a = Lo(
        s,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (a && (a === t || a === Hn(t) || a === ht(Hn(t))))
        return s;
    }
    const o = (
      // local registration
      // check instance[type] first which is resolved for options API
      Ma(i[e] || s[e], t) || // global registration
      Ma(i.appContext[e], t)
    );
    if (!o && r)
      return s;
    if ({}.NODE_ENV !== "production" && n && !o) {
      const a = e === Us ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      Q(`Failed to resolve ${e.slice(0, -1)}: ${t}${a}`);
    }
    return o;
  } else
    ({}).NODE_ENV !== "production" && Q(`resolve${ht(e.slice(0, -1))} can only be used in render() or setup().`);
}
function Ma(e, t) {
  return e && (e[t] || e[Hn(t)] || e[ht(Hn(t))]);
}
function Cv(e, t, n, r) {
  let i;
  const s = n && n[r];
  if (ne(e) || Se(e)) {
    i = new Array(e.length);
    for (let o = 0, a = e.length; o < a; o++)
      i[o] = t(e[o], o, void 0, s && s[o]);
  } else if (typeof e == "number") {
    ({}).NODE_ENV !== "production" && !Number.isInteger(e) && Q(`The v-for range expect an integer value but got ${e}.`), i = new Array(e);
    for (let o = 0; o < e; o++)
      i[o] = t(o + 1, o, void 0, s && s[o]);
  } else if (fe(e))
    if (e[Symbol.iterator])
      i = Array.from(e, (o, a) => t(o, a, void 0, s && s[a]));
    else {
      const o = Object.keys(e);
      i = new Array(o.length);
      for (let a = 0, l = o.length; a < l; a++) {
        const c = o[a];
        i[a] = t(e[c], c, a, s && s[a]);
      }
    }
  else
    i = [];
  return n && (n[r] = i), i;
}
function vs(e, t) {
  const n = {};
  if ({}.NODE_ENV !== "production" && !fe(e))
    return Q("v-on with no argument expects an object value."), n;
  for (const r in e)
    n[t && /[A-Z]/.test(r) ? `on:${r}` : gc(r)] = e[r];
  return n;
}
const Hs = (e) => e ? Fv(e) ? nu(e) || e.proxy : Hs(e.parent) : null, dr = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Re(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => ({}).NODE_ENV !== "production" ? ni(e.props) : e.props,
    $attrs: (e) => ({}).NODE_ENV !== "production" ? ni(e.attrs) : e.attrs,
    $slots: (e) => ({}).NODE_ENV !== "production" ? ni(e.slots) : e.slots,
    $refs: (e) => ({}).NODE_ENV !== "production" ? ni(e.refs) : e.refs,
    $parent: (e) => Hs(e.parent),
    $root: (e) => Hs(e.root),
    $emit: (e) => e.emit,
    $options: (e) => Ov(e),
    $forceUpdate: (e) => e.f || (e.f = () => Po(e.update)),
    $nextTick: (e) => e.n || (e.n = Oe.bind(e.proxy)),
    $watch: (e) => pv.bind(e)
  })
), kv = (e) => e === "_" || e === "$", ms = (e, t) => e !== tt && !e.__isScriptSetup && de(e, t), Tv = {
  get({ _: e }, t) {
    const { ctx: n, setupState: r, data: i, props: s, accessCache: o, type: a, appContext: l } = e;
    if ({}.NODE_ENV !== "production" && t === "__isVue")
      return !0;
    let c;
    if (t[0] !== "$") {
      const h = o[t];
      if (h !== void 0)
        switch (h) {
          case 1:
            return r[t];
          case 2:
            return i[t];
          case 4:
            return n[t];
          case 3:
            return s[t];
        }
      else {
        if (ms(r, t))
          return o[t] = 1, r[t];
        if (i !== tt && de(i, t))
          return o[t] = 2, i[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (c = e.propsOptions[0]) && de(c, t)
        )
          return o[t] = 3, s[t];
        if (n !== tt && de(n, t))
          return o[t] = 4, n[t];
        o[t] = 0;
      }
    }
    const d = dr[t];
    let u, f;
    if (d)
      return t === "$attrs" && Be(e, "get", t), d(e);
    if (
      // css module (injected by vue-loader)
      (u = a.__cssModules) && (u = u[t])
    )
      return u;
    if (n !== tt && de(n, t))
      return o[t] = 4, n[t];
    if (
      // global properties
      f = l.config.globalProperties, de(f, t)
    )
      return f[t];
    ({}).NODE_ENV !== "production" && Te && (!Se(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    t.indexOf("__v") !== 0) && (i !== tt && kv(t[0]) && de(i, t) ? Q(`Property ${JSON.stringify(t)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : e === Te && Q(`Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`));
  },
  set({ _: e }, t, n) {
    const { data: r, setupState: i, ctx: s } = e;
    return ms(i, t) ? (i[t] = n, !0) : {}.NODE_ENV !== "production" && i.__isScriptSetup && de(i, t) ? (Q(`Cannot mutate <script setup> binding "${t}" from Options API.`), !1) : r !== tt && de(r, t) ? (r[t] = n, !0) : de(e.props, t) ? ({}.NODE_ENV !== "production" && Q(`Attempting to mutate prop "${t}". Props are readonly.`), !1) : t[0] === "$" && t.slice(1) in e ? ({}.NODE_ENV !== "production" && Q(`Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`), !1) : ({}.NODE_ENV !== "production" && t in e.appContext.config.globalProperties ? Object.defineProperty(s, t, {
      enumerable: !0,
      configurable: !0,
      value: n
    }) : s[t] = n, !0);
  },
  has({ _: { data: e, setupState: t, accessCache: n, ctx: r, appContext: i, propsOptions: s } }, o) {
    let a;
    return !!n[o] || e !== tt && de(e, o) || ms(t, o) || (a = s[0]) && de(a, o) || de(r, o) || de(dr, o) || de(i.config.globalProperties, o);
  },
  defineProperty(e, t, n) {
    return n.get != null ? e._.accessCache[t] = 0 : de(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
  }
};
({}).NODE_ENV !== "production" && (Tv.ownKeys = (e) => (Q("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(e)));
function Ov(e) {
  const t = e.type, { mixins: n, extends: r } = t, { mixins: i, optionsCache: s, config: { optionMergeStrategies: o } } = e.appContext, a = s.get(t);
  let l;
  return a ? l = a : !i.length && !n && !r ? l = t : (l = {}, i.length && i.forEach((c) => Ai(l, c, o, !0)), Ai(l, t, o)), fe(t) && s.set(t, l), l;
}
function Ai(e, t, n, r = !1) {
  const { mixins: i, extends: s } = t;
  s && Ai(e, s, n, !0), i && i.forEach((o) => Ai(e, o, n, !0));
  for (const o in t)
    if (r && o === "expose")
      ({}).NODE_ENV !== "production" && Q('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
    else {
      const a = Av[o] || n && n[o];
      e[o] = a ? a(e[o], t[o]) : t[o];
    }
  return e;
}
const Av = {
  data: Ba,
  props: rn,
  emits: rn,
  // objects
  methods: rn,
  computed: rn,
  // lifecycle
  beforeCreate: Ce,
  created: Ce,
  beforeMount: Ce,
  mounted: Ce,
  beforeUpdate: Ce,
  updated: Ce,
  beforeDestroy: Ce,
  beforeUnmount: Ce,
  destroyed: Ce,
  unmounted: Ce,
  activated: Ce,
  deactivated: Ce,
  errorCaptured: Ce,
  serverPrefetch: Ce,
  // assets
  components: rn,
  directives: rn,
  // watch
  watch: Pv,
  // provide / inject
  provide: Ba,
  inject: Nv
};
function Ba(e, t) {
  return t ? e ? function() {
    return Re(ue(e) ? e.call(this, this) : e, ue(t) ? t.call(this, this) : t);
  } : t : e;
}
function Nv(e, t) {
  return rn(Fa(e), Fa(t));
}
function Fa(e) {
  if (ne(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++)
      t[e[n]] = e[n];
    return t;
  }
  return e;
}
function Ce(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function rn(e, t) {
  return e ? Re(Re(/* @__PURE__ */ Object.create(null), e), t) : t;
}
function Pv(e, t) {
  if (!e)
    return t;
  if (!t)
    return e;
  const n = Re(/* @__PURE__ */ Object.create(null), e);
  for (const r in t)
    n[r] = Ce(e[r], t[r]);
  return n;
}
const Ua = gv;
function qc(e, t, n = !1) {
  const r = e.children, i = t.children;
  if (ne(r) && ne(i))
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      let a = i[s];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = Bv(i[s]), a.el = o.el), n || qc(o, a)), a.type === Vo && (a.el = o.el), {}.NODE_ENV !== "production" && a.type === Mt && !a.el && (a.el = o.el);
    }
}
const Rv = (e) => e.__isTeleport, Bn = (e) => e && (e.disabled || e.disabled === ""), Ha = (e) => typeof SVGElement < "u" && e instanceof SVGElement, js = (e, t) => {
  const n = e && e.to;
  if (Se(n))
    if (t) {
      const r = t(n);
      return r || {}.NODE_ENV !== "production" && Q(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), r;
    } else
      return {}.NODE_ENV !== "production" && Q("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
  else
    return {}.NODE_ENV !== "production" && !n && !Bn(e) && Q(`Invalid Teleport target: ${n}`), n;
}, xv = {
  __isTeleport: !0,
  process(e, t, n, r, i, s, o, a, l, c) {
    const { mc: d, pc: u, pbc: f, o: { insert: h, querySelector: m, createText: g, createComment: w } } = c, C = Bn(t.props);
    let { shapeFlag: E, children: p, dynamicChildren: O } = t;
    if ({}.NODE_ENV !== "production" && Fs && (l = !1, O = null), e == null) {
      const A = t.el = {}.NODE_ENV !== "production" ? w("teleport start") : g(""), N = t.anchor = {}.NODE_ENV !== "production" ? w("teleport end") : g("");
      h(A, n, r), h(N, n, r);
      const I = t.target = js(t.props, m), _ = t.targetAnchor = g("");
      I ? (h(_, I), o = o || Ha(I)) : {}.NODE_ENV !== "production" && !C && Q("Invalid Teleport target on mount:", I, `(${typeof I})`);
      const b = (S, P) => {
        E & 16 && d(p, S, P, i, s, o, a, l);
      };
      C ? b(n, N) : I && b(I, _);
    } else {
      t.el = e.el;
      const A = t.anchor = e.anchor, N = t.target = e.target, I = t.targetAnchor = e.targetAnchor, _ = Bn(e.props), b = _ ? n : N, S = _ ? A : I;
      if (o = o || Ha(N), O ? (f(e.dynamicChildren, O, b, i, s, o, a), qc(e, t, !0)) : l || u(e, t, b, S, i, s, o, a, !1), C)
        _ || ii(
          t,
          n,
          A,
          c,
          1
          /* TeleportMoveTypes.TOGGLE */
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const P = t.target = js(t.props, m);
        P ? ii(
          t,
          P,
          null,
          c,
          0
          /* TeleportMoveTypes.TARGET_CHANGE */
        ) : {}.NODE_ENV !== "production" && Q("Invalid Teleport target on update:", N, `(${typeof N})`);
      } else
        _ && ii(
          t,
          N,
          I,
          c,
          1
          /* TeleportMoveTypes.TOGGLE */
        );
    }
    Kc(t);
  },
  remove(e, t, n, r, { um: i, o: { remove: s } }, o) {
    const { shapeFlag: a, children: l, anchor: c, targetAnchor: d, target: u, props: f } = e;
    if (u && s(d), (o || !Bn(f)) && (s(c), a & 16))
      for (let h = 0; h < l.length; h++) {
        const m = l[h];
        i(m, t, n, !0, !!m.dynamicChildren);
      }
  },
  move: ii,
  hydrate: Vv
};
function ii(e, t, n, { o: { insert: r }, m: i }, s = 2) {
  s === 0 && r(e.targetAnchor, t, n);
  const { el: o, anchor: a, shapeFlag: l, children: c, props: d } = e, u = s === 2;
  if (u && r(o, t, n), (!u || Bn(d)) && l & 16)
    for (let f = 0; f < c.length; f++)
      i(
        c[f],
        t,
        n,
        2
        /* MoveType.REORDER */
      );
  u && r(a, t, n);
}
function Vv(e, t, n, r, i, s, { o: { nextSibling: o, parentNode: a, querySelector: l } }, c) {
  const d = t.target = js(t.props, l);
  if (d) {
    const u = d._lpa || d.firstChild;
    if (t.shapeFlag & 16)
      if (Bn(t.props))
        t.anchor = c(o(e), t, a(e), n, r, i, s), t.targetAnchor = u;
      else {
        t.anchor = o(e);
        let f = u;
        for (; f; )
          if (f = o(f), f && f.nodeType === 8 && f.data === "teleport anchor") {
            t.targetAnchor = f, d._lpa = t.targetAnchor && o(t.targetAnchor);
            break;
          }
        c(u, t, d, n, r, i, s);
      }
    Kc(t);
  }
  return t.anchor && o(t.anchor);
}
const Dv = xv;
function Kc(e) {
  const t = e.ctx;
  if (t && t.ut) {
    let n = e.children[0].el;
    for (; n !== e.targetAnchor; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid), n = n.nextSibling;
    t.ut();
  }
}
const Pe = Symbol({}.NODE_ENV !== "production" ? "Fragment" : void 0), Vo = Symbol({}.NODE_ENV !== "production" ? "Text" : void 0), Mt = Symbol({}.NODE_ENV !== "production" ? "Comment" : void 0), ui = [];
let rt = null;
function F(e = !1) {
  ui.push(rt = e ? null : []);
}
function Lv() {
  ui.pop(), rt = ui[ui.length - 1] || null;
}
let Cr = 1;
function ja(e) {
  Cr += e;
}
function Jc(e) {
  return e.dynamicChildren = Cr > 0 ? rt || rh : null, Lv(), Cr > 0 && rt && rt.push(e), e;
}
function Ne(e, t, n, r, i, s) {
  return Jc(ye(
    e,
    t,
    n,
    r,
    i,
    s,
    !0
    /* isBlock */
  ));
}
function X(e, t, n, r, i) {
  return Jc(v(
    e,
    t,
    n,
    r,
    i,
    !0
    /* isBlock: prevent a block from tracking itself */
  ));
}
function Ws(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function Yc(e, t) {
  return {}.NODE_ENV !== "production" && t.shapeFlag & 6 && Vn.has(t.type) ? (e.shapeFlag &= -257, t.shapeFlag &= -513, !1) : e.type === t.type && e.key === t.key;
}
const $v = (...e) => Zc(...e), Xc = "__vInternal", Qc = ({ key: e }) => e ?? null, di = ({ ref: e, ref_key: t, ref_for: n }) => e != null ? Se(e) || K(e) || ue(e) ? { i: Te, r: e, k: t, f: !!n } : e : null;
function ye(e, t = null, n = null, r = 0, i = null, s = e === Pe ? 0 : 1, o = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Qc(t),
    ref: t && di(t),
    scopeId: Ki,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: r,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: Te
  };
  return a ? (Do(l, n), s & 128 && e.normalize(l)) : n && (l.shapeFlag |= Se(n) ? 8 : 16), {}.NODE_ENV !== "production" && l.key !== l.key && Q("VNode created with invalid key (NaN). VNode type:", l.type), Cr > 0 && // avoid a block node from tracking itself
  !o && // has current parent block
  rt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && rt.push(l), l;
}
const v = {}.NODE_ENV !== "production" ? $v : Zc;
function Zc(e, t = null, n = null, r = 0, i = null, s = !1) {
  if ((!e || e === zc) && ({}.NODE_ENV !== "production" && !e && Q(`Invalid vnode type when creating vnode: ${e}.`), e = Mt), Ws(e)) {
    const a = Gt(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return n && Do(a, n), Cr > 0 && !s && rt && (a.shapeFlag & 6 ? rt[rt.indexOf(e)] = a : rt.push(a)), a.patchFlag |= -2, a;
  }
  if (iu(e) && (e = e.__vccOpts), t) {
    t = Mv(t);
    let { class: a, style: l } = t;
    a && !Se(a) && (t.class = po(a)), fe(l) && (Ci(l) && !ne(l) && (l = Re({}, l)), t.style = go(l));
  }
  const o = Se(e) ? 1 : mv(e) ? 128 : Rv(e) ? 64 : fe(e) ? 4 : ue(e) ? 2 : 0;
  return {}.NODE_ENV !== "production" && o & 4 && Ci(e) && (e = B(e), Q("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, e)), ye(e, t, n, r, i, o, s, !0);
}
function Mv(e) {
  return e ? Ci(e) || Xc in e ? Re({}, e) : e : null;
}
function Gt(e, t, n = !1) {
  const { props: r, ref: i, patchFlag: s, children: o } = e, a = t ? re(r || {}, t) : r;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: a,
    key: a && Qc(a),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && i ? ne(i) ? i.concat(di(t)) : [i, di(t)] : di(t)
    ) : i,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: {}.NODE_ENV !== "production" && s === -1 && ne(o) ? o.map(eu) : o,
    target: e.target,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== Pe ? s === -1 ? 16 : s | 16 : s,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: e.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Gt(e.ssContent),
    ssFallback: e.ssFallback && Gt(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
}
function eu(e) {
  const t = Gt(e);
  return ne(e.children) && (t.children = e.children.map(eu)), t;
}
function q(e = " ", t = 0) {
  return v(Vo, null, e, t);
}
function se(e = "", t = !1) {
  return t ? (F(), X(Mt, null, e)) : v(Mt, null, e);
}
function Bv(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : Gt(e);
}
function Do(e, t) {
  let n = 0;
  const { shapeFlag: r } = e;
  if (t == null)
    t = null;
  else if (ne(t))
    n = 16;
  else if (typeof t == "object")
    if (r & 65) {
      const i = t.default;
      i && (i._c && (i._d = !1), Do(e, i()), i._c && (i._d = !0));
      return;
    } else {
      n = 32;
      const i = t._;
      !i && !(Xc in t) ? t._ctx = Te : i === 3 && Te && (Te.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else
    ue(t) ? (t = { default: t, _ctx: Te }, n = 32) : (t = String(t), r & 64 ? (n = 16, t = [q(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n;
}
function re(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    for (const i in r)
      if (i === "class")
        t.class !== r.class && (t.class = po([t.class, r.class]));
      else if (i === "style")
        t.style = go([t.style, r.style]);
      else if (sh(i)) {
        const s = t[i], o = r[i];
        o && s !== o && !(ne(s) && s.includes(o)) && (t[i] = s ? [].concat(s, o) : o);
      } else
        i !== "" && (t[i] = r[i]);
  }
  return t;
}
let ve = null;
const Cn = () => ve || Te, zs = (e) => {
  ve = e, e.scope.on();
}, tu = () => {
  ve && ve.scope.off(), ve = null;
};
function Fv(e) {
  return e.vnode.shapeFlag & 4;
}
let Uv = !1;
function nu(e) {
  if (e.exposed)
    return e.exposeProxy || (e.exposeProxy = new Proxy(zh(dt(e.exposed)), {
      get(t, n) {
        if (n in t)
          return t[n];
        if (n in dr)
          return dr[n](e);
      },
      has(t, n) {
        return n in t || n in dr;
      }
    }));
}
const Hv = /(?:^|[-_])(\w)/g, jv = (e) => e.replace(Hv, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function Lo(e, t = !0) {
  return ue(e) ? e.displayName || e.name : e.name || t && e.__name;
}
function ru(e, t, n = !1) {
  let r = Lo(t);
  if (!r && t.__file) {
    const i = t.__file.match(/([^/\\]+)\.\w+$/);
    i && (r = i[1]);
  }
  if (!r && e && e.parent) {
    const i = (s) => {
      for (const o in s)
        if (s[o] === t)
          return o;
    };
    r = i(e.components || e.parent.type.components) || i(e.appContext.components);
  }
  return r ? jv(r) : n ? "App" : "Anonymous";
}
function iu(e) {
  return ue(e) && "__vccOpts" in e;
}
const y = (e, t) => Kh(e, t, Uv);
function kn(e, t, n) {
  const r = arguments.length;
  return r === 2 ? fe(t) && !ne(t) ? Ws(t) ? v(e, null, [t]) : v(e, t) : v(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Ws(n) && (n = [n]), v(e, t, n));
}
function gs(e) {
  return !!(e && e.__v_isShallow);
}
function Wv() {
  if ({}.NODE_ENV === "production" || typeof window > "u")
    return;
  const e = { style: "color:#3ba776" }, t = { style: "color:#0b1bc9" }, n = { style: "color:#b62e24" }, r = { style: "color:#9d288c" }, i = {
    header(u) {
      return fe(u) ? u.__isVue ? ["div", e, "VueInstance"] : K(u) ? [
        "div",
        {},
        ["span", e, d(u)],
        "<",
        a(u.value),
        ">"
      ] : st(u) ? [
        "div",
        {},
        ["span", e, gs(u) ? "ShallowReactive" : "Reactive"],
        "<",
        a(u),
        `>${zt(u) ? " (readonly)" : ""}`
      ] : zt(u) ? [
        "div",
        {},
        ["span", e, gs(u) ? "ShallowReadonly" : "Readonly"],
        "<",
        a(u),
        ">"
      ] : null : null;
    },
    hasBody(u) {
      return u && u.__isVue;
    },
    body(u) {
      if (u && u.__isVue)
        return [
          "div",
          {},
          ...s(u.$)
        ];
    }
  };
  function s(u) {
    const f = [];
    u.type.props && u.props && f.push(o("props", B(u.props))), u.setupState !== tt && f.push(o("setup", u.setupState)), u.data !== tt && f.push(o("data", B(u.data)));
    const h = l(u, "computed");
    h && f.push(o("computed", h));
    const m = l(u, "inject");
    return m && f.push(o("injected", m)), f.push([
      "div",
      {},
      [
        "span",
        {
          style: r.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: u }]
    ]), f;
  }
  function o(u, f) {
    return f = Re({}, f), Object.keys(f).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        u
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(f).map((h) => [
          "div",
          {},
          ["span", r, h + ": "],
          a(f[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function a(u, f = !0) {
    return typeof u == "number" ? ["span", t, u] : typeof u == "string" ? ["span", n, JSON.stringify(u)] : typeof u == "boolean" ? ["span", r, u] : fe(u) ? ["object", { object: f ? B(u) : u }] : ["span", n, String(u)];
  }
  function l(u, f) {
    const h = u.type;
    if (ue(h))
      return;
    const m = {};
    for (const g in u.ctx)
      c(h, g, f) && (m[g] = u.ctx[g]);
    return m;
  }
  function c(u, f, h) {
    const m = u[h];
    if (ne(m) && m.includes(f) || fe(m) && f in m || u.extends && c(u.extends, f, h) || u.mixins && u.mixins.some((g) => c(g, f, h)))
      return !0;
  }
  function d(u) {
    return gs(u) ? "ShallowRef" : u.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
const Nt = "transition", er = "animation", Ct = (e, { slots: t }) => kn(Fc, ou(e), t);
Ct.displayName = "Transition";
const su = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, zv = Ct.props = /* @__PURE__ */ Re({}, Fc.props, su), tn = (e, t = []) => {
  ne(e) ? e.forEach((n) => n(...t)) : e && e(...t);
}, Wa = (e) => e ? ne(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
function ou(e) {
  const t = {};
  for (const k in e)
    k in su || (t[k] = e[k]);
  if (e.css === !1)
    return t;
  const { name: n = "v", type: r, duration: i, enterFromClass: s = `${n}-enter-from`, enterActiveClass: o = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: l = s, appearActiveClass: c = o, appearToClass: d = a, leaveFromClass: u = `${n}-leave-from`, leaveActiveClass: f = `${n}-leave-active`, leaveToClass: h = `${n}-leave-to` } = e, m = Gv(i), g = m && m[0], w = m && m[1], { onBeforeEnter: C, onEnter: E, onEnterCancelled: p, onLeave: O, onLeaveCancelled: A, onBeforeAppear: N = C, onAppear: I = E, onAppearCancelled: _ = p } = t, b = (k, R, x) => {
    Rt(k, R ? d : a), Rt(k, R ? c : o), x && x();
  }, S = (k, R) => {
    k._isLeaving = !1, Rt(k, u), Rt(k, h), Rt(k, f), R && R();
  }, P = (k) => (R, x) => {
    const j = k ? I : E, G = () => b(R, k, x);
    tn(j, [R, G]), za(() => {
      Rt(R, k ? l : s), pt(R, k ? d : a), Wa(j) || Ga(R, r, g, G);
    });
  };
  return Re(t, {
    onBeforeEnter(k) {
      tn(C, [k]), pt(k, s), pt(k, o);
    },
    onBeforeAppear(k) {
      tn(N, [k]), pt(k, l), pt(k, c);
    },
    onEnter: P(!1),
    onAppear: P(!0),
    onLeave(k, R) {
      k._isLeaving = !0;
      const x = () => S(k, R);
      pt(k, u), lu(), pt(k, f), za(() => {
        k._isLeaving && (Rt(k, u), pt(k, h), Wa(O) || Ga(k, r, w, x));
      }), tn(O, [k, x]);
    },
    onEnterCancelled(k) {
      b(k, !1), tn(p, [k]);
    },
    onAppearCancelled(k) {
      b(k, !0), tn(_, [k]);
    },
    onLeaveCancelled(k) {
      S(k), tn(A, [k]);
    }
  });
}
function Gv(e) {
  if (e == null)
    return null;
  if (fe(e))
    return [ps(e.enter), ps(e.leave)];
  {
    const t = ps(e);
    return [t, t];
  }
}
function ps(e) {
  const t = dh(e);
  return {}.NODE_ENV !== "production" && tv(t, "<transition> explicit duration"), t;
}
function pt(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e._vtc || (e._vtc = /* @__PURE__ */ new Set())).add(t);
}
function Rt(e, t) {
  t.split(/\s+/).forEach((r) => r && e.classList.remove(r));
  const { _vtc: n } = e;
  n && (n.delete(t), n.size || (e._vtc = void 0));
}
function za(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let qv = 0;
function Ga(e, t, n, r) {
  const i = e._endId = ++qv, s = () => {
    i === e._endId && r();
  };
  if (n)
    return setTimeout(s, n);
  const { type: o, timeout: a, propCount: l } = au(e, t);
  if (!o)
    return r();
  const c = o + "end";
  let d = 0;
  const u = () => {
    e.removeEventListener(c, f), s();
  }, f = (h) => {
    h.target === e && ++d >= l && u();
  };
  setTimeout(() => {
    d < l && u();
  }, a + 1), e.addEventListener(c, f);
}
function au(e, t) {
  const n = window.getComputedStyle(e), r = (m) => (n[m] || "").split(", "), i = r(`${Nt}Delay`), s = r(`${Nt}Duration`), o = qa(i, s), a = r(`${er}Delay`), l = r(`${er}Duration`), c = qa(a, l);
  let d = null, u = 0, f = 0;
  t === Nt ? o > 0 && (d = Nt, u = o, f = s.length) : t === er ? c > 0 && (d = er, u = c, f = l.length) : (u = Math.max(o, c), d = u > 0 ? o > c ? Nt : er : null, f = d ? d === Nt ? s.length : l.length : 0);
  const h = d === Nt && /\b(transform|all)(,|$)/.test(r(`${Nt}Property`).toString());
  return {
    type: d,
    timeout: u,
    propCount: f,
    hasTransform: h
  };
}
function qa(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map((n, r) => Ka(n) + Ka(e[r])));
}
function Ka(e) {
  return Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function lu() {
  return document.body.offsetHeight;
}
const cu = /* @__PURE__ */ new WeakMap(), uu = /* @__PURE__ */ new WeakMap(), du = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ Re({}, zv, {
    tag: String,
    moveClass: String
  }),
  setup(e, { slots: t }) {
    const n = Cn(), r = Bc();
    let i, s;
    return Wc(() => {
      if (!i.length)
        return;
      const o = e.moveClass || `${e.name || "v"}-move`;
      if (!Zv(i[0].el, n.vnode.el, o))
        return;
      i.forEach(Yv), i.forEach(Xv);
      const a = i.filter(Qv);
      lu(), a.forEach((l) => {
        const c = l.el, d = c.style;
        pt(c, o), d.transform = d.webkitTransform = d.transitionDuration = "";
        const u = c._moveCb = (f) => {
          f && f.target !== c || (!f || /transform$/.test(f.propertyName)) && (c.removeEventListener("transitionend", u), c._moveCb = null, Rt(c, o));
        };
        c.addEventListener("transitionend", u);
      });
    }), () => {
      const o = B(e), a = ou(o);
      let l = o.tag || Pe;
      i = s, s = t.default ? xo(t.default()) : [];
      for (let c = 0; c < s.length; c++) {
        const d = s[c];
        d.key != null ? Ir(d, Er(d, a, r, n)) : {}.NODE_ENV !== "production" && Q("<TransitionGroup> children must be keyed.");
      }
      if (i)
        for (let c = 0; c < i.length; c++) {
          const d = i[c];
          Ir(d, Er(d, a, r, n)), cu.set(d, d.el.getBoundingClientRect());
        }
      return v(l, null, s);
    };
  }
}, Kv = (e) => delete e.mode;
du.props;
const Jv = du;
function Yv(e) {
  const t = e.el;
  t._moveCb && t._moveCb(), t._enterCb && t._enterCb();
}
function Xv(e) {
  uu.set(e, e.el.getBoundingClientRect());
}
function Qv(e) {
  const t = cu.get(e), n = uu.get(e), r = t.left - n.left, i = t.top - n.top;
  if (r || i) {
    const s = e.el.style;
    return s.transform = s.webkitTransform = `translate(${r}px,${i}px)`, s.transitionDuration = "0s", e;
  }
}
function Zv(e, t, n) {
  const r = e.cloneNode();
  e._vtc && e._vtc.forEach((o) => {
    o.split(/\s+/).forEach((a) => a && r.classList.remove(a));
  }), n.split(/\s+/).forEach((o) => o && r.classList.add(o)), r.style.display = "none";
  const i = t.nodeType === 1 ? t : t.parentNode;
  i.appendChild(r);
  const { hasTransform: s } = au(r);
  return i.removeChild(r), s;
}
const em = ["ctrl", "shift", "alt", "meta"], tm = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, t) => em.some((n) => e[`${n}Key`] && !t.includes(n))
}, $o = (e, t) => (n, ...r) => {
  for (let i = 0; i < t.length; i++) {
    const s = tm[t[i]];
    if (s && s(n, t))
      return;
  }
  return e(n, ...r);
}, qn = {
  beforeMount(e, { value: t }, { transition: n }) {
    e._vod = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : tr(e, t);
  },
  mounted(e, { value: t }, { transition: n }) {
    n && t && n.enter(e);
  },
  updated(e, { value: t, oldValue: n }, { transition: r }) {
    !t != !n && (r ? t ? (r.beforeEnter(e), tr(e, !0), r.enter(e)) : r.leave(e, () => {
      tr(e, !1);
    }) : tr(e, t));
  },
  beforeUnmount(e, { value: t }) {
    tr(e, t);
  }
};
function tr(e, t) {
  e.style.display = t ? e._vod : "none";
}
function nm() {
  Wv();
}
({}).NODE_ENV !== "production" && nm();
var fu = !1;
function si(e, t, n) {
  return Array.isArray(e) ? (e.length = Math.max(e.length, t), e.splice(t, 1, n), n) : (e[t] = n, n);
}
function ys(e, t) {
  if (Array.isArray(e)) {
    e.splice(t, 1);
    return;
  }
  delete e[t];
}
function rm() {
  return hu().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function hu() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const im = typeof Proxy == "function", sm = "devtools-plugin:setup", om = "plugin:settings:set";
let Rn, Gs;
function am() {
  var e;
  return Rn !== void 0 || (typeof window < "u" && window.performance ? (Rn = !0, Gs = window.performance) : typeof global < "u" && (!((e = global.perf_hooks) === null || e === void 0) && e.performance) ? (Rn = !0, Gs = global.perf_hooks.performance) : Rn = !1), Rn;
}
function lm() {
  return am() ? Gs.now() : Date.now();
}
class cm {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const r = {};
    if (t.settings)
      for (const o in t.settings) {
        const a = t.settings[o];
        r[o] = a.defaultValue;
      }
    const i = `__vue-devtools-plugin-settings__${t.id}`;
    let s = Object.assign({}, r);
    try {
      const o = localStorage.getItem(i), a = JSON.parse(o);
      Object.assign(s, a);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return s;
      },
      setSettings(o) {
        try {
          localStorage.setItem(i, JSON.stringify(o));
        } catch {
        }
        s = o;
      },
      now() {
        return lm();
      }
    }, n && n.on(om, (o, a) => {
      o === this.plugin.id && this.fallbacks.setSettings(a);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, a) => this.target ? this.target.on[a] : (...l) => {
        this.onQueue.push({
          method: a,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
        method: a,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[a](...l)) : (...l) => new Promise((c) => {
        this.targetQueue.push({
          method: a,
          args: l,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function vu(e, t) {
  const n = e, r = hu(), i = rm(), s = im && n.enableEarlyProxy;
  if (i && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
    i.emit(sm, e, t);
  else {
    const o = s ? new cm(n, i) : null;
    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: o
    }), o && t(o.proxiedTarget);
  }
}
/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let sr;
const kr = (e) => sr = e, mu = {}.NODE_ENV !== "production" ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
function pn(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
}
var ft;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})(ft || (ft = {}));
const Ji = typeof window < "u", fr = ({}.NODE_ENV !== "production" || !1) && {}.NODE_ENV !== "test" && Ji, Ja = /* @__PURE__ */ (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null })();
function um(e, { autoBom: t = !1 } = {}) {
  return t && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob([String.fromCharCode(65279), e], { type: e.type }) : e;
}
function Mo(e, t, n) {
  const r = new XMLHttpRequest();
  r.open("GET", e), r.responseType = "blob", r.onload = function() {
    yu(r.response, t, n);
  }, r.onerror = function() {
    console.error("could not download file");
  }, r.send();
}
function gu(e) {
  const t = new XMLHttpRequest();
  t.open("HEAD", e, !1);
  try {
    t.send();
  } catch {
  }
  return t.status >= 200 && t.status <= 299;
}
function fi(e) {
  try {
    e.dispatchEvent(new MouseEvent("click"));
  } catch {
    const n = document.createEvent("MouseEvents");
    n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), e.dispatchEvent(n);
  }
}
const hi = typeof navigator == "object" ? navigator : { userAgent: "" }, pu = /* @__PURE__ */ (() => /Macintosh/.test(hi.userAgent) && /AppleWebKit/.test(hi.userAgent) && !/Safari/.test(hi.userAgent))(), yu = Ji ? (
  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
  typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !pu ? dm : (
    // Use msSaveOrOpenBlob as a second approach
    "msSaveOrOpenBlob" in hi ? fm : (
      // Fallback to using FileReader and a popup
      hm
    )
  )
) : () => {
};
function dm(e, t = "download", n) {
  const r = document.createElement("a");
  r.download = t, r.rel = "noopener", typeof e == "string" ? (r.href = e, r.origin !== location.origin ? gu(r.href) ? Mo(e, t, n) : (r.target = "_blank", fi(r)) : fi(r)) : (r.href = URL.createObjectURL(e), setTimeout(function() {
    URL.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    fi(r);
  }, 0));
}
function fm(e, t = "download", n) {
  if (typeof e == "string")
    if (gu(e))
      Mo(e, t, n);
    else {
      const r = document.createElement("a");
      r.href = e, r.target = "_blank", setTimeout(function() {
        fi(r);
      });
    }
  else
    navigator.msSaveOrOpenBlob(um(e, n), t);
}
function hm(e, t, n, r) {
  if (r = r || open("", "_blank"), r && (r.document.title = r.document.body.innerText = "downloading..."), typeof e == "string")
    return Mo(e, t, n);
  const i = e.type === "application/octet-stream", s = /constructor/i.test(String(Ja.HTMLElement)) || "safari" in Ja, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || i && s || pu) && typeof FileReader < "u") {
    const a = new FileReader();
    a.onloadend = function() {
      let l = a.result;
      if (typeof l != "string")
        throw r = null, new Error("Wrong reader.result type");
      l = o ? l : l.replace(/^data:[^;]*;/, "data:attachment/file;"), r ? r.location.href = l : location.assign(l), r = null;
    }, a.readAsDataURL(e);
  } else {
    const a = URL.createObjectURL(e);
    r ? r.location.assign(a) : location.href = a, r = null, setTimeout(function() {
      URL.revokeObjectURL(a);
    }, 4e4);
  }
}
function ge(e, t) {
  const n = "🍍 " + e;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, t) : t === "error" ? console.error(n) : t === "warn" ? console.warn(n) : console.log(n);
}
function Bo(e) {
  return "_a" in e && "install" in e;
}
function _u() {
  if (!("clipboard" in navigator))
    return ge("Your browser doesn't support the Clipboard API", "error"), !0;
}
function bu(e) {
  return e instanceof Error && e.message.toLowerCase().includes("document is not focused") ? (ge('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
async function vm(e) {
  if (!_u())
    try {
      await navigator.clipboard.writeText(JSON.stringify(e.state.value)), ge("Global state copied to clipboard.");
    } catch (t) {
      if (bu(t))
        return;
      ge("Failed to serialize the state. Check the console for more details.", "error"), console.error(t);
    }
}
async function mm(e) {
  if (!_u())
    try {
      e.state.value = JSON.parse(await navigator.clipboard.readText()), ge("Global state pasted from clipboard.");
    } catch (t) {
      if (bu(t))
        return;
      ge("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(t);
    }
}
async function gm(e) {
  try {
    yu(new Blob([JSON.stringify(e.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (t) {
    ge("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(t);
  }
}
let gt;
function pm() {
  gt || (gt = document.createElement("input"), gt.type = "file", gt.accept = ".json");
  function e() {
    return new Promise((t, n) => {
      gt.onchange = async () => {
        const r = gt.files;
        if (!r)
          return t(null);
        const i = r.item(0);
        return t(i ? { text: await i.text(), file: i } : null);
      }, gt.oncancel = () => t(null), gt.onerror = n, gt.click();
    });
  }
  return e;
}
async function ym(e) {
  try {
    const n = await (await pm())();
    if (!n)
      return;
    const { text: r, file: i } = n;
    e.state.value = JSON.parse(r), ge(`Global state imported from "${i.name}".`);
  } catch (t) {
    ge("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(t);
  }
}
function et(e) {
  return {
    _custom: {
      display: e
    }
  };
}
const wu = "🍍 Pinia (root)", qs = "_root";
function _m(e) {
  return Bo(e) ? {
    id: qs,
    label: wu
  } : {
    id: e.$id,
    label: e.$id
  };
}
function bm(e) {
  if (Bo(e)) {
    const n = Array.from(e._s.keys()), r = e._s;
    return {
      state: n.map((s) => ({
        editable: !0,
        key: s,
        value: e.state.value[s]
      })),
      getters: n.filter((s) => r.get(s)._getters).map((s) => {
        const o = r.get(s);
        return {
          editable: !1,
          key: s,
          value: o._getters.reduce((a, l) => (a[l] = o[l], a), {})
        };
      })
    };
  }
  const t = {
    state: Object.keys(e.$state).map((n) => ({
      editable: !0,
      key: n,
      value: e.$state[n]
    }))
  };
  return e._getters && e._getters.length && (t.getters = e._getters.map((n) => ({
    editable: !1,
    key: n,
    value: e[n]
  }))), e._customProperties.size && (t.customProperties = Array.from(e._customProperties).map((n) => ({
    editable: !0,
    key: n,
    value: e[n]
  }))), t;
}
function wm(e) {
  return e ? Array.isArray(e) ? e.reduce((t, n) => (t.keys.push(n.key), t.operations.push(n.type), t.oldValue[n.key] = n.oldValue, t.newValue[n.key] = n.newValue, t), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: et(e.type),
    key: et(e.key),
    oldValue: e.oldValue,
    newValue: e.newValue
  } : {};
}
function Sm(e) {
  switch (e) {
    case ft.direct:
      return "mutation";
    case ft.patchFunction:
      return "$patch";
    case ft.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let Ln = !0;
const vi = [], sn = "pinia:mutations", we = "pinia", { assign: Em } = Object, Ni = (e) => "🍍 " + e;
function Im(e, t) {
  vu({
    id: "dev.esm.pinia",
    label: "Pinia 🍍",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: vi,
    app: e
  }, (n) => {
    typeof n.now != "function" && ge("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
      id: sn,
      label: "Pinia 🍍",
      color: 15064968
    }), n.addInspector({
      id: we,
      label: "Pinia 🍍",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            vm(t);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await mm(t), n.sendInspectorTree(we), n.sendInspectorState(we);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            gm(t);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await ym(t), n.sendInspectorTree(we), n.sendInspectorState(we);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: "Reset the state (option store only)",
          action: (r) => {
            const i = t._s.get(r);
            i ? i._isOptionsAPI ? (i.$reset(), ge(`Store "${r}" reset.`)) : ge(`Cannot reset "${r}" store because it's a setup store.`, "warn") : ge(`Cannot reset "${r}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), n.on.inspectComponent((r, i) => {
      const s = r.componentInstance && r.componentInstance.proxy;
      if (s && s._pStores) {
        const o = r.componentInstance.proxy._pStores;
        Object.values(o).forEach((a) => {
          r.instanceData.state.push({
            type: Ni(a.$id),
            key: "state",
            editable: !0,
            value: a._isOptionsAPI ? {
              _custom: {
                value: B(a.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => a.$reset()
                  }
                ]
              }
            } : (
              // NOTE: workaround to unwrap transferred refs
              Object.keys(a.$state).reduce((l, c) => (l[c] = a.$state[c], l), {})
            )
          }), a._getters && a._getters.length && r.instanceData.state.push({
            type: Ni(a.$id),
            key: "getters",
            editable: !1,
            value: a._getters.reduce((l, c) => {
              try {
                l[c] = a[c];
              } catch (d) {
                l[c] = d;
              }
              return l;
            }, {})
          });
        });
      }
    }), n.on.getInspectorTree((r) => {
      if (r.app === e && r.inspectorId === we) {
        let i = [t];
        i = i.concat(Array.from(t._s.values())), r.rootNodes = (r.filter ? i.filter((s) => "$id" in s ? s.$id.toLowerCase().includes(r.filter.toLowerCase()) : wu.toLowerCase().includes(r.filter.toLowerCase())) : i).map(_m);
      }
    }), n.on.getInspectorState((r) => {
      if (r.app === e && r.inspectorId === we) {
        const i = r.nodeId === qs ? t : t._s.get(r.nodeId);
        if (!i)
          return;
        i && (r.state = bm(i));
      }
    }), n.on.editInspectorState((r, i) => {
      if (r.app === e && r.inspectorId === we) {
        const s = r.nodeId === qs ? t : t._s.get(r.nodeId);
        if (!s)
          return ge(`store "${r.nodeId}" not found`, "error");
        const { path: o } = r;
        Bo(s) ? o.unshift("state") : (o.length !== 1 || !s._customProperties.has(o[0]) || o[0] in s.$state) && o.unshift("$state"), Ln = !1, r.set(s, o, r.state.value), Ln = !0;
      }
    }), n.on.editComponentState((r) => {
      if (r.type.startsWith("🍍")) {
        const i = r.type.replace(/^🍍\s*/, ""), s = t._s.get(i);
        if (!s)
          return ge(`store "${i}" not found`, "error");
        const { path: o } = r;
        if (o[0] !== "state")
          return ge(`Invalid path for store "${i}":
${o}
Only state can be modified.`);
        o[0] = "$state", Ln = !1, r.set(s, o, r.state.value), Ln = !0;
      }
    });
  });
}
function Cm(e, t) {
  vi.includes(Ni(t.$id)) || vi.push(Ni(t.$id)), vu({
    id: "dev.esm.pinia",
    label: "Pinia 🍍",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: vi,
    app: e,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
      // useEmojis: {
      //   label: 'Use emojis in messages ⚡️',
      //   type: 'boolean',
      //   defaultValue: true,
      // },
    }
  }, (n) => {
    const r = typeof n.now == "function" ? n.now.bind(n) : Date.now;
    t.$onAction(({ after: o, onError: a, name: l, args: c }) => {
      const d = Su++;
      n.addTimelineEvent({
        layerId: sn,
        event: {
          time: r(),
          title: "🛫 " + l,
          subtitle: "start",
          data: {
            store: et(t.$id),
            action: et(l),
            args: c
          },
          groupId: d
        }
      }), o((u) => {
        an = void 0, n.addTimelineEvent({
          layerId: sn,
          event: {
            time: r(),
            title: "🛬 " + l,
            subtitle: "end",
            data: {
              store: et(t.$id),
              action: et(l),
              args: c,
              result: u
            },
            groupId: d
          }
        });
      }), a((u) => {
        an = void 0, n.addTimelineEvent({
          layerId: sn,
          event: {
            time: r(),
            logType: "error",
            title: "💥 " + l,
            subtitle: "end",
            data: {
              store: et(t.$id),
              action: et(l),
              args: c,
              error: u
            },
            groupId: d
          }
        });
      });
    }, !0), t._customProperties.forEach((o) => {
      te(() => T(t[o]), (a, l) => {
        n.notifyComponentUpdate(), n.sendInspectorState(we), Ln && n.addTimelineEvent({
          layerId: sn,
          event: {
            time: r(),
            title: "Change",
            subtitle: o,
            data: {
              newValue: a,
              oldValue: l
            },
            groupId: an
          }
        });
      }, { deep: !0 });
    }), t.$subscribe(({ events: o, type: a }, l) => {
      if (n.notifyComponentUpdate(), n.sendInspectorState(we), !Ln)
        return;
      const c = {
        time: r(),
        title: Sm(a),
        data: Em({ store: et(t.$id) }, wm(o)),
        groupId: an
      };
      an = void 0, a === ft.patchFunction ? c.subtitle = "⤵️" : a === ft.patchObject ? c.subtitle = "🧩" : o && !Array.isArray(o) && (c.subtitle = o.type), o && (c.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: o
        }
      }), n.addTimelineEvent({
        layerId: sn,
        event: c
      });
    }, { detached: !0, flush: "sync" });
    const i = t._hotUpdate;
    t._hotUpdate = dt((o) => {
      i(o), n.addTimelineEvent({
        layerId: sn,
        event: {
          time: r(),
          title: "🔥 " + t.$id,
          subtitle: "HMR update",
          data: {
            store: et(t.$id),
            info: et("HMR update")
          }
        }
      }), n.notifyComponentUpdate(), n.sendInspectorTree(we), n.sendInspectorState(we);
    });
    const { $dispose: s } = t;
    t.$dispose = () => {
      s(), n.notifyComponentUpdate(), n.sendInspectorTree(we), n.sendInspectorState(we), n.getSettings().logStoreChanges && ge(`Disposed "${t.$id}" store 🗑`);
    }, n.notifyComponentUpdate(), n.sendInspectorTree(we), n.sendInspectorState(we), n.getSettings().logStoreChanges && ge(`"${t.$id}" store installed 🆕`);
  });
}
let Su = 0, an;
function Ya(e, t) {
  const n = t.reduce((r, i) => (r[i] = B(e)[i], r), {});
  for (const r in n)
    e[r] = function() {
      const i = Su, s = new Proxy(e, {
        get(...o) {
          return an = i, Reflect.get(...o);
        },
        set(...o) {
          return an = i, Reflect.set(...o);
        }
      });
      return n[r].apply(s, arguments);
    };
}
function km({ app: e, store: t, options: n }) {
  if (!t.$id.startsWith("__hot:")) {
    if (n.state && (t._isOptionsAPI = !0), typeof n.state == "function") {
      Ya(
        // @ts-expect-error: can cast the store...
        t,
        Object.keys(n.actions)
      );
      const r = t._hotUpdate;
      B(t)._hotUpdate = function(i) {
        r.apply(this, arguments), Ya(t, Object.keys(i._hmrPayload.actions));
      };
    }
    Cm(
      e,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      t
    );
  }
}
function Tm() {
  const e = Lr(!0), t = e.run(() => D({}));
  let n = [], r = [];
  const i = dt({
    install(s) {
      kr(i), i._a = s, s.provide(mu, i), s.config.globalProperties.$pinia = i, fr && Im(s, i), r.forEach((o) => n.push(o)), r = [];
    },
    use(s) {
      return !this._a && !fu ? r.push(s) : n.push(s), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: t
  });
  return fr && typeof Proxy < "u" && i.use(km), i;
}
function Eu(e, t) {
  for (const n in t) {
    const r = t[n];
    if (!(n in e))
      continue;
    const i = e[n];
    pn(i) && pn(r) && !K(r) && !st(r) ? e[n] = Eu(i, r) : e[n] = r;
  }
  return e;
}
const Iu = () => {
};
function Xa(e, t, n, r = Iu) {
  e.push(t);
  const i = () => {
    const s = e.indexOf(t);
    s > -1 && (e.splice(s, 1), r());
  };
  return !n && pc() && xe(i), i;
}
function xn(e, ...t) {
  e.slice().forEach((n) => {
    n(...t);
  });
}
function Ks(e, t) {
  e instanceof Map && t instanceof Map && t.forEach((n, r) => e.set(r, n)), e instanceof Set && t instanceof Set && t.forEach(e.add, e);
  for (const n in t) {
    if (!t.hasOwnProperty(n))
      continue;
    const r = t[n], i = e[n];
    pn(i) && pn(r) && e.hasOwnProperty(n) && !K(r) && !st(r) ? e[n] = Ks(i, r) : e[n] = r;
  }
  return e;
}
const Om = {}.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
function Am(e) {
  return !pn(e) || !e.hasOwnProperty(Om);
}
const { assign: ze } = Object;
function Qa(e) {
  return !!(K(e) && e.effect);
}
function Za(e, t, n, r) {
  const { state: i, actions: s, getters: o } = t, a = n.state.value[e];
  let l;
  function c() {
    !a && ({}.NODE_ENV === "production" || !r) && (n.state.value[e] = i ? i() : {});
    const d = {}.NODE_ENV !== "production" && r ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      ki(D(i ? i() : {}).value)
    ) : ki(n.state.value[e]);
    return ze(d, s, Object.keys(o || {}).reduce((u, f) => ({}.NODE_ENV !== "production" && f in d && console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${f}" in store "${e}".`), u[f] = dt(y(() => {
      kr(n);
      const h = n._s.get(e);
      return o[f].call(h, h);
    })), u), {}));
  }
  return l = Js(e, c, t, n, r, !0), l;
}
function Js(e, t, n = {}, r, i, s) {
  let o;
  const a = ze({ actions: {} }, n);
  if ({}.NODE_ENV !== "production" && !r._e.active)
    throw new Error("Pinia destroyed");
  const l = {
    deep: !0
    // flush: 'post',
  };
  ({}).NODE_ENV !== "production" && !fu && (l.onTrigger = (b) => {
    c ? h = b : c == !1 && !I._hotUpdating && (Array.isArray(h) ? h.push(b) : console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let c, d, u = dt([]), f = dt([]), h;
  const m = r.state.value[e];
  !s && !m && ({}.NODE_ENV === "production" || !i) && (r.state.value[e] = {});
  const g = D({});
  let w;
  function C(b) {
    let S;
    c = d = !1, {}.NODE_ENV !== "production" && (h = []), typeof b == "function" ? (b(r.state.value[e]), S = {
      type: ft.patchFunction,
      storeId: e,
      events: h
    }) : (Ks(r.state.value[e], b), S = {
      type: ft.patchObject,
      payload: b,
      storeId: e,
      events: h
    });
    const P = w = Symbol();
    Oe().then(() => {
      w === P && (c = !0);
    }), d = !0, xn(u, S, r.state.value[e]);
  }
  const E = s ? function() {
    const { state: S } = n, P = S ? S() : {};
    this.$patch((k) => {
      ze(k, P);
    });
  } : (
    /* istanbul ignore next */
    {}.NODE_ENV !== "production" ? () => {
      throw new Error(`🍍: Store "${e}" is built using the setup syntax and does not implement $reset().`);
    } : Iu
  );
  function p() {
    o.stop(), u = [], f = [], r._s.delete(e);
  }
  function O(b, S) {
    return function() {
      kr(r);
      const P = Array.from(arguments), k = [], R = [];
      function x(M) {
        k.push(M);
      }
      function j(M) {
        R.push(M);
      }
      xn(f, {
        args: P,
        name: b,
        store: I,
        after: x,
        onError: j
      });
      let G;
      try {
        G = S.apply(this && this.$id === e ? this : I, P);
      } catch (M) {
        throw xn(R, M), M;
      }
      return G instanceof Promise ? G.then((M) => (xn(k, M), M)).catch((M) => (xn(R, M), Promise.reject(M))) : (xn(k, G), G);
    };
  }
  const A = /* @__PURE__ */ dt({
    actions: {},
    getters: {},
    state: [],
    hotState: g
  }), N = {
    _p: r,
    // _s: scope,
    $id: e,
    $onAction: Xa.bind(null, f),
    $patch: C,
    $reset: E,
    $subscribe(b, S = {}) {
      const P = Xa(u, b, S.detached, () => k()), k = o.run(() => te(() => r.state.value[e], (R) => {
        (S.flush === "sync" ? d : c) && b({
          storeId: e,
          type: ft.direct,
          events: h
        }, R);
      }, ze({}, l, S)));
      return P;
    },
    $dispose: p
  }, I = In({}.NODE_ENV !== "production" || fr ? ze(
    {
      _hmrPayload: A,
      _customProperties: dt(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    N
    // must be added later
    // setupStore
  ) : N);
  r._s.set(e, I);
  const _ = r._e.run(() => (o = Lr(), o.run(() => t())));
  for (const b in _) {
    const S = _[b];
    if (K(S) && !Qa(S) || st(S))
      ({}).NODE_ENV !== "production" && i ? si(g.value, b, U(_, b)) : s || (m && Am(S) && (K(S) ? S.value = m[b] : Ks(S, m[b])), r.state.value[e][b] = S), {}.NODE_ENV !== "production" && A.state.push(b);
    else if (typeof S == "function") {
      const P = {}.NODE_ENV !== "production" && i ? S : O(b, S);
      _[b] = P, {}.NODE_ENV !== "production" && (A.actions[b] = S), a.actions[b] = S;
    } else
      ({}).NODE_ENV !== "production" && Qa(S) && (A.getters[b] = s ? (
        // @ts-expect-error
        n.getters[b]
      ) : S, Ji && (_._getters || // @ts-expect-error: same
      (_._getters = dt([]))).push(b));
  }
  if (ze(I, _), ze(B(I), _), Object.defineProperty(I, "$state", {
    get: () => ({}).NODE_ENV !== "production" && i ? g.value : r.state.value[e],
    set: (b) => {
      if ({}.NODE_ENV !== "production" && i)
        throw new Error("cannot set hotState");
      C((S) => {
        ze(S, b);
      });
    }
  }), {}.NODE_ENV !== "production" && (I._hotUpdate = dt((b) => {
    I._hotUpdating = !0, b._hmrPayload.state.forEach((S) => {
      if (S in I.$state) {
        const P = b.$state[S], k = I.$state[S];
        typeof P == "object" && pn(P) && pn(k) ? Eu(P, k) : b.$state[S] = k;
      }
      si(I, S, U(b.$state, S));
    }), Object.keys(I.$state).forEach((S) => {
      S in b.$state || ys(I, S);
    }), c = !1, d = !1, r.state.value[e] = U(b._hmrPayload, "hotState"), d = !0, Oe().then(() => {
      c = !0;
    });
    for (const S in b._hmrPayload.actions) {
      const P = b[S];
      si(I, S, O(S, P));
    }
    for (const S in b._hmrPayload.getters) {
      const P = b._hmrPayload.getters[S], k = s ? (
        // special handling of options api
        y(() => (kr(r), P.call(I, I)))
      ) : P;
      si(I, S, k);
    }
    Object.keys(I._hmrPayload.getters).forEach((S) => {
      S in b._hmrPayload.getters || ys(I, S);
    }), Object.keys(I._hmrPayload.actions).forEach((S) => {
      S in b._hmrPayload.actions || ys(I, S);
    }), I._hmrPayload = b._hmrPayload, I._getters = b._getters, I._hotUpdating = !1;
  })), fr) {
    const b = {
      writable: !0,
      configurable: !0,
      // avoid warning on devtools trying to display this property
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((S) => {
      Object.defineProperty(I, S, ze({ value: I[S] }, b));
    });
  }
  return r._p.forEach((b) => {
    if (fr) {
      const S = o.run(() => b({
        store: I,
        app: r._a,
        pinia: r,
        options: a
      }));
      Object.keys(S || {}).forEach((P) => I._customProperties.add(P)), ze(I, S);
    } else
      ze(I, o.run(() => b({
        store: I,
        app: r._a,
        pinia: r,
        options: a
      })));
  }), {}.NODE_ENV !== "production" && I.$state && typeof I.$state == "object" && typeof I.$state.constructor == "function" && !I.$state.constructor.toString().includes("[native code]") && console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${I.$id}".`), m && s && n.hydrate && n.hydrate(I.$state, m), c = !0, d = !0, I;
}
function Nm(e, t, n) {
  let r, i;
  const s = typeof t == "function";
  typeof e == "string" ? (r = e, i = s ? n : t) : (i = e, r = e.id);
  function o(a, l) {
    const c = Cn();
    if (a = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    ({}.NODE_ENV === "test" && sr && sr._testing ? null : a) || c && me(mu, null), a && kr(a), {}.NODE_ENV !== "production" && !sr)
      throw new Error(`[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    a = sr, a._s.has(r) || (s ? Js(r, t, i, a) : Za(r, i, a), {}.NODE_ENV !== "production" && (o._pinia = a));
    const d = a._s.get(r);
    if ({}.NODE_ENV !== "production" && l) {
      const u = "__hot:" + r, f = s ? Js(u, t, i, a, !0) : Za(u, ze({}, i), a, !0);
      l._hotUpdate(f), delete a.state.value[u], a._s.delete(u);
    }
    if ({}.NODE_ENV !== "production" && Ji && c && c.proxy && // avoid adding stores that are just built for hot module replacement
    !l) {
      const u = c.proxy, f = "_pStores" in u ? u._pStores : u._pStores = {};
      f[r] = d;
    }
    return d;
  }
  return o.$id = r, o;
}
function Tn(e) {
  {
    e = B(e);
    const t = {};
    for (const n in e) {
      const r = e[n];
      (K(r) || st(r)) && (t[n] = // ---
      U(e, n));
    }
    return t;
  }
}
const Pm = () => ({
  config: null,
  // package init configuration
  error: null,
  // error from last operation
  current_user: null,
  // current user
  text_confirmation: null,
  // log in by phone text
  sign_by_phone_step: 1,
  // sign in by phone step
  tab: !1,
  is_loading: !1,
  is_session_persistant: !0,
  is_login_with_phone_shown: !1,
  is_authguard_dialog_shown: !0,
  // login dialog
  is_authguard_dialog_persistent: !0,
  // login dialog persistent option
  is_email_verification_link_sent: !1,
  // email verification confirmation
  is_email_reset_password_link_sent: !1,
  // confirmation for successful reset password link email
  is_email_verification_screen_shown: !1,
  // show email verification screen,
  is_reset_password_screen_shown: !1,
  // show reset password screen,
  is_route_public: !1,
  // is current route public
  is_from_public_to_auth: !1
  // is route going from public page to protected
});
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Cu = function(e) {
  const t = [];
  let n = 0;
  for (let r = 0; r < e.length; r++) {
    let i = e.charCodeAt(r);
    i < 128 ? t[n++] = i : i < 2048 ? (t[n++] = i >> 6 | 192, t[n++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < e.length && (e.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (e.charCodeAt(++r) & 1023), t[n++] = i >> 18 | 240, t[n++] = i >> 12 & 63 | 128, t[n++] = i >> 6 & 63 | 128, t[n++] = i & 63 | 128) : (t[n++] = i >> 12 | 224, t[n++] = i >> 6 & 63 | 128, t[n++] = i & 63 | 128);
  }
  return t;
}, Rm = function(e) {
  const t = [];
  let n = 0, r = 0;
  for (; n < e.length; ) {
    const i = e[n++];
    if (i < 128)
      t[r++] = String.fromCharCode(i);
    else if (i > 191 && i < 224) {
      const s = e[n++];
      t[r++] = String.fromCharCode((i & 31) << 6 | s & 63);
    } else if (i > 239 && i < 365) {
      const s = e[n++], o = e[n++], a = e[n++], l = ((i & 7) << 18 | (s & 63) << 12 | (o & 63) << 6 | a & 63) - 65536;
      t[r++] = String.fromCharCode(55296 + (l >> 10)), t[r++] = String.fromCharCode(56320 + (l & 1023));
    } else {
      const s = e[n++], o = e[n++];
      t[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | o & 63);
    }
  }
  return t.join("");
}, ku = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(e, t) {
    if (!Array.isArray(e))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = [];
    for (let i = 0; i < e.length; i += 3) {
      const s = e[i], o = i + 1 < e.length, a = o ? e[i + 1] : 0, l = i + 2 < e.length, c = l ? e[i + 2] : 0, d = s >> 2, u = (s & 3) << 4 | a >> 4;
      let f = (a & 15) << 2 | c >> 6, h = c & 63;
      l || (h = 64, o || (f = 64)), r.push(n[d], n[u], n[f], n[h]);
    }
    return r.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(e, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(Cu(e), t);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(e, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : Rm(this.decodeStringToByteArray(e, t));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(e, t) {
    this.init_();
    const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = [];
    for (let i = 0; i < e.length; ) {
      const s = n[e.charAt(i++)], a = i < e.length ? n[e.charAt(i)] : 0;
      ++i;
      const c = i < e.length ? n[e.charAt(i)] : 64;
      ++i;
      const u = i < e.length ? n[e.charAt(i)] : 64;
      if (++i, s == null || a == null || c == null || u == null)
        throw new xm();
      const f = s << 2 | a >> 4;
      if (r.push(f), c !== 64) {
        const h = a << 4 & 240 | c >> 2;
        if (r.push(h), u !== 64) {
          const m = c << 6 & 192 | u;
          r.push(m);
        }
      }
    }
    return r;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let e = 0; e < this.ENCODED_VALS.length; e++)
        this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e);
    }
  }
};
class xm extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const Vm = function(e) {
  const t = Cu(e);
  return ku.encodeByteArray(t, !0);
}, Tu = function(e) {
  return Vm(e).replace(/\./g, "");
}, Ou = function(e) {
  try {
    return ku.decodeString(e, !0);
  } catch (t) {
    console.error("base64Decode failed: ", t);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Dm() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Lm = () => Dm().__FIREBASE_DEFAULTS__, $m = () => {
  if (typeof process > "u" || typeof {} > "u")
    return;
  const e = {}.__FIREBASE_DEFAULTS__;
  if (e)
    return JSON.parse(e);
}, Mm = () => {
  if (typeof document > "u")
    return;
  let e;
  try {
    e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const t = e && Ou(e[1]);
  return t && JSON.parse(t);
}, Fo = () => {
  try {
    return Lm() || $m() || Mm();
  } catch (e) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
    return;
  }
}, Bm = (e) => {
  var t, n;
  return (n = (t = Fo()) === null || t === void 0 ? void 0 : t.emulatorHosts) === null || n === void 0 ? void 0 : n[e];
}, Fm = () => {
  var e;
  return (e = Fo()) === null || e === void 0 ? void 0 : e.config;
}, Au = (e) => {
  var t;
  return (t = Fo()) === null || t === void 0 ? void 0 : t[`_${e}`];
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Um {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((t, n) => {
      this.resolve = t, this.reject = n;
    });
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(t) {
    return (n, r) => {
      n ? this.reject(n) : this.resolve(r), typeof t == "function" && (this.promise.catch(() => {
      }), t.length === 1 ? t(n) : t(n, r));
    };
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ee() {
  return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : "";
}
function Hm() {
  return typeof window < "u" && // @ts-ignore Setting up an broadly applicable index signature for Window
  // just to deal with this case would probably be a bad idea.
  !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Ee());
}
function jm() {
  const e = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
  return typeof e == "object" && e.id !== void 0;
}
function Wm() {
  return typeof navigator == "object" && navigator.product === "ReactNative";
}
function zm() {
  const e = Ee();
  return e.indexOf("MSIE ") >= 0 || e.indexOf("Trident/") >= 0;
}
function Gm() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function qm() {
  return new Promise((e, t) => {
    try {
      let n = !0;
      const r = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(r);
      i.onsuccess = () => {
        i.result.close(), n || self.indexedDB.deleteDatabase(r), e(!0);
      }, i.onupgradeneeded = () => {
        n = !1;
      }, i.onerror = () => {
        var s;
        t(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (n) {
      t(n);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Km = "FirebaseError";
class Jt extends Error {
  constructor(t, n, r) {
    super(n), this.code = t, this.customData = r, this.name = Km, Object.setPrototypeOf(this, Jt.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Br.prototype.create);
  }
}
class Br {
  constructor(t, n, r) {
    this.service = t, this.serviceName = n, this.errors = r;
  }
  create(t, ...n) {
    const r = n[0] || {}, i = `${this.service}/${t}`, s = this.errors[t], o = s ? Jm(s, r) : "Error", a = `${this.serviceName}: ${o} (${i}).`;
    return new Jt(i, a, r);
  }
}
function Jm(e, t) {
  return e.replace(Ym, (n, r) => {
    const i = t[r];
    return i != null ? String(i) : `<${r}?>`;
  });
}
const Ym = /\{\$([^}]+)}/g;
function Xm(e) {
  for (const t in e)
    if (Object.prototype.hasOwnProperty.call(e, t))
      return !1;
  return !0;
}
function Pi(e, t) {
  if (e === t)
    return !0;
  const n = Object.keys(e), r = Object.keys(t);
  for (const i of n) {
    if (!r.includes(i))
      return !1;
    const s = e[i], o = t[i];
    if (el(s) && el(o)) {
      if (!Pi(s, o))
        return !1;
    } else if (s !== o)
      return !1;
  }
  for (const i of r)
    if (!n.includes(i))
      return !1;
  return !0;
}
function el(e) {
  return e !== null && typeof e == "object";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Kn(e) {
  const t = [];
  for (const [n, r] of Object.entries(e))
    Array.isArray(r) ? r.forEach((i) => {
      t.push(encodeURIComponent(n) + "=" + encodeURIComponent(i));
    }) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(r));
  return t.length ? "&" + t.join("&") : "";
}
function or(e) {
  const t = {};
  return e.replace(/^\?/, "").split("&").forEach((r) => {
    if (r) {
      const [i, s] = r.split("=");
      t[decodeURIComponent(i)] = decodeURIComponent(s);
    }
  }), t;
}
function ar(e) {
  const t = e.indexOf("?");
  if (!t)
    return "";
  const n = e.indexOf("#", t);
  return e.substring(t, n > 0 ? n : void 0);
}
function Qm(e, t) {
  const n = new Zm(e, t);
  return n.subscribe.bind(n);
}
class Zm {
  /**
   * @param executor Function which can make calls to a single Observer
   *     as a proxy.
   * @param onNoObservers Callback when count of Observers goes to zero.
   */
  constructor(t, n) {
    this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = n, this.task.then(() => {
      t(this);
    }).catch((r) => {
      this.error(r);
    });
  }
  next(t) {
    this.forEachObserver((n) => {
      n.next(t);
    });
  }
  error(t) {
    this.forEachObserver((n) => {
      n.error(t);
    }), this.close(t);
  }
  complete() {
    this.forEachObserver((t) => {
      t.complete();
    }), this.close();
  }
  /**
   * Subscribe function that can be used to add an Observer to the fan-out list.
   *
   * - We require that no event is sent to a subscriber sychronously to their
   *   call to subscribe().
   */
  subscribe(t, n, r) {
    let i;
    if (t === void 0 && n === void 0 && r === void 0)
      throw new Error("Missing Observer.");
    eg(t, [
      "next",
      "error",
      "complete"
    ]) ? i = t : i = {
      next: t,
      error: n,
      complete: r
    }, i.next === void 0 && (i.next = _s), i.error === void 0 && (i.error = _s), i.complete === void 0 && (i.complete = _s);
    const s = this.unsubscribeOne.bind(this, this.observers.length);
    return this.finalized && this.task.then(() => {
      try {
        this.finalError ? i.error(this.finalError) : i.complete();
      } catch {
      }
    }), this.observers.push(i), s;
  }
  // Unsubscribe is synchronous - we guarantee that no events are sent to
  // any unsubscribed Observer.
  unsubscribeOne(t) {
    this.observers === void 0 || this.observers[t] === void 0 || (delete this.observers[t], this.observerCount -= 1, this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this));
  }
  forEachObserver(t) {
    if (!this.finalized)
      for (let n = 0; n < this.observers.length; n++)
        this.sendOne(n, t);
  }
  // Call the Observer via one of it's callback function. We are careful to
  // confirm that the observe has not been unsubscribed since this asynchronous
  // function had been queued.
  sendOne(t, n) {
    this.task.then(() => {
      if (this.observers !== void 0 && this.observers[t] !== void 0)
        try {
          n(this.observers[t]);
        } catch (r) {
          typeof console < "u" && console.error && console.error(r);
        }
    });
  }
  close(t) {
    this.finalized || (this.finalized = !0, t !== void 0 && (this.finalError = t), this.task.then(() => {
      this.observers = void 0, this.onNoObservers = void 0;
    }));
  }
}
function eg(e, t) {
  if (typeof e != "object" || e === null)
    return !1;
  for (const n of t)
    if (n in e && typeof e[n] == "function")
      return !0;
  return !1;
}
function _s() {
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Fe(e) {
  return e && e._delegate ? e._delegate : e;
}
class jn {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(t, n, r) {
    this.name = t, this.instanceFactory = n, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(t) {
    return this.instantiationMode = t, this;
  }
  setMultipleInstances(t) {
    return this.multipleInstances = t, this;
  }
  setServiceProps(t) {
    return this.serviceProps = t, this;
  }
  setInstanceCreatedCallback(t) {
    return this.onInstanceCreated = t, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const on = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class tg {
  constructor(t, n) {
    this.name = t, this.container = n, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(t) {
    const n = this.normalizeInstanceIdentifier(t);
    if (!this.instancesDeferred.has(n)) {
      const r = new Um();
      if (this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize())
        try {
          const i = this.getOrInitializeService({
            instanceIdentifier: n
          });
          i && r.resolve(i);
        } catch {
        }
    }
    return this.instancesDeferred.get(n).promise;
  }
  getImmediate(t) {
    var n;
    const r = this.normalizeInstanceIdentifier(t == null ? void 0 : t.identifier), i = (n = t == null ? void 0 : t.optional) !== null && n !== void 0 ? n : !1;
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: r
        });
      } catch (s) {
        if (i)
          return null;
        throw s;
      }
    else {
      if (i)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(t) {
    if (t.name !== this.name)
      throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = t, !!this.shouldAutoInitialize()) {
      if (rg(t))
        try {
          this.getOrInitializeService({ instanceIdentifier: on });
        } catch {
        }
      for (const [n, r] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(n);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: i
          });
          r.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(t = on) {
    this.instancesDeferred.delete(t), this.instancesOptions.delete(t), this.instances.delete(t);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const t = Array.from(this.instances.values());
    await Promise.all([
      ...t.filter((n) => "INTERNAL" in n).map((n) => n.INTERNAL.delete()),
      ...t.filter((n) => "_delete" in n).map((n) => n._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(t = on) {
    return this.instances.has(t);
  }
  getOptions(t = on) {
    return this.instancesOptions.get(t) || {};
  }
  initialize(t = {}) {
    const { options: n = {} } = t, r = this.normalizeInstanceIdentifier(t.instanceIdentifier);
    if (this.isInitialized(r))
      throw Error(`${this.name}(${r}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const i = this.getOrInitializeService({
      instanceIdentifier: r,
      options: n
    });
    for (const [s, o] of this.instancesDeferred.entries()) {
      const a = this.normalizeInstanceIdentifier(s);
      r === a && o.resolve(i);
    }
    return i;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(t, n) {
    var r;
    const i = this.normalizeInstanceIdentifier(n), s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : /* @__PURE__ */ new Set();
    s.add(t), this.onInitCallbacks.set(i, s);
    const o = this.instances.get(i);
    return o && t(o, i), () => {
      s.delete(t);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(t, n) {
    const r = this.onInitCallbacks.get(n);
    if (r)
      for (const i of r)
        try {
          i(t, n);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: t, options: n = {} }) {
    let r = this.instances.get(t);
    if (!r && this.component && (r = this.component.instanceFactory(this.container, {
      instanceIdentifier: ng(t),
      options: n
    }), this.instances.set(t, r), this.instancesOptions.set(t, n), this.invokeOnInitCallbacks(r, t), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, t, r);
      } catch {
      }
    return r || null;
  }
  normalizeInstanceIdentifier(t = on) {
    return this.component ? this.component.multipleInstances ? t : on : t;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function ng(e) {
  return e === on ? void 0 : e;
}
function rg(e) {
  return e.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ig {
  constructor(t) {
    this.name = t, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(t) {
    const n = this.getProvider(t.name);
    if (n.isComponentSet())
      throw new Error(`Component ${t.name} has already been registered with ${this.name}`);
    n.setComponent(t);
  }
  addOrOverwriteComponent(t) {
    this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name), this.addComponent(t);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(t) {
    if (this.providers.has(t))
      return this.providers.get(t);
    const n = new tg(t, this);
    return this.providers.set(t, n), n;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ie;
(function(e) {
  e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT";
})(ie || (ie = {}));
const sg = {
  debug: ie.DEBUG,
  verbose: ie.VERBOSE,
  info: ie.INFO,
  warn: ie.WARN,
  error: ie.ERROR,
  silent: ie.SILENT
}, og = ie.INFO, ag = {
  [ie.DEBUG]: "log",
  [ie.VERBOSE]: "log",
  [ie.INFO]: "info",
  [ie.WARN]: "warn",
  [ie.ERROR]: "error"
}, lg = (e, t, ...n) => {
  if (t < e.logLevel)
    return;
  const r = (/* @__PURE__ */ new Date()).toISOString(), i = ag[t];
  if (i)
    console[i](`[${r}]  ${e.name}:`, ...n);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
};
class Nu {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(t) {
    this.name = t, this._logLevel = og, this._logHandler = lg, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(t) {
    if (!(t in ie))
      throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);
    this._logLevel = t;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(t) {
    this._logLevel = typeof t == "string" ? sg[t] : t;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(t) {
    if (typeof t != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = t;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(t) {
    this._userLogHandler = t;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...t) {
    this._userLogHandler && this._userLogHandler(this, ie.DEBUG, ...t), this._logHandler(this, ie.DEBUG, ...t);
  }
  log(...t) {
    this._userLogHandler && this._userLogHandler(this, ie.VERBOSE, ...t), this._logHandler(this, ie.VERBOSE, ...t);
  }
  info(...t) {
    this._userLogHandler && this._userLogHandler(this, ie.INFO, ...t), this._logHandler(this, ie.INFO, ...t);
  }
  warn(...t) {
    this._userLogHandler && this._userLogHandler(this, ie.WARN, ...t), this._logHandler(this, ie.WARN, ...t);
  }
  error(...t) {
    this._userLogHandler && this._userLogHandler(this, ie.ERROR, ...t), this._logHandler(this, ie.ERROR, ...t);
  }
}
const cg = (e, t) => t.some((n) => e instanceof n);
let tl, nl;
function ug() {
  return tl || (tl = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function dg() {
  return nl || (nl = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const Pu = /* @__PURE__ */ new WeakMap(), Ys = /* @__PURE__ */ new WeakMap(), Ru = /* @__PURE__ */ new WeakMap(), bs = /* @__PURE__ */ new WeakMap(), Uo = /* @__PURE__ */ new WeakMap();
function fg(e) {
  const t = new Promise((n, r) => {
    const i = () => {
      e.removeEventListener("success", s), e.removeEventListener("error", o);
    }, s = () => {
      n(Bt(e.result)), i();
    }, o = () => {
      r(e.error), i();
    };
    e.addEventListener("success", s), e.addEventListener("error", o);
  });
  return t.then((n) => {
    n instanceof IDBCursor && Pu.set(n, e);
  }).catch(() => {
  }), Uo.set(t, e), t;
}
function hg(e) {
  if (Ys.has(e))
    return;
  const t = new Promise((n, r) => {
    const i = () => {
      e.removeEventListener("complete", s), e.removeEventListener("error", o), e.removeEventListener("abort", o);
    }, s = () => {
      n(), i();
    }, o = () => {
      r(e.error || new DOMException("AbortError", "AbortError")), i();
    };
    e.addEventListener("complete", s), e.addEventListener("error", o), e.addEventListener("abort", o);
  });
  Ys.set(e, t);
}
let Xs = {
  get(e, t, n) {
    if (e instanceof IDBTransaction) {
      if (t === "done")
        return Ys.get(e);
      if (t === "objectStoreNames")
        return e.objectStoreNames || Ru.get(e);
      if (t === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Bt(e[t]);
  },
  set(e, t, n) {
    return e[t] = n, !0;
  },
  has(e, t) {
    return e instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in e;
  }
};
function vg(e) {
  Xs = e(Xs);
}
function mg(e) {
  return e === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(t, ...n) {
    const r = e.call(ws(this), t, ...n);
    return Ru.set(r, t.sort ? t.sort() : [t]), Bt(r);
  } : dg().includes(e) ? function(...t) {
    return e.apply(ws(this), t), Bt(Pu.get(this));
  } : function(...t) {
    return Bt(e.apply(ws(this), t));
  };
}
function gg(e) {
  return typeof e == "function" ? mg(e) : (e instanceof IDBTransaction && hg(e), cg(e, ug()) ? new Proxy(e, Xs) : e);
}
function Bt(e) {
  if (e instanceof IDBRequest)
    return fg(e);
  if (bs.has(e))
    return bs.get(e);
  const t = gg(e);
  return t !== e && (bs.set(e, t), Uo.set(t, e)), t;
}
const ws = (e) => Uo.get(e);
function pg(e, t, { blocked: n, upgrade: r, blocking: i, terminated: s } = {}) {
  const o = indexedDB.open(e, t), a = Bt(o);
  return r && o.addEventListener("upgradeneeded", (l) => {
    r(Bt(o.result), l.oldVersion, l.newVersion, Bt(o.transaction));
  }), n && o.addEventListener("blocked", () => n()), a.then((l) => {
    s && l.addEventListener("close", () => s()), i && l.addEventListener("versionchange", () => i());
  }).catch(() => {
  }), a;
}
const yg = ["get", "getKey", "getAll", "getAllKeys", "count"], _g = ["put", "add", "delete", "clear"], Ss = /* @__PURE__ */ new Map();
function rl(e, t) {
  if (!(e instanceof IDBDatabase && !(t in e) && typeof t == "string"))
    return;
  if (Ss.get(t))
    return Ss.get(t);
  const n = t.replace(/FromIndex$/, ""), r = t !== n, i = _g.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || yg.includes(n))
  )
    return;
  const s = async function(o, ...a) {
    const l = this.transaction(o, i ? "readwrite" : "readonly");
    let c = l.store;
    return r && (c = c.index(a.shift())), (await Promise.all([
      c[n](...a),
      i && l.done
    ]))[0];
  };
  return Ss.set(t, s), s;
}
vg((e) => ({
  ...e,
  get: (t, n, r) => rl(t, n) || e.get(t, n, r),
  has: (t, n) => !!rl(t, n) || e.has(t, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bg {
  constructor(t) {
    this.container = t;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((n) => {
      if (wg(n)) {
        const r = n.getImmediate();
        return `${r.library}/${r.version}`;
      } else
        return null;
    }).filter((n) => n).join(" ");
  }
}
function wg(e) {
  const t = e.getComponent();
  return (t == null ? void 0 : t.type) === "VERSION";
}
const Qs = "@firebase/app", il = "0.9.7";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yn = new Nu("@firebase/app"), Sg = "@firebase/app-compat", Eg = "@firebase/analytics-compat", Ig = "@firebase/analytics", Cg = "@firebase/app-check-compat", kg = "@firebase/app-check", Tg = "@firebase/auth", Og = "@firebase/auth-compat", Ag = "@firebase/database", Ng = "@firebase/database-compat", Pg = "@firebase/functions", Rg = "@firebase/functions-compat", xg = "@firebase/installations", Vg = "@firebase/installations-compat", Dg = "@firebase/messaging", Lg = "@firebase/messaging-compat", $g = "@firebase/performance", Mg = "@firebase/performance-compat", Bg = "@firebase/remote-config", Fg = "@firebase/remote-config-compat", Ug = "@firebase/storage", Hg = "@firebase/storage-compat", jg = "@firebase/firestore", Wg = "@firebase/firestore-compat", zg = "firebase", Gg = "9.19.1";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Zs = "[DEFAULT]", qg = {
  [Qs]: "fire-core",
  [Sg]: "fire-core-compat",
  [Ig]: "fire-analytics",
  [Eg]: "fire-analytics-compat",
  [kg]: "fire-app-check",
  [Cg]: "fire-app-check-compat",
  [Tg]: "fire-auth",
  [Og]: "fire-auth-compat",
  [Ag]: "fire-rtdb",
  [Ng]: "fire-rtdb-compat",
  [Pg]: "fire-fn",
  [Rg]: "fire-fn-compat",
  [xg]: "fire-iid",
  [Vg]: "fire-iid-compat",
  [Dg]: "fire-fcm",
  [Lg]: "fire-fcm-compat",
  [$g]: "fire-perf",
  [Mg]: "fire-perf-compat",
  [Bg]: "fire-rc",
  [Fg]: "fire-rc-compat",
  [Ug]: "fire-gcs",
  [Hg]: "fire-gcs-compat",
  [jg]: "fire-fst",
  [Wg]: "fire-fst-compat",
  "fire-js": "fire-js",
  [zg]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ri = /* @__PURE__ */ new Map(), eo = /* @__PURE__ */ new Map();
function Kg(e, t) {
  try {
    e.container.addComponent(t);
  } catch (n) {
    yn.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n);
  }
}
function Tr(e) {
  const t = e.name;
  if (eo.has(t))
    return yn.debug(`There were multiple attempts to register component ${t}.`), !1;
  eo.set(t, e);
  for (const n of Ri.values())
    Kg(n, e);
  return !0;
}
function xu(e, t) {
  const n = e.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return n && n.triggerHeartbeat(), e.container.getProvider(t);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jg = {
  [
    "no-app"
    /* AppError.NO_APP */
  ]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  [
    "bad-app-name"
    /* AppError.BAD_APP_NAME */
  ]: "Illegal App name: '{$appName}",
  [
    "duplicate-app"
    /* AppError.DUPLICATE_APP */
  ]: "Firebase App named '{$appName}' already exists with different options or config",
  [
    "app-deleted"
    /* AppError.APP_DELETED */
  ]: "Firebase App named '{$appName}' already deleted",
  [
    "no-options"
    /* AppError.NO_OPTIONS */
  ]: "Need to provide options, when not being deployed to hosting via source.",
  [
    "invalid-app-argument"
    /* AppError.INVALID_APP_ARGUMENT */
  ]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  [
    "invalid-log-argument"
    /* AppError.INVALID_LOG_ARGUMENT */
  ]: "First argument to `onLog` must be null or a function.",
  [
    "idb-open"
    /* AppError.IDB_OPEN */
  ]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-get"
    /* AppError.IDB_GET */
  ]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-set"
    /* AppError.IDB_WRITE */
  ]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-delete"
    /* AppError.IDB_DELETE */
  ]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
}, Ft = new Br("app", "Firebase", Jg);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Yg {
  constructor(t, n, r) {
    this._isDeleted = !1, this._options = Object.assign({}, t), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new jn(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(t) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = t;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(t) {
    this._isDeleted = t;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw Ft.create("app-deleted", { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yi = Gg;
function Xg(e, t = {}) {
  let n = e;
  typeof t != "object" && (t = { name: t });
  const r = Object.assign({ name: Zs, automaticDataCollectionEnabled: !1 }, t), i = r.name;
  if (typeof i != "string" || !i)
    throw Ft.create("bad-app-name", {
      appName: String(i)
    });
  if (n || (n = Fm()), !n)
    throw Ft.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = Ri.get(i);
  if (s) {
    if (Pi(n, s.options) && Pi(r, s.config))
      return s;
    throw Ft.create("duplicate-app", { appName: i });
  }
  const o = new ig(i);
  for (const l of eo.values())
    o.addComponent(l);
  const a = new Yg(n, r, o);
  return Ri.set(i, a), a;
}
function Qg(e = Zs) {
  const t = Ri.get(e);
  if (!t && e === Zs)
    return Xg();
  if (!t)
    throw Ft.create("no-app", { appName: e });
  return t;
}
function hr(e, t, n) {
  var r;
  let i = (r = qg[e]) !== null && r !== void 0 ? r : e;
  n && (i += `-${n}`);
  const s = i.match(/\s|\//), o = t.match(/\s|\//);
  if (s || o) {
    const a = [
      `Unable to register library "${i}" with version "${t}":`
    ];
    s && a.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && o && a.push("and"), o && a.push(`version name "${t}" contains illegal characters (whitespace or "/")`), yn.warn(a.join(" "));
    return;
  }
  Tr(new jn(
    `${i}-version`,
    () => ({ library: i, version: t }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Zg = "firebase-heartbeat-database", ep = 1, Or = "firebase-heartbeat-store";
let Es = null;
function Vu() {
  return Es || (Es = pg(Zg, ep, {
    upgrade: (e, t) => {
      switch (t) {
        case 0:
          e.createObjectStore(Or);
      }
    }
  }).catch((e) => {
    throw Ft.create("idb-open", {
      originalErrorMessage: e.message
    });
  })), Es;
}
async function tp(e) {
  try {
    return (await Vu()).transaction(Or).objectStore(Or).get(Du(e));
  } catch (t) {
    if (t instanceof Jt)
      yn.warn(t.message);
    else {
      const n = Ft.create("idb-get", {
        originalErrorMessage: t == null ? void 0 : t.message
      });
      yn.warn(n.message);
    }
  }
}
async function sl(e, t) {
  try {
    const r = (await Vu()).transaction(Or, "readwrite");
    return await r.objectStore(Or).put(t, Du(e)), r.done;
  } catch (n) {
    if (n instanceof Jt)
      yn.warn(n.message);
    else {
      const r = Ft.create("idb-set", {
        originalErrorMessage: n == null ? void 0 : n.message
      });
      yn.warn(r.message);
    }
  }
}
function Du(e) {
  return `${e.name}!${e.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const np = 1024, rp = 30 * 24 * 60 * 60 * 1e3;
class ip {
  constructor(t) {
    this.container = t, this._heartbeatsCache = null;
    const n = this.container.getProvider("app").getImmediate();
    this._storage = new op(n), this._heartbeatsCachePromise = this._storage.read().then((r) => (this._heartbeatsCache = r, r));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    const n = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), r = ol();
    if (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise), !(this._heartbeatsCache.lastSentHeartbeatDate === r || this._heartbeatsCache.heartbeats.some((i) => i.date === r)))
      return this._heartbeatsCache.heartbeats.push({ date: r, agent: n }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((i) => {
        const s = new Date(i.date).valueOf();
        return Date.now() - s <= rp;
      }), this._storage.overwrite(this._heartbeatsCache);
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0)
      return "";
    const t = ol(), { heartbeatsToSend: n, unsentEntries: r } = sp(this._heartbeatsCache.heartbeats), i = Tu(JSON.stringify({ version: 2, heartbeats: n }));
    return this._heartbeatsCache.lastSentHeartbeatDate = t, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), i;
  }
}
function ol() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function sp(e, t = np) {
  const n = [];
  let r = e.slice();
  for (const i of e) {
    const s = n.find((o) => o.agent === i.agent);
    if (s) {
      if (s.dates.push(i.date), al(n) > t) {
        s.dates.pop();
        break;
      }
    } else if (n.push({
      agent: i.agent,
      dates: [i.date]
    }), al(n) > t) {
      n.pop();
      break;
    }
    r = r.slice(1);
  }
  return {
    heartbeatsToSend: n,
    unsentEntries: r
  };
}
class op {
  constructor(t) {
    this.app = t, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return Gm() ? qm().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    return await this._canUseIndexedDBPromise ? await tp(this.app) || { heartbeats: [] } : { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(t) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return sl(this.app, {
        lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
        heartbeats: t.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(t) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return sl(this.app, {
        lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
        heartbeats: [
          ...i.heartbeats,
          ...t.heartbeats
        ]
      });
    } else
      return;
  }
}
function al(e) {
  return Tu(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: e })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ap(e) {
  Tr(new jn(
    "platform-logger",
    (t) => new bg(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Tr(new jn(
    "heartbeat",
    (t) => new ip(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), hr(Qs, il, e), hr(Qs, il, "esm2017"), hr("fire-js", "");
}
ap("");
function Ho(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function Lu() {
  return {
    [
      "dependent-sdk-initialized-before-auth"
      /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
    ]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
  };
}
const lp = Lu, $u = new Br("auth", "Firebase", Lu());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ll = new Nu("@firebase/auth");
function mi(e, ...t) {
  ll.logLevel <= ie.ERROR && ll.error(`Auth (${Yi}): ${e}`, ...t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ke(e, ...t) {
  throw jo(e, ...t);
}
function Me(e, ...t) {
  return jo(e, ...t);
}
function Mu(e, t, n) {
  const r = Object.assign(Object.assign({}, lp()), { [t]: n });
  return new Br("auth", "Firebase", r).create(t, {
    appName: e.name
  });
}
function cp(e, t, n) {
  const r = n;
  if (!(t instanceof r))
    throw r.name !== t.constructor.name && Ke(
      e,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), Mu(e, "argument-error", `Type of ${t.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`);
}
function jo(e, ...t) {
  if (typeof e != "string") {
    const n = t[0], r = [...t.slice(1)];
    return r[0] && (r[0].appName = e.name), e._errorFactory.create(n, ...r);
  }
  return $u.create(e, ...t);
}
function L(e, t, ...n) {
  if (!e)
    throw jo(t, ...n);
}
function bt(e) {
  const t = "INTERNAL ASSERTION FAILED: " + e;
  throw mi(t), new Error(t);
}
function kt(e, t) {
  e || bt(t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cl = /* @__PURE__ */ new Map();
function wt(e) {
  kt(e instanceof Function, "Expected a class definition");
  let t = cl.get(e);
  return t ? (kt(t instanceof e, "Instance stored in cache mismatched with class"), t) : (t = new e(), cl.set(e, t), t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function up(e, t) {
  const n = xu(e, "auth");
  if (n.isInitialized()) {
    const i = n.getImmediate(), s = n.getOptions();
    if (Pi(s, t ?? {}))
      return i;
    Ke(
      i,
      "already-initialized"
      /* AuthErrorCode.ALREADY_INITIALIZED */
    );
  }
  return n.initialize({ options: t });
}
function dp(e, t) {
  const n = (t == null ? void 0 : t.persistence) || [], r = (Array.isArray(n) ? n : [n]).map(wt);
  t != null && t.errorMap && e._updateErrorMap(t.errorMap), e._initializeWithPersistence(r, t == null ? void 0 : t.popupRedirectResolver);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function to() {
  var e;
  return typeof self < "u" && ((e = self.location) === null || e === void 0 ? void 0 : e.href) || "";
}
function Bu() {
  return ul() === "http:" || ul() === "https:";
}
function ul() {
  var e;
  return typeof self < "u" && ((e = self.location) === null || e === void 0 ? void 0 : e.protocol) || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fp() {
  return typeof navigator < "u" && navigator && "onLine" in navigator && typeof navigator.onLine == "boolean" && // Apply only for traditional web apps and Chrome extensions.
  // This is especially true for Cordova apps which have unreliable
  // navigator.onLine behavior unless cordova-plugin-network-information is
  // installed which overwrites the native navigator.onLine value and
  // defines navigator.connection.
  (Bu() || jm() || "connection" in navigator) ? navigator.onLine : !0;
}
function hp() {
  if (typeof navigator > "u")
    return null;
  const e = navigator;
  return (
    // Most reliable, but only supported in Chrome/Firefox.
    e.languages && e.languages[0] || // Supported in most browsers, but returns the language of the browser
    // UI, not the language set in browser settings.
    e.language || // Couldn't determine language.
    null
  );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fr {
  constructor(t, n) {
    this.shortDelay = t, this.longDelay = n, kt(n > t, "Short delay should be less than long delay!"), this.isMobile = Hm() || Wm();
  }
  get() {
    return fp() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Wo(e, t) {
  kt(e.emulator, "Emulator should always be set here");
  const { url: n } = e.emulator;
  return t ? `${n}${t.startsWith("/") ? t.slice(1) : t}` : n;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fu {
  static initialize(t, n, r) {
    this.fetchImpl = t, n && (this.headersImpl = n), r && (this.responseImpl = r);
  }
  static fetch() {
    if (this.fetchImpl)
      return this.fetchImpl;
    if (typeof self < "u" && "fetch" in self)
      return self.fetch;
    bt("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static headers() {
    if (this.headersImpl)
      return this.headersImpl;
    if (typeof self < "u" && "Headers" in self)
      return self.Headers;
    bt("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static response() {
    if (this.responseImpl)
      return this.responseImpl;
    if (typeof self < "u" && "Response" in self)
      return self.Response;
    bt("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vp = {
  // Custom token errors.
  CREDENTIAL_MISMATCH: "custom-token-mismatch",
  // This can only happen if the SDK sends a bad request.
  MISSING_CUSTOM_TOKEN: "internal-error",
  // Create Auth URI errors.
  INVALID_IDENTIFIER: "invalid-email",
  // This can only happen if the SDK sends a bad request.
  MISSING_CONTINUE_URI: "internal-error",
  // Sign in with email and password errors (some apply to sign up too).
  INVALID_PASSWORD: "wrong-password",
  // This can only happen if the SDK sends a bad request.
  MISSING_PASSWORD: "missing-password",
  // Sign up with email and password errors.
  EMAIL_EXISTS: "email-already-in-use",
  PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
  // Verify assertion for sign in with credential errors:
  INVALID_IDP_RESPONSE: "invalid-credential",
  INVALID_PENDING_TOKEN: "invalid-credential",
  FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
  // This can only happen if the SDK sends a bad request.
  MISSING_REQ_TYPE: "internal-error",
  // Send Password reset email errors:
  EMAIL_NOT_FOUND: "user-not-found",
  RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
  EXPIRED_OOB_CODE: "expired-action-code",
  INVALID_OOB_CODE: "invalid-action-code",
  // This can only happen if the SDK sends a bad request.
  MISSING_OOB_CODE: "internal-error",
  // Operations that require ID token in request:
  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
  INVALID_ID_TOKEN: "invalid-user-token",
  TOKEN_EXPIRED: "user-token-expired",
  USER_NOT_FOUND: "user-token-expired",
  // Other errors.
  TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
  // Phone Auth related errors.
  INVALID_CODE: "invalid-verification-code",
  INVALID_SESSION_INFO: "invalid-verification-id",
  INVALID_TEMPORARY_PROOF: "invalid-credential",
  MISSING_SESSION_INFO: "missing-verification-id",
  SESSION_EXPIRED: "code-expired",
  // Other action code errors when additional settings passed.
  // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.
  // This is OK as this error will be caught by client side validation.
  MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
  UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
  // getProjectConfig errors when clientId is passed.
  INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
  // User actions (sign-up or deletion) disabled errors.
  ADMIN_ONLY_OPERATION: "admin-restricted-operation",
  // Multi factor related errors.
  INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
  MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
  MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
  MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
  SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
  SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
  // Blocking functions related errors.
  BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error"
  /* AuthErrorCode.INTERNAL_ERROR */
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mp = new Fr(3e4, 6e4);
function Ye(e, t) {
  return e.tenantId && !t.tenantId ? Object.assign(Object.assign({}, t), { tenantId: e.tenantId }) : t;
}
async function at(e, t, n, r, i = {}) {
  return Uu(e, i, async () => {
    let s = {}, o = {};
    r && (t === "GET" ? o = r : s = {
      body: JSON.stringify(r)
    });
    const a = Kn(Object.assign({ key: e.config.apiKey }, o)).slice(1), l = await e._getAdditionalHeaders();
    return l[
      "Content-Type"
      /* HttpHeader.CONTENT_TYPE */
    ] = "application/json", e.languageCode && (l[
      "X-Firebase-Locale"
      /* HttpHeader.X_FIREBASE_LOCALE */
    ] = e.languageCode), Fu.fetch()(Hu(e, e.config.apiHost, n, a), Object.assign({
      method: t,
      headers: l,
      referrerPolicy: "no-referrer"
    }, s));
  });
}
async function Uu(e, t, n) {
  e._canInitEmulator = !1;
  const r = Object.assign(Object.assign({}, vp), t);
  try {
    const i = new gp(e), s = await Promise.race([
      n(),
      i.promise
    ]);
    i.clearNetworkTimeout();
    const o = await s.json();
    if ("needConfirmation" in o)
      throw lr(e, "account-exists-with-different-credential", o);
    if (s.ok && !("errorMessage" in o))
      return o;
    {
      const a = s.ok ? o.errorMessage : o.error.message, [l, c] = a.split(" : ");
      if (l === "FEDERATED_USER_ID_ALREADY_LINKED")
        throw lr(e, "credential-already-in-use", o);
      if (l === "EMAIL_EXISTS")
        throw lr(e, "email-already-in-use", o);
      if (l === "USER_DISABLED")
        throw lr(e, "user-disabled", o);
      const d = r[l] || l.toLowerCase().replace(/[_\s]+/g, "-");
      if (c)
        throw Mu(e, d, c);
      Ke(e, d);
    }
  } catch (i) {
    if (i instanceof Jt)
      throw i;
    Ke(e, "network-request-failed", { message: String(i) });
  }
}
async function Yt(e, t, n, r, i = {}) {
  const s = await at(e, t, n, r, i);
  return "mfaPendingCredential" in s && Ke(e, "multi-factor-auth-required", {
    _serverResponse: s
  }), s;
}
function Hu(e, t, n, r) {
  const i = `${t}${n}?${r}`;
  return e.config.emulator ? Wo(e.config, i) : `${e.config.apiScheme}://${i}`;
}
class gp {
  constructor(t) {
    this.auth = t, this.timer = null, this.promise = new Promise((n, r) => {
      this.timer = setTimeout(() => r(Me(
        this.auth,
        "network-request-failed"
        /* AuthErrorCode.NETWORK_REQUEST_FAILED */
      )), mp.get());
    });
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer);
  }
}
function lr(e, t, n) {
  const r = {
    appName: e.name
  };
  n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber);
  const i = Me(e, t, r);
  return i.customData._tokenResponse = n, i;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function pp(e, t) {
  return at(e, "POST", "/v1/accounts:delete", t);
}
async function yp(e, t) {
  return at(e, "POST", "/v1/accounts:lookup", t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function vr(e) {
  if (e)
    try {
      const t = new Date(Number(e));
      if (!isNaN(t.getTime()))
        return t.toUTCString();
    } catch {
    }
}
async function _p(e, t = !1) {
  const n = Fe(e), r = await n.getIdToken(t), i = zo(r);
  L(
    i && i.exp && i.auth_time && i.iat,
    n.auth,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  const s = typeof i.firebase == "object" ? i.firebase : void 0, o = s == null ? void 0 : s.sign_in_provider;
  return {
    claims: i,
    token: r,
    authTime: vr(Is(i.auth_time)),
    issuedAtTime: vr(Is(i.iat)),
    expirationTime: vr(Is(i.exp)),
    signInProvider: o || null,
    signInSecondFactor: (s == null ? void 0 : s.sign_in_second_factor) || null
  };
}
function Is(e) {
  return Number(e) * 1e3;
}
function zo(e) {
  const [t, n, r] = e.split(".");
  if (t === void 0 || n === void 0 || r === void 0)
    return mi("JWT malformed, contained fewer than 3 sections"), null;
  try {
    const i = Ou(n);
    return i ? JSON.parse(i) : (mi("Failed to decode base64 JWT payload"), null);
  } catch (i) {
    return mi("Caught error parsing JWT payload as JSON", i == null ? void 0 : i.toString()), null;
  }
}
function bp(e) {
  const t = zo(e);
  return L(
    t,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), L(
    typeof t.exp < "u",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), L(
    typeof t.iat < "u",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), Number(t.exp) - Number(t.iat);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Wn(e, t, n = !1) {
  if (n)
    return t;
  try {
    return await t;
  } catch (r) {
    throw r instanceof Jt && wp(r) && e.auth.currentUser === e && await e.auth.signOut(), r;
  }
}
function wp({ code: e }) {
  return e === "auth/user-disabled" || e === "auth/user-token-expired";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sp {
  constructor(t) {
    this.user = t, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4;
  }
  _start() {
    this.isRunning || (this.isRunning = !0, this.schedule());
  }
  _stop() {
    this.isRunning && (this.isRunning = !1, this.timerId !== null && clearTimeout(this.timerId));
  }
  getInterval(t) {
    var n;
    if (t) {
      const r = this.errorBackoff;
      return this.errorBackoff = Math.min(
        this.errorBackoff * 2,
        96e4
        /* Duration.RETRY_BACKOFF_MAX */
      ), r;
    } else {
      this.errorBackoff = 3e4;
      const i = ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) - Date.now() - 3e5;
      return Math.max(0, i);
    }
  }
  schedule(t = !1) {
    if (!this.isRunning)
      return;
    const n = this.getInterval(t);
    this.timerId = setTimeout(async () => {
      await this.iteration();
    }, n);
  }
  async iteration() {
    try {
      await this.user.getIdToken(!0);
    } catch (t) {
      (t == null ? void 0 : t.code) === "auth/network-request-failed" && this.schedule(
        /* wasError */
        !0
      );
      return;
    }
    this.schedule();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ju {
  constructor(t, n) {
    this.createdAt = t, this.lastLoginAt = n, this._initializeTime();
  }
  _initializeTime() {
    this.lastSignInTime = vr(this.lastLoginAt), this.creationTime = vr(this.createdAt);
  }
  _copy(t) {
    this.createdAt = t.createdAt, this.lastLoginAt = t.lastLoginAt, this._initializeTime();
  }
  toJSON() {
    return {
      createdAt: this.createdAt,
      lastLoginAt: this.lastLoginAt
    };
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function xi(e) {
  var t;
  const n = e.auth, r = await e.getIdToken(), i = await Wn(e, yp(n, { idToken: r }));
  L(
    i == null ? void 0 : i.users.length,
    n,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  const s = i.users[0];
  e._notifyReloadListener(s);
  const o = !((t = s.providerUserInfo) === null || t === void 0) && t.length ? Cp(s.providerUserInfo) : [], a = Ip(e.providerData, o), l = e.isAnonymous, c = !(e.email && s.passwordHash) && !(a != null && a.length), d = l ? c : !1, u = {
    uid: s.localId,
    displayName: s.displayName || null,
    photoURL: s.photoUrl || null,
    email: s.email || null,
    emailVerified: s.emailVerified || !1,
    phoneNumber: s.phoneNumber || null,
    tenantId: s.tenantId || null,
    providerData: a,
    metadata: new ju(s.createdAt, s.lastLoginAt),
    isAnonymous: d
  };
  Object.assign(e, u);
}
async function Ep(e) {
  const t = Fe(e);
  await xi(t), await t.auth._persistUserIfCurrent(t), t.auth._notifyListenersIfCurrent(t);
}
function Ip(e, t) {
  return [...e.filter((r) => !t.some((i) => i.providerId === r.providerId)), ...t];
}
function Cp(e) {
  return e.map((t) => {
    var { providerId: n } = t, r = Ho(t, ["providerId"]);
    return {
      providerId: n,
      uid: r.rawId || "",
      displayName: r.displayName || null,
      email: r.email || null,
      phoneNumber: r.phoneNumber || null,
      photoURL: r.photoUrl || null
    };
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function kp(e, t) {
  const n = await Uu(e, {}, async () => {
    const r = Kn({
      grant_type: "refresh_token",
      refresh_token: t
    }).slice(1), { tokenApiHost: i, apiKey: s } = e.config, o = Hu(e, i, "/v1/token", `key=${s}`), a = await e._getAdditionalHeaders();
    return a[
      "Content-Type"
      /* HttpHeader.CONTENT_TYPE */
    ] = "application/x-www-form-urlencoded", Fu.fetch()(o, {
      method: "POST",
      headers: a,
      body: r
    });
  });
  return {
    accessToken: n.access_token,
    expiresIn: n.expires_in,
    refreshToken: n.refresh_token
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ar {
  constructor() {
    this.refreshToken = null, this.accessToken = null, this.expirationTime = null;
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
  }
  updateFromServerResponse(t) {
    L(
      t.idToken,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), L(
      typeof t.idToken < "u",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), L(
      typeof t.refreshToken < "u",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const n = "expiresIn" in t && typeof t.expiresIn < "u" ? Number(t.expiresIn) : bp(t.idToken);
    this.updateTokensAndExpiration(t.idToken, t.refreshToken, n);
  }
  async getToken(t, n = !1) {
    return L(
      !this.accessToken || this.refreshToken,
      t,
      "user-token-expired"
      /* AuthErrorCode.TOKEN_EXPIRED */
    ), !n && this.accessToken && !this.isExpired ? this.accessToken : this.refreshToken ? (await this.refresh(t, this.refreshToken), this.accessToken) : null;
  }
  clearRefreshToken() {
    this.refreshToken = null;
  }
  async refresh(t, n) {
    const { accessToken: r, refreshToken: i, expiresIn: s } = await kp(t, n);
    this.updateTokensAndExpiration(r, i, Number(s));
  }
  updateTokensAndExpiration(t, n, r) {
    this.refreshToken = n || null, this.accessToken = t || null, this.expirationTime = Date.now() + r * 1e3;
  }
  static fromJSON(t, n) {
    const { refreshToken: r, accessToken: i, expirationTime: s } = n, o = new Ar();
    return r && (L(typeof r == "string", "internal-error", {
      appName: t
    }), o.refreshToken = r), i && (L(typeof i == "string", "internal-error", {
      appName: t
    }), o.accessToken = i), s && (L(typeof s == "number", "internal-error", {
      appName: t
    }), o.expirationTime = s), o;
  }
  toJSON() {
    return {
      refreshToken: this.refreshToken,
      accessToken: this.accessToken,
      expirationTime: this.expirationTime
    };
  }
  _assign(t) {
    this.accessToken = t.accessToken, this.refreshToken = t.refreshToken, this.expirationTime = t.expirationTime;
  }
  _clone() {
    return Object.assign(new Ar(), this.toJSON());
  }
  _performRefresh() {
    return bt("not implemented");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Pt(e, t) {
  L(typeof e == "string" || typeof e > "u", "internal-error", { appName: t });
}
class vn {
  constructor(t) {
    var { uid: n, auth: r, stsTokenManager: i } = t, s = Ho(t, ["uid", "auth", "stsTokenManager"]);
    this.providerId = "firebase", this.proactiveRefresh = new Sp(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = n, this.auth = r, this.stsTokenManager = i, this.accessToken = i.accessToken, this.displayName = s.displayName || null, this.email = s.email || null, this.emailVerified = s.emailVerified || !1, this.phoneNumber = s.phoneNumber || null, this.photoURL = s.photoURL || null, this.isAnonymous = s.isAnonymous || !1, this.tenantId = s.tenantId || null, this.providerData = s.providerData ? [...s.providerData] : [], this.metadata = new ju(s.createdAt || void 0, s.lastLoginAt || void 0);
  }
  async getIdToken(t) {
    const n = await Wn(this, this.stsTokenManager.getToken(this.auth, t));
    return L(
      n,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.accessToken !== n && (this.accessToken = n, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), n;
  }
  getIdTokenResult(t) {
    return _p(this, t);
  }
  reload() {
    return Ep(this);
  }
  _assign(t) {
    this !== t && (L(
      this.uid === t.uid,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.displayName = t.displayName, this.photoURL = t.photoURL, this.email = t.email, this.emailVerified = t.emailVerified, this.phoneNumber = t.phoneNumber, this.isAnonymous = t.isAnonymous, this.tenantId = t.tenantId, this.providerData = t.providerData.map((n) => Object.assign({}, n)), this.metadata._copy(t.metadata), this.stsTokenManager._assign(t.stsTokenManager));
  }
  _clone(t) {
    const n = new vn(Object.assign(Object.assign({}, this), { auth: t, stsTokenManager: this.stsTokenManager._clone() }));
    return n.metadata._copy(this.metadata), n;
  }
  _onReload(t) {
    L(
      !this.reloadListener,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.reloadListener = t, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null);
  }
  _notifyReloadListener(t) {
    this.reloadListener ? this.reloadListener(t) : this.reloadUserInfo = t;
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start();
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop();
  }
  async _updateTokensIfNecessary(t, n = !1) {
    let r = !1;
    t.idToken && t.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(t), r = !0), n && await xi(this), await this.auth._persistUserIfCurrent(this), r && this.auth._notifyListenersIfCurrent(this);
  }
  async delete() {
    const t = await this.getIdToken();
    return await Wn(this, pp(this.auth, { idToken: t })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut();
  }
  toJSON() {
    return Object.assign(Object.assign({
      uid: this.uid,
      email: this.email || void 0,
      emailVerified: this.emailVerified,
      displayName: this.displayName || void 0,
      isAnonymous: this.isAnonymous,
      photoURL: this.photoURL || void 0,
      phoneNumber: this.phoneNumber || void 0,
      tenantId: this.tenantId || void 0,
      providerData: this.providerData.map((t) => Object.assign({}, t)),
      stsTokenManager: this.stsTokenManager.toJSON(),
      // Redirect event ID must be maintained in case there is a pending
      // redirect event.
      _redirectEventId: this._redirectEventId
    }, this.metadata.toJSON()), {
      // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
      apiKey: this.auth.config.apiKey,
      appName: this.auth.name
    });
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || "";
  }
  static _fromJSON(t, n) {
    var r, i, s, o, a, l, c, d;
    const u = (r = n.displayName) !== null && r !== void 0 ? r : void 0, f = (i = n.email) !== null && i !== void 0 ? i : void 0, h = (s = n.phoneNumber) !== null && s !== void 0 ? s : void 0, m = (o = n.photoURL) !== null && o !== void 0 ? o : void 0, g = (a = n.tenantId) !== null && a !== void 0 ? a : void 0, w = (l = n._redirectEventId) !== null && l !== void 0 ? l : void 0, C = (c = n.createdAt) !== null && c !== void 0 ? c : void 0, E = (d = n.lastLoginAt) !== null && d !== void 0 ? d : void 0, { uid: p, emailVerified: O, isAnonymous: A, providerData: N, stsTokenManager: I } = n;
    L(
      p && I,
      t,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const _ = Ar.fromJSON(this.name, I);
    L(
      typeof p == "string",
      t,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), Pt(u, t.name), Pt(f, t.name), L(
      typeof O == "boolean",
      t,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), L(
      typeof A == "boolean",
      t,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), Pt(h, t.name), Pt(m, t.name), Pt(g, t.name), Pt(w, t.name), Pt(C, t.name), Pt(E, t.name);
    const b = new vn({
      uid: p,
      auth: t,
      email: f,
      emailVerified: O,
      displayName: u,
      isAnonymous: A,
      photoURL: m,
      phoneNumber: h,
      tenantId: g,
      stsTokenManager: _,
      createdAt: C,
      lastLoginAt: E
    });
    return N && Array.isArray(N) && (b.providerData = N.map((S) => Object.assign({}, S))), w && (b._redirectEventId = w), b;
  }
  /**
   * Initialize a User from an idToken server response
   * @param auth
   * @param idTokenResponse
   */
  static async _fromIdTokenResponse(t, n, r = !1) {
    const i = new Ar();
    i.updateFromServerResponse(n);
    const s = new vn({
      uid: n.localId,
      auth: t,
      stsTokenManager: i,
      isAnonymous: r
    });
    return await xi(s), s;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Wu {
  constructor() {
    this.type = "NONE", this.storage = {};
  }
  async _isAvailable() {
    return !0;
  }
  async _set(t, n) {
    this.storage[t] = n;
  }
  async _get(t) {
    const n = this.storage[t];
    return n === void 0 ? null : n;
  }
  async _remove(t) {
    delete this.storage[t];
  }
  _addListener(t, n) {
  }
  _removeListener(t, n) {
  }
}
Wu.type = "NONE";
const dl = Wu;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function gi(e, t, n) {
  return `firebase:${e}:${t}:${n}`;
}
class Fn {
  constructor(t, n, r) {
    this.persistence = t, this.auth = n, this.userKey = r;
    const { config: i, name: s } = this.auth;
    this.fullUserKey = gi(this.userKey, i.apiKey, s), this.fullPersistenceKey = gi("persistence", i.apiKey, s), this.boundEventHandler = n._onStorageEvent.bind(n), this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
  }
  setCurrentUser(t) {
    return this.persistence._set(this.fullUserKey, t.toJSON());
  }
  async getCurrentUser() {
    const t = await this.persistence._get(this.fullUserKey);
    return t ? vn._fromJSON(this.auth, t) : null;
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey);
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
  }
  async setPersistence(t) {
    if (this.persistence === t)
      return;
    const n = await this.getCurrentUser();
    if (await this.removeCurrentUser(), this.persistence = t, n)
      return this.setCurrentUser(n);
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
  }
  static async create(t, n, r = "authUser") {
    if (!n.length)
      return new Fn(wt(dl), t, r);
    const i = (await Promise.all(n.map(async (c) => {
      if (await c._isAvailable())
        return c;
    }))).filter((c) => c);
    let s = i[0] || wt(dl);
    const o = gi(r, t.config.apiKey, t.name);
    let a = null;
    for (const c of n)
      try {
        const d = await c._get(o);
        if (d) {
          const u = vn._fromJSON(t, d);
          c !== s && (a = u), s = c;
          break;
        }
      } catch {
      }
    const l = i.filter((c) => c._shouldAllowMigration);
    return !s._shouldAllowMigration || !l.length ? new Fn(s, t, r) : (s = l[0], a && await s._set(o, a.toJSON()), await Promise.all(n.map(async (c) => {
      if (c !== s)
        try {
          await c._remove(o);
        } catch {
        }
    })), new Fn(s, t, r));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fl(e) {
  const t = e.toLowerCase();
  if (t.includes("opera/") || t.includes("opr/") || t.includes("opios/"))
    return "Opera";
  if (qu(t))
    return "IEMobile";
  if (t.includes("msie") || t.includes("trident/"))
    return "IE";
  if (t.includes("edge/"))
    return "Edge";
  if (zu(t))
    return "Firefox";
  if (t.includes("silk/"))
    return "Silk";
  if (Ju(t))
    return "Blackberry";
  if (Yu(t))
    return "Webos";
  if (Go(t))
    return "Safari";
  if ((t.includes("chrome/") || Gu(t)) && !t.includes("edge/"))
    return "Chrome";
  if (Ku(t))
    return "Android";
  {
    const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/, r = e.match(n);
    if ((r == null ? void 0 : r.length) === 2)
      return r[1];
  }
  return "Other";
}
function zu(e = Ee()) {
  return /firefox\//i.test(e);
}
function Go(e = Ee()) {
  const t = e.toLowerCase();
  return t.includes("safari/") && !t.includes("chrome/") && !t.includes("crios/") && !t.includes("android");
}
function Gu(e = Ee()) {
  return /crios\//i.test(e);
}
function qu(e = Ee()) {
  return /iemobile/i.test(e);
}
function Ku(e = Ee()) {
  return /android/i.test(e);
}
function Ju(e = Ee()) {
  return /blackberry/i.test(e);
}
function Yu(e = Ee()) {
  return /webos/i.test(e);
}
function Xi(e = Ee()) {
  return /iphone|ipad|ipod/i.test(e) || /macintosh/i.test(e) && /mobile/i.test(e);
}
function Tp(e = Ee()) {
  var t;
  return Xi(e) && !!(!((t = window.navigator) === null || t === void 0) && t.standalone);
}
function Op() {
  return zm() && document.documentMode === 10;
}
function Xu(e = Ee()) {
  return Xi(e) || Ku(e) || Yu(e) || Ju(e) || /windows phone/i.test(e) || qu(e);
}
function Ap() {
  try {
    return !!(window && window !== window.top);
  } catch {
    return !1;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Qu(e, t = []) {
  let n;
  switch (e) {
    case "Browser":
      n = fl(Ee());
      break;
    case "Worker":
      n = `${fl(Ee())}-${e}`;
      break;
    default:
      n = e;
  }
  const r = t.length ? t.join(",") : "FirebaseCore-web";
  return `${n}/JsCore/${Yi}/${r}`;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Np {
  constructor(t) {
    this.auth = t, this.queue = [];
  }
  pushCallback(t, n) {
    const r = (s) => new Promise((o, a) => {
      try {
        const l = t(s);
        o(l);
      } catch (l) {
        a(l);
      }
    });
    r.onAbort = n, this.queue.push(r);
    const i = this.queue.length - 1;
    return () => {
      this.queue[i] = () => Promise.resolve();
    };
  }
  async runMiddleware(t) {
    if (this.auth.currentUser === t)
      return;
    const n = [];
    try {
      for (const r of this.queue)
        await r(t), r.onAbort && n.push(r.onAbort);
    } catch (r) {
      n.reverse();
      for (const i of n)
        try {
          i();
        } catch {
        }
      throw this.auth._errorFactory.create("login-blocked", {
        originalMessage: r == null ? void 0 : r.message
      });
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pp {
  constructor(t, n, r) {
    this.app = t, this.heartbeatServiceProvider = n, this.config = r, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new hl(this), this.idTokenSubscription = new hl(this), this.beforeStateQueue = new Np(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = $u, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = t.name, this.clientVersion = r.sdkClientVersion;
  }
  _initializeWithPersistence(t, n) {
    return n && (this._popupRedirectResolver = wt(n)), this._initializationPromise = this.queue(async () => {
      var r, i;
      if (!this._deleted && (this.persistenceManager = await Fn.create(this, t), !this._deleted)) {
        if (!((r = this._popupRedirectResolver) === null || r === void 0) && r._shouldInitProactively)
          try {
            await this._popupRedirectResolver._initialize(this);
          } catch {
          }
        await this.initializeCurrentUser(n), this.lastNotifiedUid = ((i = this.currentUser) === null || i === void 0 ? void 0 : i.uid) || null, !this._deleted && (this._isInitialized = !0);
      }
    }), this._initializationPromise;
  }
  /**
   * If the persistence is changed in another window, the user manager will let us know
   */
  async _onStorageEvent() {
    if (this._deleted)
      return;
    const t = await this.assertedPersistence.getCurrentUser();
    if (!(!this.currentUser && !t)) {
      if (this.currentUser && t && this.currentUser.uid === t.uid) {
        this._currentUser._assign(t), await this.currentUser.getIdToken();
        return;
      }
      await this._updateCurrentUser(
        t,
        /* skipBeforeStateCallbacks */
        !0
      );
    }
  }
  async initializeCurrentUser(t) {
    var n;
    const r = await this.assertedPersistence.getCurrentUser();
    let i = r, s = !1;
    if (t && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager();
      const o = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId, a = i == null ? void 0 : i._redirectEventId, l = await this.tryRedirectSignIn(t);
      (!o || o === a) && (l != null && l.user) && (i = l.user, s = !0);
    }
    if (!i)
      return this.directlySetCurrentUser(null);
    if (!i._redirectEventId) {
      if (s)
        try {
          await this.beforeStateQueue.runMiddleware(i);
        } catch (o) {
          i = r, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o));
        }
      return i ? this.reloadAndSetCurrentUserOrClear(i) : this.directlySetCurrentUser(null);
    }
    return L(
      this._popupRedirectResolver,
      this,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === i._redirectEventId ? this.directlySetCurrentUser(i) : this.reloadAndSetCurrentUserOrClear(i);
  }
  async tryRedirectSignIn(t) {
    let n = null;
    try {
      n = await this._popupRedirectResolver._completeRedirectFn(this, t, !0);
    } catch {
      await this._setRedirectUser(null);
    }
    return n;
  }
  async reloadAndSetCurrentUserOrClear(t) {
    try {
      await xi(t);
    } catch (n) {
      if ((n == null ? void 0 : n.code) !== "auth/network-request-failed")
        return this.directlySetCurrentUser(null);
    }
    return this.directlySetCurrentUser(t);
  }
  useDeviceLanguage() {
    this.languageCode = hp();
  }
  async _delete() {
    this._deleted = !0;
  }
  async updateCurrentUser(t) {
    const n = t ? Fe(t) : null;
    return n && L(
      n.auth.config.apiKey === this.config.apiKey,
      this,
      "invalid-user-token"
      /* AuthErrorCode.INVALID_AUTH */
    ), this._updateCurrentUser(n && n._clone(this));
  }
  async _updateCurrentUser(t, n = !1) {
    if (!this._deleted)
      return t && L(
        this.tenantId === t.tenantId,
        this,
        "tenant-id-mismatch"
        /* AuthErrorCode.TENANT_ID_MISMATCH */
      ), n || await this.beforeStateQueue.runMiddleware(t), this.queue(async () => {
        await this.directlySetCurrentUser(t), this.notifyAuthListeners();
      });
  }
  async signOut() {
    return await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(
      null,
      /* skipBeforeStateCallbacks */
      !0
    );
  }
  setPersistence(t) {
    return this.queue(async () => {
      await this.assertedPersistence.setPersistence(wt(t));
    });
  }
  _getPersistence() {
    return this.assertedPersistence.persistence.type;
  }
  _updateErrorMap(t) {
    this._errorFactory = new Br("auth", "Firebase", t());
  }
  onAuthStateChanged(t, n, r) {
    return this.registerStateListener(this.authStateSubscription, t, n, r);
  }
  beforeAuthStateChanged(t, n) {
    return this.beforeStateQueue.pushCallback(t, n);
  }
  onIdTokenChanged(t, n, r) {
    return this.registerStateListener(this.idTokenSubscription, t, n, r);
  }
  toJSON() {
    var t;
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (t = this._currentUser) === null || t === void 0 ? void 0 : t.toJSON()
    };
  }
  async _setRedirectUser(t, n) {
    const r = await this.getOrInitRedirectPersistenceManager(n);
    return t === null ? r.removeCurrentUser() : r.setCurrentUser(t);
  }
  async getOrInitRedirectPersistenceManager(t) {
    if (!this.redirectPersistenceManager) {
      const n = t && wt(t) || this._popupRedirectResolver;
      L(
        n,
        this,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      ), this.redirectPersistenceManager = await Fn.create(
        this,
        [wt(n._redirectPersistence)],
        "redirectUser"
        /* KeyName.REDIRECT_USER */
      ), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
    }
    return this.redirectPersistenceManager;
  }
  async _redirectUserForId(t) {
    var n, r;
    return this._isInitialized && await this.queue(async () => {
    }), ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === t ? this._currentUser : ((r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId) === t ? this.redirectUser : null;
  }
  async _persistUserIfCurrent(t) {
    if (t === this.currentUser)
      return this.queue(async () => this.directlySetCurrentUser(t));
  }
  /** Notifies listeners only if the user is current */
  _notifyListenersIfCurrent(t) {
    t === this.currentUser && this.notifyAuthListeners();
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
  }
  _startProactiveRefresh() {
    this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh();
  }
  _stopProactiveRefresh() {
    this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh();
  }
  /** Returns the current user cast as the internal type */
  get _currentUser() {
    return this.currentUser;
  }
  notifyAuthListeners() {
    var t, n;
    if (!this._isInitialized)
      return;
    this.idTokenSubscription.next(this.currentUser);
    const r = (n = (t = this.currentUser) === null || t === void 0 ? void 0 : t.uid) !== null && n !== void 0 ? n : null;
    this.lastNotifiedUid !== r && (this.lastNotifiedUid = r, this.authStateSubscription.next(this.currentUser));
  }
  registerStateListener(t, n, r, i) {
    if (this._deleted)
      return () => {
      };
    const s = typeof n == "function" ? n : n.next.bind(n), o = this._isInitialized ? Promise.resolve() : this._initializationPromise;
    return L(
      o,
      this,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), o.then(() => s(this.currentUser)), typeof n == "function" ? t.addObserver(n, r, i) : t.addObserver(n);
  }
  /**
   * Unprotected (from race conditions) method to set the current user. This
   * should only be called from within a queued callback. This is necessary
   * because the queue shouldn't rely on another queued callback.
   */
  async directlySetCurrentUser(t) {
    this.currentUser && this.currentUser !== t && this._currentUser._stopProactiveRefresh(), t && this.isProactiveRefreshEnabled && t._startProactiveRefresh(), this.currentUser = t, t ? await this.assertedPersistence.setCurrentUser(t) : await this.assertedPersistence.removeCurrentUser();
  }
  queue(t) {
    return this.operations = this.operations.then(t, t), this.operations;
  }
  get assertedPersistence() {
    return L(
      this.persistenceManager,
      this,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.persistenceManager;
  }
  _logFramework(t) {
    !t || this.frameworks.includes(t) || (this.frameworks.push(t), this.frameworks.sort(), this.clientVersion = Qu(this.config.clientPlatform, this._getFrameworks()));
  }
  _getFrameworks() {
    return this.frameworks;
  }
  async _getAdditionalHeaders() {
    var t;
    const n = {
      [
        "X-Client-Version"
        /* HttpHeader.X_CLIENT_VERSION */
      ]: this.clientVersion
    };
    this.app.options.appId && (n[
      "X-Firebase-gmpid"
      /* HttpHeader.X_FIREBASE_GMPID */
    ] = this.app.options.appId);
    const r = await ((t = this.heartbeatServiceProvider.getImmediate({
      optional: !0
    })) === null || t === void 0 ? void 0 : t.getHeartbeatsHeader());
    return r && (n[
      "X-Firebase-Client"
      /* HttpHeader.X_FIREBASE_CLIENT */
    ] = r), n;
  }
}
function Xt(e) {
  return Fe(e);
}
class hl {
  constructor(t) {
    this.auth = t, this.observer = null, this.addObserver = Qm((n) => this.observer = n);
  }
  get next() {
    return L(
      this.observer,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.observer.next.bind(this.observer);
  }
}
function Rp(e, t, n) {
  const r = Xt(e);
  L(
    r._canInitEmulator,
    r,
    "emulator-config-failed"
    /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
  ), L(
    /^https?:\/\//.test(t),
    r,
    "invalid-emulator-scheme"
    /* AuthErrorCode.INVALID_EMULATOR_SCHEME */
  );
  const i = !!(n != null && n.disableWarnings), s = Zu(t), { host: o, port: a } = xp(t), l = a === null ? "" : `:${a}`;
  r.config.emulator = { url: `${s}//${o}${l}/` }, r.settings.appVerificationDisabledForTesting = !0, r.emulatorConfig = Object.freeze({
    host: o,
    port: a,
    protocol: s.replace(":", ""),
    options: Object.freeze({ disableWarnings: i })
  }), i || Vp();
}
function Zu(e) {
  const t = e.indexOf(":");
  return t < 0 ? "" : e.substr(0, t + 1);
}
function xp(e) {
  const t = Zu(e), n = /(\/\/)?([^?#/]+)/.exec(e.substr(t.length));
  if (!n)
    return { host: "", port: null };
  const r = n[2].split("@").pop() || "", i = /^(\[[^\]]+\])(:|$)/.exec(r);
  if (i) {
    const s = i[1];
    return { host: s, port: vl(r.substr(s.length + 1)) };
  } else {
    const [s, o] = r.split(":");
    return { host: s, port: vl(o) };
  }
}
function vl(e) {
  if (!e)
    return null;
  const t = Number(e);
  return isNaN(t) ? null : t;
}
function Vp() {
  function e() {
    const t = document.createElement("p"), n = t.style;
    t.innerText = "Running in emulator mode. Do not use with production credentials.", n.position = "fixed", n.width = "100%", n.backgroundColor = "#ffffff", n.border = ".1em solid #000000", n.color = "#b50000", n.bottom = "0px", n.left = "0px", n.margin = "0px", n.zIndex = "10000", n.textAlign = "center", t.classList.add("firebase-emulator-warning"), document.body.appendChild(t);
  }
  typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", e) : e());
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ur {
  /** @internal */
  constructor(t, n) {
    this.providerId = t, this.signInMethod = n;
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns a JSON-serializable representation of this object.
   */
  toJSON() {
    return bt("not implemented");
  }
  /** @internal */
  _getIdTokenResponse(t) {
    return bt("not implemented");
  }
  /** @internal */
  _linkToIdToken(t, n) {
    return bt("not implemented");
  }
  /** @internal */
  _getReauthenticationResolver(t) {
    return bt("not implemented");
  }
}
async function Dp(e, t) {
  return at(e, "POST", "/v1/accounts:update", t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Lp(e, t) {
  return Yt(e, "POST", "/v1/accounts:signInWithPassword", Ye(e, t));
}
async function ed(e, t) {
  return at(e, "POST", "/v1/accounts:sendOobCode", Ye(e, t));
}
async function $p(e, t) {
  return ed(e, t);
}
async function Mp(e, t) {
  return ed(e, t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Bp(e, t) {
  return Yt(e, "POST", "/v1/accounts:signInWithEmailLink", Ye(e, t));
}
async function Fp(e, t) {
  return Yt(e, "POST", "/v1/accounts:signInWithEmailLink", Ye(e, t));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Nr extends Ur {
  /** @internal */
  constructor(t, n, r, i = null) {
    super("password", r), this._email = t, this._password = n, this._tenantId = i;
  }
  /** @internal */
  static _fromEmailAndPassword(t, n) {
    return new Nr(
      t,
      n,
      "password"
      /* SignInMethod.EMAIL_PASSWORD */
    );
  }
  /** @internal */
  static _fromEmailAndCode(t, n, r = null) {
    return new Nr(t, n, "emailLink", r);
  }
  /** {@inheritdoc AuthCredential.toJSON} */
  toJSON() {
    return {
      email: this._email,
      password: this._password,
      signInMethod: this.signInMethod,
      tenantId: this._tenantId
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.
   *
   * @param json - Either `object` or the stringified representation of the object. When string is
   * provided, `JSON.parse` would be called first.
   *
   * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.
   */
  static fromJSON(t) {
    const n = typeof t == "string" ? JSON.parse(t) : t;
    if (n != null && n.email && (n != null && n.password)) {
      if (n.signInMethod === "password")
        return this._fromEmailAndPassword(n.email, n.password);
      if (n.signInMethod === "emailLink")
        return this._fromEmailAndCode(n.email, n.password, n.tenantId);
    }
    return null;
  }
  /** @internal */
  async _getIdTokenResponse(t) {
    switch (this.signInMethod) {
      case "password":
        return Lp(t, {
          returnSecureToken: !0,
          email: this._email,
          password: this._password
        });
      case "emailLink":
        return Bp(t, {
          email: this._email,
          oobCode: this._password
        });
      default:
        Ke(
          t,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  /** @internal */
  async _linkToIdToken(t, n) {
    switch (this.signInMethod) {
      case "password":
        return Dp(t, {
          idToken: n,
          returnSecureToken: !0,
          email: this._email,
          password: this._password
        });
      case "emailLink":
        return Fp(t, {
          idToken: n,
          email: this._email,
          oobCode: this._password
        });
      default:
        Ke(
          t,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  /** @internal */
  _getReauthenticationResolver(t) {
    return this._getIdTokenResponse(t);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function It(e, t) {
  return Yt(e, "POST", "/v1/accounts:signInWithIdp", Ye(e, t));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Up = "http://localhost";
class _n extends Ur {
  constructor() {
    super(...arguments), this.pendingToken = null;
  }
  /** @internal */
  static _fromParams(t) {
    const n = new _n(t.providerId, t.signInMethod);
    return t.idToken || t.accessToken ? (t.idToken && (n.idToken = t.idToken), t.accessToken && (n.accessToken = t.accessToken), t.nonce && !t.pendingToken && (n.nonce = t.nonce), t.pendingToken && (n.pendingToken = t.pendingToken)) : t.oauthToken && t.oauthTokenSecret ? (n.accessToken = t.oauthToken, n.secret = t.oauthTokenSecret) : Ke(
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), n;
  }
  /** {@inheritdoc AuthCredential.toJSON}  */
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an
   * {@link  AuthCredential}.
   *
   * @param json - Input can be either Object or the stringified representation of the object.
   * When string is provided, JSON.parse would be called first.
   *
   * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
   */
  static fromJSON(t) {
    const n = typeof t == "string" ? JSON.parse(t) : t, { providerId: r, signInMethod: i } = n, s = Ho(n, ["providerId", "signInMethod"]);
    if (!r || !i)
      return null;
    const o = new _n(r, i);
    return o.idToken = s.idToken || void 0, o.accessToken = s.accessToken || void 0, o.secret = s.secret, o.nonce = s.nonce, o.pendingToken = s.pendingToken || null, o;
  }
  /** @internal */
  _getIdTokenResponse(t) {
    const n = this.buildRequest();
    return It(t, n);
  }
  /** @internal */
  _linkToIdToken(t, n) {
    const r = this.buildRequest();
    return r.idToken = n, It(t, r);
  }
  /** @internal */
  _getReauthenticationResolver(t) {
    const n = this.buildRequest();
    return n.autoCreate = !1, It(t, n);
  }
  buildRequest() {
    const t = {
      requestUri: Up,
      returnSecureToken: !0
    };
    if (this.pendingToken)
      t.pendingToken = this.pendingToken;
    else {
      const n = {};
      this.idToken && (n.id_token = this.idToken), this.accessToken && (n.access_token = this.accessToken), this.secret && (n.oauth_token_secret = this.secret), n.providerId = this.providerId, this.nonce && !this.pendingToken && (n.nonce = this.nonce), t.postBody = Kn(n);
    }
    return t;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Hp(e, t) {
  return at(e, "POST", "/v1/accounts:sendVerificationCode", Ye(e, t));
}
async function jp(e, t) {
  return Yt(e, "POST", "/v1/accounts:signInWithPhoneNumber", Ye(e, t));
}
async function Wp(e, t) {
  const n = await Yt(e, "POST", "/v1/accounts:signInWithPhoneNumber", Ye(e, t));
  if (n.temporaryProof)
    throw lr(e, "account-exists-with-different-credential", n);
  return n;
}
const zp = {
  USER_NOT_FOUND: "user-not-found"
  /* AuthErrorCode.USER_DELETED */
};
async function Gp(e, t) {
  const n = Object.assign(Object.assign({}, t), { operation: "REAUTH" });
  return Yt(e, "POST", "/v1/accounts:signInWithPhoneNumber", Ye(e, n), zp);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mr extends Ur {
  constructor(t) {
    super(
      "phone",
      "phone"
      /* SignInMethod.PHONE */
    ), this.params = t;
  }
  /** @internal */
  static _fromVerification(t, n) {
    return new mr({ verificationId: t, verificationCode: n });
  }
  /** @internal */
  static _fromTokenResponse(t, n) {
    return new mr({ phoneNumber: t, temporaryProof: n });
  }
  /** @internal */
  _getIdTokenResponse(t) {
    return jp(t, this._makeVerificationRequest());
  }
  /** @internal */
  _linkToIdToken(t, n) {
    return Wp(t, Object.assign({ idToken: n }, this._makeVerificationRequest()));
  }
  /** @internal */
  _getReauthenticationResolver(t) {
    return Gp(t, this._makeVerificationRequest());
  }
  /** @internal */
  _makeVerificationRequest() {
    const { temporaryProof: t, phoneNumber: n, verificationId: r, verificationCode: i } = this.params;
    return t && n ? { temporaryProof: t, phoneNumber: n } : {
      sessionInfo: r,
      code: i
    };
  }
  /** {@inheritdoc AuthCredential.toJSON} */
  toJSON() {
    const t = {
      providerId: this.providerId
    };
    return this.params.phoneNumber && (t.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (t.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (t.verificationCode = this.params.verificationCode), this.params.verificationId && (t.verificationId = this.params.verificationId), t;
  }
  /** Generates a phone credential based on a plain object or a JSON string. */
  static fromJSON(t) {
    typeof t == "string" && (t = JSON.parse(t));
    const { verificationId: n, verificationCode: r, phoneNumber: i, temporaryProof: s } = t;
    return !r && !n && !i && !s ? null : new mr({
      verificationId: n,
      verificationCode: r,
      phoneNumber: i,
      temporaryProof: s
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qp(e) {
  switch (e) {
    case "recoverEmail":
      return "RECOVER_EMAIL";
    case "resetPassword":
      return "PASSWORD_RESET";
    case "signIn":
      return "EMAIL_SIGNIN";
    case "verifyEmail":
      return "VERIFY_EMAIL";
    case "verifyAndChangeEmail":
      return "VERIFY_AND_CHANGE_EMAIL";
    case "revertSecondFactorAddition":
      return "REVERT_SECOND_FACTOR_ADDITION";
    default:
      return null;
  }
}
function Kp(e) {
  const t = or(ar(e)).link, n = t ? or(ar(t)).deep_link_id : null, r = or(ar(e)).deep_link_id;
  return (r ? or(ar(r)).link : null) || r || n || t || e;
}
class qo {
  /**
   * @param actionLink - The link from which to extract the URL.
   * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
   *
   * @internal
   */
  constructor(t) {
    var n, r, i, s, o, a;
    const l = or(ar(t)), c = (n = l.apiKey) !== null && n !== void 0 ? n : null, d = (r = l.oobCode) !== null && r !== void 0 ? r : null, u = qp((i = l.mode) !== null && i !== void 0 ? i : null);
    L(
      c && d && u,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), this.apiKey = c, this.operation = u, this.code = d, this.continueUrl = (s = l.continueUrl) !== null && s !== void 0 ? s : null, this.languageCode = (o = l.languageCode) !== null && o !== void 0 ? o : null, this.tenantId = (a = l.tenantId) !== null && a !== void 0 ? a : null;
  }
  /**
   * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,
   * otherwise returns null.
   *
   * @param link  - The email action link string.
   * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
   *
   * @public
   */
  static parseLink(t) {
    const n = Kp(t);
    try {
      return new qo(n);
    } catch {
      return null;
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Jn {
  constructor() {
    this.providerId = Jn.PROVIDER_ID;
  }
  /**
   * Initialize an {@link AuthCredential} using an email and password.
   *
   * @example
   * ```javascript
   * const authCredential = EmailAuthProvider.credential(email, password);
   * const userCredential = await signInWithCredential(auth, authCredential);
   * ```
   *
   * @example
   * ```javascript
   * const userCredential = await signInWithEmailAndPassword(auth, email, password);
   * ```
   *
   * @param email - Email address.
   * @param password - User account password.
   * @returns The auth provider credential.
   */
  static credential(t, n) {
    return Nr._fromEmailAndPassword(t, n);
  }
  /**
   * Initialize an {@link AuthCredential} using an email and an email link after a sign in with
   * email link operation.
   *
   * @example
   * ```javascript
   * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);
   * const userCredential = await signInWithCredential(auth, authCredential);
   * ```
   *
   * @example
   * ```javascript
   * await sendSignInLinkToEmail(auth, email);
   * // Obtain emailLink from user.
   * const userCredential = await signInWithEmailLink(auth, email, emailLink);
   * ```
   *
   * @param auth - The {@link Auth} instance used to verify the link.
   * @param email - Email address.
   * @param emailLink - Sign-in email link.
   * @returns - The auth provider credential.
   */
  static credentialWithLink(t, n) {
    const r = qo.parseLink(n);
    return L(
      r,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), Nr._fromEmailAndCode(t, r.code, r.tenantId);
  }
}
Jn.PROVIDER_ID = "password";
Jn.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
Jn.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qi {
  /**
   * Constructor for generic OAuth providers.
   *
   * @param providerId - Provider for which credentials should be generated.
   */
  constructor(t) {
    this.providerId = t, this.defaultLanguageCode = null, this.customParameters = {};
  }
  /**
   * Set the language gode.
   *
   * @param languageCode - language code
   */
  setDefaultLanguage(t) {
    this.defaultLanguageCode = t;
  }
  /**
   * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in
   * operations.
   *
   * @remarks
   * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,
   * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.
   *
   * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.
   */
  setCustomParameters(t) {
    return this.customParameters = t, this;
  }
  /**
   * Retrieve the current list of {@link CustomParameters}.
   */
  getCustomParameters() {
    return this.customParameters;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Hr extends Qi {
  constructor() {
    super(...arguments), this.scopes = [];
  }
  /**
   * Add an OAuth scope to the credential.
   *
   * @param scope - Provider OAuth scope to add.
   */
  addScope(t) {
    return this.scopes.includes(t) || this.scopes.push(t), this;
  }
  /**
   * Retrieve the current list of OAuth scopes.
   */
  getScopes() {
    return [...this.scopes];
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yt extends Hr {
  constructor() {
    super(
      "facebook.com"
      /* ProviderId.FACEBOOK */
    );
  }
  /**
   * Creates a credential for Facebook.
   *
   * @example
   * ```javascript
   * // `event` from the Facebook auth.authResponseChange callback.
   * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param accessToken - Facebook access token.
   */
  static credential(t) {
    return _n._fromParams({
      providerId: yt.PROVIDER_ID,
      signInMethod: yt.FACEBOOK_SIGN_IN_METHOD,
      accessToken: t
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(t) {
    return yt.credentialFromTaggedObject(t);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(t) {
    return yt.credentialFromTaggedObject(t.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t || !("oauthAccessToken" in t) || !t.oauthAccessToken)
      return null;
    try {
      return yt.credential(t.oauthAccessToken);
    } catch {
      return null;
    }
  }
}
yt.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
yt.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _t extends Hr {
  constructor() {
    super(
      "google.com"
      /* ProviderId.GOOGLE */
    ), this.addScope("profile");
  }
  /**
   * Creates a credential for Google. At least one of ID token and access token is required.
   *
   * @example
   * ```javascript
   * // \`googleUser\` from the onsuccess Google Sign In callback.
   * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param idToken - Google ID token.
   * @param accessToken - Google access token.
   */
  static credential(t, n) {
    return _n._fromParams({
      providerId: _t.PROVIDER_ID,
      signInMethod: _t.GOOGLE_SIGN_IN_METHOD,
      idToken: t,
      accessToken: n
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(t) {
    return _t.credentialFromTaggedObject(t);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(t) {
    return _t.credentialFromTaggedObject(t.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t)
      return null;
    const { oauthIdToken: n, oauthAccessToken: r } = t;
    if (!n && !r)
      return null;
    try {
      return _t.credential(n, r);
    } catch {
      return null;
    }
  }
}
_t.GOOGLE_SIGN_IN_METHOD = "google.com";
_t.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dt extends Hr {
  constructor() {
    super(
      "github.com"
      /* ProviderId.GITHUB */
    );
  }
  /**
   * Creates a credential for Github.
   *
   * @param accessToken - Github access token.
   */
  static credential(t) {
    return _n._fromParams({
      providerId: Dt.PROVIDER_ID,
      signInMethod: Dt.GITHUB_SIGN_IN_METHOD,
      accessToken: t
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(t) {
    return Dt.credentialFromTaggedObject(t);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(t) {
    return Dt.credentialFromTaggedObject(t.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t || !("oauthAccessToken" in t) || !t.oauthAccessToken)
      return null;
    try {
      return Dt.credential(t.oauthAccessToken);
    } catch {
      return null;
    }
  }
}
Dt.GITHUB_SIGN_IN_METHOD = "github.com";
Dt.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jp = "http://localhost";
class Pr extends Ur {
  /** @internal */
  constructor(t, n) {
    super(t, t), this.pendingToken = n;
  }
  /** @internal */
  _getIdTokenResponse(t) {
    const n = this.buildRequest();
    return It(t, n);
  }
  /** @internal */
  _linkToIdToken(t, n) {
    const r = this.buildRequest();
    return r.idToken = n, It(t, r);
  }
  /** @internal */
  _getReauthenticationResolver(t) {
    const n = this.buildRequest();
    return n.autoCreate = !1, It(t, n);
  }
  /** {@inheritdoc AuthCredential.toJSON}  */
  toJSON() {
    return {
      signInMethod: this.signInMethod,
      providerId: this.providerId,
      pendingToken: this.pendingToken
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an
   * {@link  AuthCredential}.
   *
   * @param json - Input can be either Object or the stringified representation of the object.
   * When string is provided, JSON.parse would be called first.
   *
   * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
   */
  static fromJSON(t) {
    const n = typeof t == "string" ? JSON.parse(t) : t, { providerId: r, signInMethod: i, pendingToken: s } = n;
    return !r || !i || !s || r !== i ? null : new Pr(r, s);
  }
  /**
   * Helper static method to avoid exposing the constructor to end users.
   *
   * @internal
   */
  static _create(t, n) {
    return new Pr(t, n);
  }
  buildRequest() {
    return {
      requestUri: Jp,
      returnSecureToken: !0,
      pendingToken: this.pendingToken
    };
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yp = "saml.";
class Vi extends Qi {
  /**
   * Constructor. The providerId must start with "saml."
   * @param providerId - SAML provider ID.
   */
  constructor(t) {
    L(
      t.startsWith(Yp),
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), super(t);
  }
  /**
   * Generates an {@link AuthCredential} from a {@link UserCredential} after a
   * successful SAML flow completes.
   *
   * @remarks
   *
   * For example, to get an {@link AuthCredential}, you could write the
   * following code:
   *
   * ```js
   * const userCredential = await signInWithPopup(auth, samlProvider);
   * const credential = SAMLAuthProvider.credentialFromResult(userCredential);
   * ```
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(t) {
    return Vi.samlCredentialFromTaggedObject(t);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(t) {
    return Vi.samlCredentialFromTaggedObject(t.customData || {});
  }
  /**
   * Creates an {@link AuthCredential} from a JSON string or a plain object.
   * @param json - A plain object or a JSON string
   */
  static credentialFromJSON(t) {
    const n = Pr.fromJSON(t);
    return L(
      n,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), n;
  }
  static samlCredentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t)
      return null;
    const { pendingToken: n, providerId: r } = t;
    if (!n || !r)
      return null;
    try {
      return Pr._create(r, n);
    } catch {
      return null;
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lt extends Hr {
  constructor() {
    super(
      "twitter.com"
      /* ProviderId.TWITTER */
    );
  }
  /**
   * Creates a credential for Twitter.
   *
   * @param token - Twitter access token.
   * @param secret - Twitter secret.
   */
  static credential(t, n) {
    return _n._fromParams({
      providerId: Lt.PROVIDER_ID,
      signInMethod: Lt.TWITTER_SIGN_IN_METHOD,
      oauthToken: t,
      oauthTokenSecret: n
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(t) {
    return Lt.credentialFromTaggedObject(t);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(t) {
    return Lt.credentialFromTaggedObject(t.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t)
      return null;
    const { oauthAccessToken: n, oauthTokenSecret: r } = t;
    if (!n || !r)
      return null;
    try {
      return Lt.credential(n, r);
    } catch {
      return null;
    }
  }
}
Lt.TWITTER_SIGN_IN_METHOD = "twitter.com";
Lt.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Xp(e, t) {
  return Yt(e, "POST", "/v1/accounts:signUp", Ye(e, t));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bn {
  constructor(t) {
    this.user = t.user, this.providerId = t.providerId, this._tokenResponse = t._tokenResponse, this.operationType = t.operationType;
  }
  static async _fromIdTokenResponse(t, n, r, i = !1) {
    const s = await vn._fromIdTokenResponse(t, r, i), o = ml(r);
    return new bn({
      user: s,
      providerId: o,
      _tokenResponse: r,
      operationType: n
    });
  }
  static async _forOperation(t, n, r) {
    await t._updateTokensIfNecessary(
      r,
      /* reload */
      !0
    );
    const i = ml(r);
    return new bn({
      user: t,
      providerId: i,
      _tokenResponse: r,
      operationType: n
    });
  }
}
function ml(e) {
  return e.providerId ? e.providerId : "phoneNumber" in e ? "phone" : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Di extends Jt {
  constructor(t, n, r, i) {
    var s;
    super(n.code, n.message), this.operationType = r, this.user = i, Object.setPrototypeOf(this, Di.prototype), this.customData = {
      appName: t.name,
      tenantId: (s = t.tenantId) !== null && s !== void 0 ? s : void 0,
      _serverResponse: n.customData._serverResponse,
      operationType: r
    };
  }
  static _fromErrorAndOperation(t, n, r, i) {
    return new Di(t, n, r, i);
  }
}
function td(e, t, n, r) {
  return (t === "reauthenticate" ? n._getReauthenticationResolver(e) : n._getIdTokenResponse(e)).catch((s) => {
    throw s.code === "auth/multi-factor-auth-required" ? Di._fromErrorAndOperation(e, s, t, r) : s;
  });
}
async function Qp(e, t, n = !1) {
  const r = await Wn(e, t._linkToIdToken(e.auth, await e.getIdToken()), n);
  return bn._forOperation(e, "link", r);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Zp(e, t, n = !1) {
  const { auth: r } = e, i = "reauthenticate";
  try {
    const s = await Wn(e, td(r, i, t, e), n);
    L(
      s.idToken,
      r,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const o = zo(s.idToken);
    L(
      o,
      r,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const { sub: a } = o;
    return L(
      e.uid === a,
      r,
      "user-mismatch"
      /* AuthErrorCode.USER_MISMATCH */
    ), bn._forOperation(e, i, s);
  } catch (s) {
    throw (s == null ? void 0 : s.code) === "auth/user-not-found" && Ke(
      r,
      "user-mismatch"
      /* AuthErrorCode.USER_MISMATCH */
    ), s;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function nd(e, t, n = !1) {
  const r = "signIn", i = await td(e, r, t), s = await bn._fromIdTokenResponse(e, r, i);
  return n || await e._updateCurrentUser(s.user), s;
}
async function rd(e, t) {
  return nd(Xt(e), t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function id(e, t, n) {
  var r;
  L(
    ((r = n.url) === null || r === void 0 ? void 0 : r.length) > 0,
    e,
    "invalid-continue-uri"
    /* AuthErrorCode.INVALID_CONTINUE_URI */
  ), L(
    typeof n.dynamicLinkDomain > "u" || n.dynamicLinkDomain.length > 0,
    e,
    "invalid-dynamic-link-domain"
    /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */
  ), t.continueUrl = n.url, t.dynamicLinkDomain = n.dynamicLinkDomain, t.canHandleCodeInApp = n.handleCodeInApp, n.iOS && (L(
    n.iOS.bundleId.length > 0,
    e,
    "missing-ios-bundle-id"
    /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */
  ), t.iOSBundleId = n.iOS.bundleId), n.android && (L(
    n.android.packageName.length > 0,
    e,
    "missing-android-pkg-name"
    /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */
  ), t.androidInstallApp = n.android.installApp, t.androidMinimumVersionCode = n.android.minimumVersion, t.androidPackageName = n.android.packageName);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ey(e, t, n) {
  const r = Fe(e), i = {
    requestType: "PASSWORD_RESET",
    email: t
  };
  n && id(r, i, n), await Mp(r, i);
}
async function ty(e, t, n) {
  const r = Xt(e), i = await Xp(r, {
    returnSecureToken: !0,
    email: t,
    password: n
  }), s = await bn._fromIdTokenResponse(r, "signIn", i);
  return await r._updateCurrentUser(s.user), s;
}
function gl(e, t, n) {
  return rd(Fe(e), Jn.credential(t, n));
}
async function pl(e, t) {
  const n = Fe(e), i = {
    requestType: "VERIFY_EMAIL",
    idToken: await e.getIdToken()
  };
  t && id(n.auth, i, t);
  const { email: s } = await $p(n.auth, i);
  s !== e.email && await e.reload();
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ny(e, t) {
  return at(e, "POST", "/v1/accounts:update", t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ry(e, { displayName: t, photoURL: n }) {
  if (t === void 0 && n === void 0)
    return;
  const r = Fe(e), s = {
    idToken: await r.getIdToken(),
    displayName: t,
    photoUrl: n,
    returnSecureToken: !0
  }, o = await Wn(r, ny(r.auth, s));
  r.displayName = o.displayName || null, r.photoURL = o.photoUrl || null;
  const a = r.providerData.find(
    ({ providerId: l }) => l === "password"
    /* ProviderId.PASSWORD */
  );
  a && (a.displayName = r.displayName, a.photoURL = r.photoURL), await r._updateTokensIfNecessary(o);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function yl(e, t) {
  return Fe(e).setPersistence(t);
}
function iy(e, t, n, r) {
  return Fe(e).onIdTokenChanged(t, n, r);
}
function sy(e, t, n) {
  return Fe(e).beforeAuthStateChanged(t, n);
}
function _l(e) {
  return Fe(e).signOut();
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function oy(e, t) {
  return at(e, "POST", "/v2/accounts/mfaEnrollment:start", Ye(e, t));
}
const Li = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sd {
  constructor(t, n) {
    this.storageRetriever = t, this.type = n;
  }
  _isAvailable() {
    try {
      return this.storage ? (this.storage.setItem(Li, "1"), this.storage.removeItem(Li), Promise.resolve(!0)) : Promise.resolve(!1);
    } catch {
      return Promise.resolve(!1);
    }
  }
  _set(t, n) {
    return this.storage.setItem(t, JSON.stringify(n)), Promise.resolve();
  }
  _get(t) {
    const n = this.storage.getItem(t);
    return Promise.resolve(n ? JSON.parse(n) : null);
  }
  _remove(t) {
    return this.storage.removeItem(t), Promise.resolve();
  }
  get storage() {
    return this.storageRetriever();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ay() {
  const e = Ee();
  return Go(e) || Xi(e);
}
const ly = 1e3, cy = 10;
class od extends sd {
  constructor() {
    super(
      () => window.localStorage,
      "LOCAL"
      /* PersistenceType.LOCAL */
    ), this.boundEventHandler = (t, n) => this.onStorageEvent(t, n), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = ay() && Ap(), this.fallbackToPolling = Xu(), this._shouldAllowMigration = !0;
  }
  forAllChangedKeys(t) {
    for (const n of Object.keys(this.listeners)) {
      const r = this.storage.getItem(n), i = this.localCache[n];
      r !== i && t(n, i, r);
    }
  }
  onStorageEvent(t, n = !1) {
    if (!t.key) {
      this.forAllChangedKeys((o, a, l) => {
        this.notifyListeners(o, l);
      });
      return;
    }
    const r = t.key;
    if (n ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) {
      const o = this.storage.getItem(r);
      if (t.newValue !== o)
        t.newValue !== null ? this.storage.setItem(r, t.newValue) : this.storage.removeItem(r);
      else if (this.localCache[r] === t.newValue && !n)
        return;
    }
    const i = () => {
      const o = this.storage.getItem(r);
      !n && this.localCache[r] === o || this.notifyListeners(r, o);
    }, s = this.storage.getItem(r);
    Op() && s !== t.newValue && t.newValue !== t.oldValue ? setTimeout(i, cy) : i();
  }
  notifyListeners(t, n) {
    this.localCache[t] = n;
    const r = this.listeners[t];
    if (r)
      for (const i of Array.from(r))
        i(n && JSON.parse(n));
  }
  startPolling() {
    this.stopPolling(), this.pollTimer = setInterval(() => {
      this.forAllChangedKeys((t, n, r) => {
        this.onStorageEvent(
          new StorageEvent("storage", {
            key: t,
            oldValue: n,
            newValue: r
          }),
          /* poll */
          !0
        );
      });
    }, ly);
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
  }
  attachListener() {
    window.addEventListener("storage", this.boundEventHandler);
  }
  detachListener() {
    window.removeEventListener("storage", this.boundEventHandler);
  }
  _addListener(t, n) {
    Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[t] || (this.listeners[t] = /* @__PURE__ */ new Set(), this.localCache[t] = this.storage.getItem(t)), this.listeners[t].add(n);
  }
  _removeListener(t, n) {
    this.listeners[t] && (this.listeners[t].delete(n), this.listeners[t].size === 0 && delete this.listeners[t]), Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling());
  }
  // Update local cache on base operations:
  async _set(t, n) {
    await super._set(t, n), this.localCache[t] = JSON.stringify(n);
  }
  async _get(t) {
    const n = await super._get(t);
    return this.localCache[t] = JSON.stringify(n), n;
  }
  async _remove(t) {
    await super._remove(t), delete this.localCache[t];
  }
}
od.type = "LOCAL";
const ad = od;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ld extends sd {
  constructor() {
    super(
      () => window.sessionStorage,
      "SESSION"
      /* PersistenceType.SESSION */
    );
  }
  _addListener(t, n) {
  }
  _removeListener(t, n) {
  }
}
ld.type = "SESSION";
const Ko = ld;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function uy(e) {
  return Promise.all(e.map(async (t) => {
    try {
      return {
        fulfilled: !0,
        value: await t
      };
    } catch (n) {
      return {
        fulfilled: !1,
        reason: n
      };
    }
  }));
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zi {
  constructor(t) {
    this.eventTarget = t, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this);
  }
  /**
   * Obtain an instance of a Receiver for a given event target, if none exists it will be created.
   *
   * @param eventTarget - An event target (such as window or self) through which the underlying
   * messages will be received.
   */
  static _getInstance(t) {
    const n = this.receivers.find((i) => i.isListeningto(t));
    if (n)
      return n;
    const r = new Zi(t);
    return this.receivers.push(r), r;
  }
  isListeningto(t) {
    return this.eventTarget === t;
  }
  /**
   * Fans out a MessageEvent to the appropriate listeners.
   *
   * @remarks
   * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have
   * finished processing.
   *
   * @param event - The MessageEvent.
   *
   */
  async handleEvent(t) {
    const n = t, { eventId: r, eventType: i, data: s } = n.data, o = this.handlersMap[i];
    if (!(o != null && o.size))
      return;
    n.ports[0].postMessage({
      status: "ack",
      eventId: r,
      eventType: i
    });
    const a = Array.from(o).map(async (c) => c(n.origin, s)), l = await uy(a);
    n.ports[0].postMessage({
      status: "done",
      eventId: r,
      eventType: i,
      response: l
    });
  }
  /**
   * Subscribe an event handler for a particular event.
   *
   * @param eventType - Event name to subscribe to.
   * @param eventHandler - The event handler which should receive the events.
   *
   */
  _subscribe(t, n) {
    Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[t] || (this.handlersMap[t] = /* @__PURE__ */ new Set()), this.handlersMap[t].add(n);
  }
  /**
   * Unsubscribe an event handler from a particular event.
   *
   * @param eventType - Event name to unsubscribe from.
   * @param eventHandler - Optinoal event handler, if none provided, unsubscribe all handlers on this event.
   *
   */
  _unsubscribe(t, n) {
    this.handlersMap[t] && n && this.handlersMap[t].delete(n), (!n || this.handlersMap[t].size === 0) && delete this.handlersMap[t], Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler);
  }
}
Zi.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Jo(e = "", t = 10) {
  let n = "";
  for (let r = 0; r < t; r++)
    n += Math.floor(Math.random() * 10);
  return e + n;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dy {
  constructor(t) {
    this.target = t, this.handlers = /* @__PURE__ */ new Set();
  }
  /**
   * Unsubscribe the handler and remove it from our tracking Set.
   *
   * @param handler - The handler to unsubscribe.
   */
  removeMessageHandler(t) {
    t.messageChannel && (t.messageChannel.port1.removeEventListener("message", t.onMessage), t.messageChannel.port1.close()), this.handlers.delete(t);
  }
  /**
   * Send a message to the Receiver located at {@link target}.
   *
   * @remarks
   * We'll first wait a bit for an ACK , if we get one we will wait significantly longer until the
   * receiver has had a chance to fully process the event.
   *
   * @param eventType - Type of event to send.
   * @param data - The payload of the event.
   * @param timeout - Timeout for waiting on an ACK from the receiver.
   *
   * @returns An array of settled promises from all the handlers that were listening on the receiver.
   */
  async _send(t, n, r = 50) {
    const i = typeof MessageChannel < "u" ? new MessageChannel() : null;
    if (!i)
      throw new Error(
        "connection_unavailable"
        /* _MessageError.CONNECTION_UNAVAILABLE */
      );
    let s, o;
    return new Promise((a, l) => {
      const c = Jo("", 20);
      i.port1.start();
      const d = setTimeout(() => {
        l(new Error(
          "unsupported_event"
          /* _MessageError.UNSUPPORTED_EVENT */
        ));
      }, r);
      o = {
        messageChannel: i,
        onMessage(u) {
          const f = u;
          if (f.data.eventId === c)
            switch (f.data.status) {
              case "ack":
                clearTimeout(d), s = setTimeout(
                  () => {
                    l(new Error(
                      "timeout"
                      /* _MessageError.TIMEOUT */
                    ));
                  },
                  3e3
                  /* _TimeoutDuration.COMPLETION */
                );
                break;
              case "done":
                clearTimeout(s), a(f.data.response);
                break;
              default:
                clearTimeout(d), clearTimeout(s), l(new Error(
                  "invalid_response"
                  /* _MessageError.INVALID_RESPONSE */
                ));
                break;
            }
        }
      }, this.handlers.add(o), i.port1.addEventListener("message", o.onMessage), this.target.postMessage({
        eventType: t,
        eventId: c,
        data: n
      }, [i.port2]);
    }).finally(() => {
      o && this.removeMessageHandler(o);
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function he() {
  return window;
}
function fy(e) {
  he().location.href = e;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Yo() {
  return typeof he().WorkerGlobalScope < "u" && typeof he().importScripts == "function";
}
async function hy() {
  if (!(navigator != null && navigator.serviceWorker))
    return null;
  try {
    return (await navigator.serviceWorker.ready).active;
  } catch {
    return null;
  }
}
function vy() {
  var e;
  return ((e = navigator == null ? void 0 : navigator.serviceWorker) === null || e === void 0 ? void 0 : e.controller) || null;
}
function my() {
  return Yo() ? self : null;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cd = "firebaseLocalStorageDb", gy = 1, $i = "firebaseLocalStorage", ud = "fbase_key";
class jr {
  constructor(t) {
    this.request = t;
  }
  toPromise() {
    return new Promise((t, n) => {
      this.request.addEventListener("success", () => {
        t(this.request.result);
      }), this.request.addEventListener("error", () => {
        n(this.request.error);
      });
    });
  }
}
function es(e, t) {
  return e.transaction([$i], t ? "readwrite" : "readonly").objectStore($i);
}
function py() {
  const e = indexedDB.deleteDatabase(cd);
  return new jr(e).toPromise();
}
function no() {
  const e = indexedDB.open(cd, gy);
  return new Promise((t, n) => {
    e.addEventListener("error", () => {
      n(e.error);
    }), e.addEventListener("upgradeneeded", () => {
      const r = e.result;
      try {
        r.createObjectStore($i, { keyPath: ud });
      } catch (i) {
        n(i);
      }
    }), e.addEventListener("success", async () => {
      const r = e.result;
      r.objectStoreNames.contains($i) ? t(r) : (r.close(), await py(), t(await no()));
    });
  });
}
async function bl(e, t, n) {
  const r = es(e, !0).put({
    [ud]: t,
    value: n
  });
  return new jr(r).toPromise();
}
async function yy(e, t) {
  const n = es(e, !1).get(t), r = await new jr(n).toPromise();
  return r === void 0 ? null : r.value;
}
function wl(e, t) {
  const n = es(e, !0).delete(t);
  return new jr(n).toPromise();
}
const _y = 800, by = 3;
class dd {
  constructor() {
    this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {
    }, () => {
    });
  }
  async _openDb() {
    return this.db ? this.db : (this.db = await no(), this.db);
  }
  async _withRetries(t) {
    let n = 0;
    for (; ; )
      try {
        const r = await this._openDb();
        return await t(r);
      } catch (r) {
        if (n++ > by)
          throw r;
        this.db && (this.db.close(), this.db = void 0);
      }
  }
  /**
   * IndexedDB events do not propagate from the main window to the worker context.  We rely on a
   * postMessage interface to send these events to the worker ourselves.
   */
  async initializeServiceWorkerMessaging() {
    return Yo() ? this.initializeReceiver() : this.initializeSender();
  }
  /**
   * As the worker we should listen to events from the main window.
   */
  async initializeReceiver() {
    this.receiver = Zi._getInstance(my()), this.receiver._subscribe("keyChanged", async (t, n) => ({
      keyProcessed: (await this._poll()).includes(n.key)
    })), this.receiver._subscribe("ping", async (t, n) => [
      "keyChanged"
      /* _EventType.KEY_CHANGED */
    ]);
  }
  /**
   * As the main window, we should let the worker know when keys change (set and remove).
   *
   * @remarks
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/ready | ServiceWorkerContainer.ready}
   * may not resolve.
   */
  async initializeSender() {
    var t, n;
    if (this.activeServiceWorker = await hy(), !this.activeServiceWorker)
      return;
    this.sender = new dy(this.activeServiceWorker);
    const r = await this.sender._send(
      "ping",
      {},
      800
      /* _TimeoutDuration.LONG_ACK */
    );
    r && !((t = r[0]) === null || t === void 0) && t.fulfilled && !((n = r[0]) === null || n === void 0) && n.value.includes(
      "keyChanged"
      /* _EventType.KEY_CHANGED */
    ) && (this.serviceWorkerReceiverAvailable = !0);
  }
  /**
   * Let the worker know about a changed key, the exact key doesn't technically matter since the
   * worker will just trigger a full sync anyway.
   *
   * @remarks
   * For now, we only support one service worker per page.
   *
   * @param key - Storage key which changed.
   */
  async notifyServiceWorker(t) {
    if (!(!this.sender || !this.activeServiceWorker || vy() !== this.activeServiceWorker))
      try {
        await this.sender._send(
          "keyChanged",
          { key: t },
          // Use long timeout if receiver has previously responded to a ping from us.
          this.serviceWorkerReceiverAvailable ? 800 : 50
          /* _TimeoutDuration.ACK */
        );
      } catch {
      }
  }
  async _isAvailable() {
    try {
      if (!indexedDB)
        return !1;
      const t = await no();
      return await bl(t, Li, "1"), await wl(t, Li), !0;
    } catch {
    }
    return !1;
  }
  async _withPendingWrite(t) {
    this.pendingWrites++;
    try {
      await t();
    } finally {
      this.pendingWrites--;
    }
  }
  async _set(t, n) {
    return this._withPendingWrite(async () => (await this._withRetries((r) => bl(r, t, n)), this.localCache[t] = n, this.notifyServiceWorker(t)));
  }
  async _get(t) {
    const n = await this._withRetries((r) => yy(r, t));
    return this.localCache[t] = n, n;
  }
  async _remove(t) {
    return this._withPendingWrite(async () => (await this._withRetries((n) => wl(n, t)), delete this.localCache[t], this.notifyServiceWorker(t)));
  }
  async _poll() {
    const t = await this._withRetries((i) => {
      const s = es(i, !1).getAll();
      return new jr(s).toPromise();
    });
    if (!t)
      return [];
    if (this.pendingWrites !== 0)
      return [];
    const n = [], r = /* @__PURE__ */ new Set();
    for (const { fbase_key: i, value: s } of t)
      r.add(i), JSON.stringify(this.localCache[i]) !== JSON.stringify(s) && (this.notifyListeners(i, s), n.push(i));
    for (const i of Object.keys(this.localCache))
      this.localCache[i] && !r.has(i) && (this.notifyListeners(i, null), n.push(i));
    return n;
  }
  notifyListeners(t, n) {
    this.localCache[t] = n;
    const r = this.listeners[t];
    if (r)
      for (const i of Array.from(r))
        i(n);
  }
  startPolling() {
    this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), _y);
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
  }
  _addListener(t, n) {
    Object.keys(this.listeners).length === 0 && this.startPolling(), this.listeners[t] || (this.listeners[t] = /* @__PURE__ */ new Set(), this._get(t)), this.listeners[t].add(n);
  }
  _removeListener(t, n) {
    this.listeners[t] && (this.listeners[t].delete(n), this.listeners[t].size === 0 && delete this.listeners[t]), Object.keys(this.listeners).length === 0 && this.stopPolling();
  }
}
dd.type = "LOCAL";
const wy = dd;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Sy(e, t) {
  return at(e, "POST", "/v2/accounts/mfaSignIn:start", Ye(e, t));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Ey(e) {
  return (await at(
    e,
    "GET",
    "/v1/recaptchaParams"
    /* Endpoint.GET_RECAPTCHA_PARAM */
  )).recaptchaSiteKey || "";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Iy() {
  var e, t;
  return (t = (e = document.getElementsByTagName("head")) === null || e === void 0 ? void 0 : e[0]) !== null && t !== void 0 ? t : document;
}
function fd(e) {
  return new Promise((t, n) => {
    const r = document.createElement("script");
    r.setAttribute("src", e), r.onload = t, r.onerror = (i) => {
      const s = Me(
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      s.customData = i, n(s);
    }, r.type = "text/javascript", r.charset = "UTF-8", Iy().appendChild(r);
  });
}
function hd(e) {
  return `__${e}${Math.floor(Math.random() * 1e6)}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Cy = 500, ky = 6e4, oi = 1e12;
class Ty {
  constructor(t) {
    this.auth = t, this.counter = oi, this._widgets = /* @__PURE__ */ new Map();
  }
  render(t, n) {
    const r = this.counter;
    return this._widgets.set(r, new Oy(t, this.auth.name, n || {})), this.counter++, r;
  }
  reset(t) {
    var n;
    const r = t || oi;
    (n = this._widgets.get(r)) === null || n === void 0 || n.delete(), this._widgets.delete(r);
  }
  getResponse(t) {
    var n;
    const r = t || oi;
    return ((n = this._widgets.get(r)) === null || n === void 0 ? void 0 : n.getResponse()) || "";
  }
  async execute(t) {
    var n;
    const r = t || oi;
    return (n = this._widgets.get(r)) === null || n === void 0 || n.execute(), "";
  }
}
class Oy {
  constructor(t, n, r) {
    this.params = r, this.timerId = null, this.deleted = !1, this.responseToken = null, this.clickHandler = () => {
      this.execute();
    };
    const i = typeof t == "string" ? document.getElementById(t) : t;
    L(i, "argument-error", { appName: n }), this.container = i, this.isVisible = this.params.size !== "invisible", this.isVisible ? this.execute() : this.container.addEventListener("click", this.clickHandler);
  }
  getResponse() {
    return this.checkIfDeleted(), this.responseToken;
  }
  delete() {
    this.checkIfDeleted(), this.deleted = !0, this.timerId && (clearTimeout(this.timerId), this.timerId = null), this.container.removeEventListener("click", this.clickHandler);
  }
  execute() {
    this.checkIfDeleted(), !this.timerId && (this.timerId = window.setTimeout(() => {
      this.responseToken = Ay(50);
      const { callback: t, "expired-callback": n } = this.params;
      if (t)
        try {
          t(this.responseToken);
        } catch {
        }
      this.timerId = window.setTimeout(() => {
        if (this.timerId = null, this.responseToken = null, n)
          try {
            n();
          } catch {
          }
        this.isVisible && this.execute();
      }, ky);
    }, Cy));
  }
  checkIfDeleted() {
    if (this.deleted)
      throw new Error("reCAPTCHA mock was already deleted!");
  }
}
function Ay(e) {
  const t = [], n = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (let r = 0; r < e; r++)
    t.push(n.charAt(Math.floor(Math.random() * n.length)));
  return t.join("");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Cs = hd("rcb"), Ny = new Fr(3e4, 6e4), Py = "https://www.google.com/recaptcha/api.js?";
class Ry {
  constructor() {
    var t;
    this.hostLanguage = "", this.counter = 0, this.librarySeparatelyLoaded = !!(!((t = he().grecaptcha) === null || t === void 0) && t.render);
  }
  load(t, n = "") {
    return L(
      xy(n),
      t,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), this.shouldResolveImmediately(n) ? Promise.resolve(he().grecaptcha) : new Promise((r, i) => {
      const s = he().setTimeout(() => {
        i(Me(
          t,
          "network-request-failed"
          /* AuthErrorCode.NETWORK_REQUEST_FAILED */
        ));
      }, Ny.get());
      he()[Cs] = () => {
        he().clearTimeout(s), delete he()[Cs];
        const a = he().grecaptcha;
        if (!a) {
          i(Me(
            t,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          ));
          return;
        }
        const l = a.render;
        a.render = (c, d) => {
          const u = l(c, d);
          return this.counter++, u;
        }, this.hostLanguage = n, r(a);
      };
      const o = `${Py}?${Kn({
        onload: Cs,
        render: "explicit",
        hl: n
      })}`;
      fd(o).catch(() => {
        clearTimeout(s), i(Me(
          t,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        ));
      });
    });
  }
  clearedOneInstance() {
    this.counter--;
  }
  shouldResolveImmediately(t) {
    var n;
    return !!(!((n = he().grecaptcha) === null || n === void 0) && n.render) && (t === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded);
  }
}
function xy(e) {
  return e.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(e);
}
class Vy {
  async load(t) {
    return new Ty(t);
  }
  clearedOneInstance() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vd = "recaptcha", Dy = {
  theme: "light",
  type: "image"
};
class Ly {
  /**
   *
   * @param containerOrId - The reCAPTCHA container parameter.
   *
   * @remarks
   * This has different meaning depending on whether the reCAPTCHA is hidden or visible. For a
   * visible reCAPTCHA the container must be empty. If a string is used, it has to correspond to
   * an element ID. The corresponding element must also must be in the DOM at the time of
   * initialization.
   *
   * @param parameters - The optional reCAPTCHA parameters.
   *
   * @remarks
   * Check the reCAPTCHA docs for a comprehensive list. All parameters are accepted except for
   * the sitekey. Firebase Auth backend provisions a reCAPTCHA for each project and will
   * configure this upon rendering. For an invisible reCAPTCHA, a size key must have the value
   * 'invisible'.
   *
   * @param authExtern - The corresponding Firebase {@link Auth} instance.
   */
  constructor(t, n = Object.assign({}, Dy), r) {
    this.parameters = n, this.type = vd, this.destroyed = !1, this.widgetId = null, this.tokenChangeListeners = /* @__PURE__ */ new Set(), this.renderPromise = null, this.recaptcha = null, this.auth = Xt(r), this.isInvisible = this.parameters.size === "invisible", L(
      typeof document < "u",
      this.auth,
      "operation-not-supported-in-this-environment"
      /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
    );
    const i = typeof t == "string" ? document.getElementById(t) : t;
    L(
      i,
      this.auth,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), this.container = i, this.parameters.callback = this.makeTokenCallback(this.parameters.callback), this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new Vy() : new Ry(), this.validateStartingState();
  }
  /**
   * Waits for the user to solve the reCAPTCHA and resolves with the reCAPTCHA token.
   *
   * @returns A Promise for the reCAPTCHA token.
   */
  async verify() {
    this.assertNotDestroyed();
    const t = await this.render(), n = this.getAssertedRecaptcha(), r = n.getResponse(t);
    return r || new Promise((i) => {
      const s = (o) => {
        o && (this.tokenChangeListeners.delete(s), i(o));
      };
      this.tokenChangeListeners.add(s), this.isInvisible && n.execute(t);
    });
  }
  /**
   * Renders the reCAPTCHA widget on the page.
   *
   * @returns A Promise that resolves with the reCAPTCHA widget ID.
   */
  render() {
    try {
      this.assertNotDestroyed();
    } catch (t) {
      return Promise.reject(t);
    }
    return this.renderPromise ? this.renderPromise : (this.renderPromise = this.makeRenderPromise().catch((t) => {
      throw this.renderPromise = null, t;
    }), this.renderPromise);
  }
  /** @internal */
  _reset() {
    this.assertNotDestroyed(), this.widgetId !== null && this.getAssertedRecaptcha().reset(this.widgetId);
  }
  /**
   * Clears the reCAPTCHA widget from the page and destroys the instance.
   */
  clear() {
    this.assertNotDestroyed(), this.destroyed = !0, this._recaptchaLoader.clearedOneInstance(), this.isInvisible || this.container.childNodes.forEach((t) => {
      this.container.removeChild(t);
    });
  }
  validateStartingState() {
    L(
      !this.parameters.sitekey,
      this.auth,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), L(
      this.isInvisible || !this.container.hasChildNodes(),
      this.auth,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), L(
      typeof document < "u",
      this.auth,
      "operation-not-supported-in-this-environment"
      /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
    );
  }
  makeTokenCallback(t) {
    return (n) => {
      if (this.tokenChangeListeners.forEach((r) => r(n)), typeof t == "function")
        t(n);
      else if (typeof t == "string") {
        const r = he()[t];
        typeof r == "function" && r(n);
      }
    };
  }
  assertNotDestroyed() {
    L(
      !this.destroyed,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
  }
  async makeRenderPromise() {
    if (await this.init(), !this.widgetId) {
      let t = this.container;
      if (!this.isInvisible) {
        const n = document.createElement("div");
        t.appendChild(n), t = n;
      }
      this.widgetId = this.getAssertedRecaptcha().render(t, this.parameters);
    }
    return this.widgetId;
  }
  async init() {
    L(
      Bu() && !Yo(),
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), await $y(), this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || void 0);
    const t = await Ey(this.auth);
    L(
      t,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.parameters.sitekey = t;
  }
  getAssertedRecaptcha() {
    return L(
      this.recaptcha,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.recaptcha;
  }
}
function $y() {
  let e = null;
  return new Promise((t) => {
    if (document.readyState === "complete") {
      t();
      return;
    }
    e = () => t(), window.addEventListener("load", e);
  }).catch((t) => {
    throw e && window.removeEventListener("load", e), t;
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class My {
  constructor(t, n) {
    this.verificationId = t, this.onConfirmation = n;
  }
  confirm(t) {
    const n = mr._fromVerification(this.verificationId, t);
    return this.onConfirmation(n);
  }
}
async function By(e, t, n) {
  const r = Xt(e), i = await Fy(r, t, Fe(n));
  return new My(i, (s) => rd(r, s));
}
async function Fy(e, t, n) {
  var r;
  const i = await n.verify();
  try {
    L(
      typeof i == "string",
      e,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), L(
      n.type === vd,
      e,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    let s;
    if (typeof t == "string" ? s = {
      phoneNumber: t
    } : s = t, "session" in s) {
      const o = s.session;
      if ("phoneNumber" in s)
        return L(
          o.type === "enroll",
          e,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        ), (await oy(e, {
          idToken: o.credential,
          phoneEnrollmentInfo: {
            phoneNumber: s.phoneNumber,
            recaptchaToken: i
          }
        })).phoneSessionInfo.sessionInfo;
      {
        L(
          o.type === "signin",
          e,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
        const a = ((r = s.multiFactorHint) === null || r === void 0 ? void 0 : r.uid) || s.multiFactorUid;
        return L(
          a,
          e,
          "missing-multi-factor-info"
          /* AuthErrorCode.MISSING_MFA_INFO */
        ), (await Sy(e, {
          mfaPendingCredential: o.credential,
          mfaEnrollmentId: a,
          phoneSignInInfo: {
            recaptchaToken: i
          }
        })).phoneResponseInfo.sessionInfo;
      }
    } else {
      const { sessionInfo: o } = await Hp(e, {
        phoneNumber: s.phoneNumber,
        recaptchaToken: i
      });
      return o;
    }
  } finally {
    n._reset();
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function md(e, t) {
  return t ? wt(t) : (L(
    e._popupRedirectResolver,
    e,
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  ), e._popupRedirectResolver);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xo extends Ur {
  constructor(t) {
    super(
      "custom",
      "custom"
      /* ProviderId.CUSTOM */
    ), this.params = t;
  }
  _getIdTokenResponse(t) {
    return It(t, this._buildIdpRequest());
  }
  _linkToIdToken(t, n) {
    return It(t, this._buildIdpRequest(n));
  }
  _getReauthenticationResolver(t) {
    return It(t, this._buildIdpRequest());
  }
  _buildIdpRequest(t) {
    const n = {
      requestUri: this.params.requestUri,
      sessionId: this.params.sessionId,
      postBody: this.params.postBody,
      tenantId: this.params.tenantId,
      pendingToken: this.params.pendingToken,
      returnSecureToken: !0,
      returnIdpCredential: !0
    };
    return t && (n.idToken = t), n;
  }
}
function Uy(e) {
  return nd(e.auth, new Xo(e), e.bypassAuthState);
}
function Hy(e) {
  const { auth: t, user: n } = e;
  return L(
    n,
    t,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), Zp(n, new Xo(e), e.bypassAuthState);
}
async function jy(e) {
  const { auth: t, user: n } = e;
  return L(
    n,
    t,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), Qp(n, new Xo(e), e.bypassAuthState);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gd {
  constructor(t, n, r, i, s = !1) {
    this.auth = t, this.resolver = r, this.user = i, this.bypassAuthState = s, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(n) ? n : [n];
  }
  execute() {
    return new Promise(async (t, n) => {
      this.pendingPromise = { resolve: t, reject: n };
      try {
        this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this);
      } catch (r) {
        this.reject(r);
      }
    });
  }
  async onAuthEvent(t) {
    const { urlResponse: n, sessionId: r, postBody: i, tenantId: s, error: o, type: a } = t;
    if (o) {
      this.reject(o);
      return;
    }
    const l = {
      auth: this.auth,
      requestUri: n,
      sessionId: r,
      tenantId: s || void 0,
      postBody: i || void 0,
      user: this.user,
      bypassAuthState: this.bypassAuthState
    };
    try {
      this.resolve(await this.getIdpTask(a)(l));
    } catch (c) {
      this.reject(c);
    }
  }
  onError(t) {
    this.reject(t);
  }
  getIdpTask(t) {
    switch (t) {
      case "signInViaPopup":
      case "signInViaRedirect":
        return Uy;
      case "linkViaPopup":
      case "linkViaRedirect":
        return jy;
      case "reauthViaPopup":
      case "reauthViaRedirect":
        return Hy;
      default:
        Ke(
          this.auth,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  resolve(t) {
    kt(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(t), this.unregisterAndCleanUp();
  }
  reject(t) {
    kt(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(t), this.unregisterAndCleanUp();
  }
  unregisterAndCleanUp() {
    this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Wy = new Fr(2e3, 1e4);
class $n extends gd {
  constructor(t, n, r, i, s) {
    super(t, n, i, s), this.provider = r, this.authWindow = null, this.pollId = null, $n.currentPopupAction && $n.currentPopupAction.cancel(), $n.currentPopupAction = this;
  }
  async executeNotNull() {
    const t = await this.execute();
    return L(
      t,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), t;
  }
  async onExecution() {
    kt(this.filter.length === 1, "Popup operations only handle one event");
    const t = Jo();
    this.authWindow = await this.resolver._openPopup(
      this.auth,
      this.provider,
      this.filter[0],
      // There's always one, see constructor
      t
    ), this.authWindow.associatedEvent = t, this.resolver._originValidation(this.auth).catch((n) => {
      this.reject(n);
    }), this.resolver._isIframeWebStorageSupported(this.auth, (n) => {
      n || this.reject(Me(
        this.auth,
        "web-storage-unsupported"
        /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */
      ));
    }), this.pollUserCancellation();
  }
  get eventId() {
    var t;
    return ((t = this.authWindow) === null || t === void 0 ? void 0 : t.associatedEvent) || null;
  }
  cancel() {
    this.reject(Me(
      this.auth,
      "cancelled-popup-request"
      /* AuthErrorCode.EXPIRED_POPUP_REQUEST */
    ));
  }
  cleanUp() {
    this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, $n.currentPopupAction = null;
  }
  pollUserCancellation() {
    const t = () => {
      var n, r;
      if (!((r = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null || r === void 0) && r.closed) {
        this.pollId = window.setTimeout(
          () => {
            this.pollId = null, this.reject(Me(
              this.auth,
              "popup-closed-by-user"
              /* AuthErrorCode.POPUP_CLOSED_BY_USER */
            ));
          },
          2e3
          /* _Timeout.AUTH_EVENT */
        );
        return;
      }
      this.pollId = window.setTimeout(t, Wy.get());
    };
    t();
  }
}
$n.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zy = "pendingRedirect", pi = /* @__PURE__ */ new Map();
class Gy extends gd {
  constructor(t, n, r = !1) {
    super(t, [
      "signInViaRedirect",
      "linkViaRedirect",
      "reauthViaRedirect",
      "unknown"
      /* AuthEventType.UNKNOWN */
    ], n, void 0, r), this.eventId = null;
  }
  /**
   * Override the execute function; if we already have a redirect result, then
   * just return it.
   */
  async execute() {
    let t = pi.get(this.auth._key());
    if (!t) {
      try {
        const r = await qy(this.resolver, this.auth) ? await super.execute() : null;
        t = () => Promise.resolve(r);
      } catch (n) {
        t = () => Promise.reject(n);
      }
      pi.set(this.auth._key(), t);
    }
    return this.bypassAuthState || pi.set(this.auth._key(), () => Promise.resolve(null)), t();
  }
  async onAuthEvent(t) {
    if (t.type === "signInViaRedirect")
      return super.onAuthEvent(t);
    if (t.type === "unknown") {
      this.resolve(null);
      return;
    }
    if (t.eventId) {
      const n = await this.auth._redirectUserForId(t.eventId);
      if (n)
        return this.user = n, super.onAuthEvent(t);
      this.resolve(null);
    }
  }
  async onExecution() {
  }
  cleanUp() {
  }
}
async function qy(e, t) {
  const n = yd(t), r = pd(e);
  if (!await r._isAvailable())
    return !1;
  const i = await r._get(n) === "true";
  return await r._remove(n), i;
}
async function Ky(e, t) {
  return pd(e)._set(yd(t), "true");
}
function Jy(e, t) {
  pi.set(e._key(), t);
}
function pd(e) {
  return wt(e._redirectPersistence);
}
function yd(e) {
  return gi(zy, e.config.apiKey, e.name);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ks(e, t, n) {
  return Yy(e, t, n);
}
async function Yy(e, t, n) {
  const r = Xt(e);
  cp(e, t, Qi), await r._initializationPromise;
  const i = md(r, n);
  return await Ky(i, r), i._openRedirect(
    r,
    t,
    "signInViaRedirect"
    /* AuthEventType.SIGN_IN_VIA_REDIRECT */
  );
}
async function Xy(e, t, n = !1) {
  const r = Xt(e), i = md(r, t), o = await new Gy(r, i, n).execute();
  return o && !n && (delete o.user._redirectEventId, await r._persistUserIfCurrent(o.user), await r._setRedirectUser(null, t)), o;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Qy = 10 * 60 * 1e3;
class Zy {
  constructor(t) {
    this.auth = t, this.cachedEventUids = /* @__PURE__ */ new Set(), this.consumers = /* @__PURE__ */ new Set(), this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now();
  }
  registerConsumer(t) {
    this.consumers.add(t), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, t) && (this.sendToConsumer(this.queuedRedirectEvent, t), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null);
  }
  unregisterConsumer(t) {
    this.consumers.delete(t);
  }
  onEvent(t) {
    if (this.hasEventBeenHandled(t))
      return !1;
    let n = !1;
    return this.consumers.forEach((r) => {
      this.isEventForConsumer(t, r) && (n = !0, this.sendToConsumer(t, r), this.saveEventToCache(t));
    }), this.hasHandledPotentialRedirect || !e_(t) || (this.hasHandledPotentialRedirect = !0, n || (this.queuedRedirectEvent = t, n = !0)), n;
  }
  sendToConsumer(t, n) {
    var r;
    if (t.error && !_d(t)) {
      const i = ((r = t.error.code) === null || r === void 0 ? void 0 : r.split("auth/")[1]) || "internal-error";
      n.onError(Me(this.auth, i));
    } else
      n.onAuthEvent(t);
  }
  isEventForConsumer(t, n) {
    const r = n.eventId === null || !!t.eventId && t.eventId === n.eventId;
    return n.filter.includes(t.type) && r;
  }
  hasEventBeenHandled(t) {
    return Date.now() - this.lastProcessedEventTime >= Qy && this.cachedEventUids.clear(), this.cachedEventUids.has(Sl(t));
  }
  saveEventToCache(t) {
    this.cachedEventUids.add(Sl(t)), this.lastProcessedEventTime = Date.now();
  }
}
function Sl(e) {
  return [e.type, e.eventId, e.sessionId, e.tenantId].filter((t) => t).join("-");
}
function _d({ type: e, error: t }) {
  return e === "unknown" && (t == null ? void 0 : t.code) === "auth/no-auth-event";
}
function e_(e) {
  switch (e.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
      return !0;
    case "unknown":
      return _d(e);
    default:
      return !1;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function t_(e, t = {}) {
  return at(e, "GET", "/v1/projects", t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const n_ = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, r_ = /^https?/;
async function i_(e) {
  if (e.config.emulator)
    return;
  const { authorizedDomains: t } = await t_(e);
  for (const n of t)
    try {
      if (s_(n))
        return;
    } catch {
    }
  Ke(
    e,
    "unauthorized-domain"
    /* AuthErrorCode.INVALID_ORIGIN */
  );
}
function s_(e) {
  const t = to(), { protocol: n, hostname: r } = new URL(t);
  if (e.startsWith("chrome-extension://")) {
    const o = new URL(e);
    return o.hostname === "" && r === "" ? n === "chrome-extension:" && e.replace("chrome-extension://", "") === t.replace("chrome-extension://", "") : n === "chrome-extension:" && o.hostname === r;
  }
  if (!r_.test(n))
    return !1;
  if (n_.test(e))
    return r === e;
  const i = e.replace(/\./g, "\\.");
  return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(r);
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const o_ = new Fr(3e4, 6e4);
function El() {
  const e = he().___jsl;
  if (e != null && e.H) {
    for (const t of Object.keys(e.H))
      if (e.H[t].r = e.H[t].r || [], e.H[t].L = e.H[t].L || [], e.H[t].r = [...e.H[t].L], e.CP)
        for (let n = 0; n < e.CP.length; n++)
          e.CP[n] = null;
  }
}
function a_(e) {
  return new Promise((t, n) => {
    var r, i, s;
    function o() {
      El(), gapi.load("gapi.iframes", {
        callback: () => {
          t(gapi.iframes.getContext());
        },
        ontimeout: () => {
          El(), n(Me(
            e,
            "network-request-failed"
            /* AuthErrorCode.NETWORK_REQUEST_FAILED */
          ));
        },
        timeout: o_.get()
      });
    }
    if (!((i = (r = he().gapi) === null || r === void 0 ? void 0 : r.iframes) === null || i === void 0) && i.Iframe)
      t(gapi.iframes.getContext());
    else if (!((s = he().gapi) === null || s === void 0) && s.load)
      o();
    else {
      const a = hd("iframefcb");
      return he()[a] = () => {
        gapi.load ? o() : n(Me(
          e,
          "network-request-failed"
          /* AuthErrorCode.NETWORK_REQUEST_FAILED */
        ));
      }, fd(`https://apis.google.com/js/api.js?onload=${a}`).catch((l) => n(l));
    }
  }).catch((t) => {
    throw yi = null, t;
  });
}
let yi = null;
function l_(e) {
  return yi = yi || a_(e), yi;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const c_ = new Fr(5e3, 15e3), u_ = "__/auth/iframe", d_ = "emulator/auth/iframe", f_ = {
  style: {
    position: "absolute",
    top: "-100px",
    width: "1px",
    height: "1px"
  },
  "aria-hidden": "true",
  tabindex: "-1"
}, h_ = /* @__PURE__ */ new Map([
  ["identitytoolkit.googleapis.com", "p"],
  ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
  ["test-identitytoolkit.sandbox.googleapis.com", "t"]
  // test
]);
function v_(e) {
  const t = e.config;
  L(
    t.authDomain,
    e,
    "auth-domain-config-required"
    /* AuthErrorCode.MISSING_AUTH_DOMAIN */
  );
  const n = t.emulator ? Wo(t, d_) : `https://${e.config.authDomain}/${u_}`, r = {
    apiKey: t.apiKey,
    appName: e.name,
    v: Yi
  }, i = h_.get(e.config.apiHost);
  i && (r.eid = i);
  const s = e._getFrameworks();
  return s.length && (r.fw = s.join(",")), `${n}?${Kn(r).slice(1)}`;
}
async function m_(e) {
  const t = await l_(e), n = he().gapi;
  return L(
    n,
    e,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), t.open({
    where: document.body,
    url: v_(e),
    messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
    attributes: f_,
    dontclear: !0
  }, (r) => new Promise(async (i, s) => {
    await r.restyle({
      // Prevent iframe from closing on mouse out.
      setHideOnLeave: !1
    });
    const o = Me(
      e,
      "network-request-failed"
      /* AuthErrorCode.NETWORK_REQUEST_FAILED */
    ), a = he().setTimeout(() => {
      s(o);
    }, c_.get());
    function l() {
      he().clearTimeout(a), i(r);
    }
    r.ping(l).then(l, () => {
      s(o);
    });
  }));
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const g_ = {
  location: "yes",
  resizable: "yes",
  statusbar: "yes",
  toolbar: "no"
}, p_ = 500, y_ = 600, __ = "_blank", b_ = "http://localhost";
class Il {
  constructor(t) {
    this.window = t, this.associatedEvent = null;
  }
  close() {
    if (this.window)
      try {
        this.window.close();
      } catch {
      }
  }
}
function w_(e, t, n, r = p_, i = y_) {
  const s = Math.max((window.screen.availHeight - i) / 2, 0).toString(), o = Math.max((window.screen.availWidth - r) / 2, 0).toString();
  let a = "";
  const l = Object.assign(Object.assign({}, g_), {
    width: r.toString(),
    height: i.toString(),
    top: s,
    left: o
  }), c = Ee().toLowerCase();
  n && (a = Gu(c) ? __ : n), zu(c) && (t = t || b_, l.scrollbars = "yes");
  const d = Object.entries(l).reduce((f, [h, m]) => `${f}${h}=${m},`, "");
  if (Tp(c) && a !== "_self")
    return S_(t || "", a), new Il(null);
  const u = window.open(t || "", a, d);
  L(
    u,
    e,
    "popup-blocked"
    /* AuthErrorCode.POPUP_BLOCKED */
  );
  try {
    u.focus();
  } catch {
  }
  return new Il(u);
}
function S_(e, t) {
  const n = document.createElement("a");
  n.href = e, n.target = t;
  const r = document.createEvent("MouseEvent");
  r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const E_ = "__/auth/handler", I_ = "emulator/auth/handler";
function Cl(e, t, n, r, i, s) {
  L(
    e.config.authDomain,
    e,
    "auth-domain-config-required"
    /* AuthErrorCode.MISSING_AUTH_DOMAIN */
  ), L(
    e.config.apiKey,
    e,
    "invalid-api-key"
    /* AuthErrorCode.INVALID_API_KEY */
  );
  const o = {
    apiKey: e.config.apiKey,
    appName: e.name,
    authType: n,
    redirectUrl: r,
    v: Yi,
    eventId: i
  };
  if (t instanceof Qi) {
    t.setDefaultLanguage(e.languageCode), o.providerId = t.providerId || "", Xm(t.getCustomParameters()) || (o.customParameters = JSON.stringify(t.getCustomParameters()));
    for (const [l, c] of Object.entries(s || {}))
      o[l] = c;
  }
  if (t instanceof Hr) {
    const l = t.getScopes().filter((c) => c !== "");
    l.length > 0 && (o.scopes = l.join(","));
  }
  e.tenantId && (o.tid = e.tenantId);
  const a = o;
  for (const l of Object.keys(a))
    a[l] === void 0 && delete a[l];
  return `${C_(e)}?${Kn(a).slice(1)}`;
}
function C_({ config: e }) {
  return e.emulator ? Wo(e, I_) : `https://${e.authDomain}/${E_}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ts = "webStorageSupport";
class k_ {
  constructor() {
    this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = Ko, this._completeRedirectFn = Xy, this._overrideRedirectResult = Jy;
  }
  // Wrapping in async even though we don't await anywhere in order
  // to make sure errors are raised as promise rejections
  async _openPopup(t, n, r, i) {
    var s;
    kt((s = this.eventManagers[t._key()]) === null || s === void 0 ? void 0 : s.manager, "_initialize() not called before _openPopup()");
    const o = Cl(t, n, r, to(), i);
    return w_(t, o, Jo());
  }
  async _openRedirect(t, n, r, i) {
    return await this._originValidation(t), fy(Cl(t, n, r, to(), i)), new Promise(() => {
    });
  }
  _initialize(t) {
    const n = t._key();
    if (this.eventManagers[n]) {
      const { manager: i, promise: s } = this.eventManagers[n];
      return i ? Promise.resolve(i) : (kt(s, "If manager is not set, promise should be"), s);
    }
    const r = this.initAndGetManager(t);
    return this.eventManagers[n] = { promise: r }, r.catch(() => {
      delete this.eventManagers[n];
    }), r;
  }
  async initAndGetManager(t) {
    const n = await m_(t), r = new Zy(t);
    return n.register("authEvent", (i) => (L(
      i == null ? void 0 : i.authEvent,
      t,
      "invalid-auth-event"
      /* AuthErrorCode.INVALID_AUTH_EVENT */
    ), {
      status: r.onEvent(i.authEvent) ? "ACK" : "ERROR"
      /* GapiOutcome.ERROR */
    }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[t._key()] = { manager: r }, this.iframes[t._key()] = n, r;
  }
  _isIframeWebStorageSupported(t, n) {
    this.iframes[t._key()].send(Ts, { type: Ts }, (i) => {
      var s;
      const o = (s = i == null ? void 0 : i[0]) === null || s === void 0 ? void 0 : s[Ts];
      o !== void 0 && n(!!o), Ke(
        t,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
  }
  _originValidation(t) {
    const n = t._key();
    return this.originValidationPromises[n] || (this.originValidationPromises[n] = i_(t)), this.originValidationPromises[n];
  }
  get _shouldInitProactively() {
    return Xu() || Go() || Xi();
  }
}
const T_ = k_;
var kl = "@firebase/auth", Tl = "0.22.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class O_ {
  constructor(t) {
    this.auth = t, this.internalListeners = /* @__PURE__ */ new Map();
  }
  getUid() {
    var t;
    return this.assertAuthConfigured(), ((t = this.auth.currentUser) === null || t === void 0 ? void 0 : t.uid) || null;
  }
  async getToken(t) {
    return this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser ? { accessToken: await this.auth.currentUser.getIdToken(t) } : null;
  }
  addAuthTokenListener(t) {
    if (this.assertAuthConfigured(), this.internalListeners.has(t))
      return;
    const n = this.auth.onIdTokenChanged((r) => {
      t((r == null ? void 0 : r.stsTokenManager.accessToken) || null);
    });
    this.internalListeners.set(t, n), this.updateProactiveRefresh();
  }
  removeAuthTokenListener(t) {
    this.assertAuthConfigured();
    const n = this.internalListeners.get(t);
    n && (this.internalListeners.delete(t), n(), this.updateProactiveRefresh());
  }
  assertAuthConfigured() {
    L(
      this.auth._initializationPromise,
      "dependent-sdk-initialized-before-auth"
      /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
    );
  }
  updateProactiveRefresh() {
    this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function A_(e) {
  switch (e) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    default:
      return;
  }
}
function N_(e) {
  Tr(new jn(
    "auth",
    (t, { options: n }) => {
      const r = t.getProvider("app").getImmediate(), i = t.getProvider("heartbeat"), { apiKey: s, authDomain: o } = r.options;
      return ((a, l) => {
        L(s && !s.includes(":"), "invalid-api-key", { appName: a.name }), L(!(o != null && o.includes(":")), "argument-error", {
          appName: a.name
        });
        const c = {
          apiKey: s,
          authDomain: o,
          clientPlatform: e,
          apiHost: "identitytoolkit.googleapis.com",
          tokenApiHost: "securetoken.googleapis.com",
          apiScheme: "https",
          sdkClientVersion: Qu(e)
        }, d = new Pp(a, l, c);
        return dp(d, n), d;
      })(r, i);
    },
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  ).setInstanceCreatedCallback((t, n, r) => {
    t.getProvider(
      "auth-internal"
      /* _ComponentName.AUTH_INTERNAL */
    ).initialize();
  })), Tr(new jn(
    "auth-internal",
    (t) => {
      const n = Xt(t.getProvider(
        "auth"
        /* _ComponentName.AUTH */
      ).getImmediate());
      return ((r) => new O_(r))(n);
    },
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  )), hr(kl, Tl, A_(e)), hr(kl, Tl, "esm2017");
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const P_ = 5 * 60, R_ = Au("authIdTokenMaxAge") || P_;
let Ol = null;
const x_ = (e) => async (t) => {
  const n = t && await t.getIdTokenResult(), r = n && ((/* @__PURE__ */ new Date()).getTime() - Date.parse(n.issuedAtTime)) / 1e3;
  if (r && r > R_)
    return;
  const i = n == null ? void 0 : n.token;
  Ol !== i && (Ol = i, await fetch(e, {
    method: i ? "POST" : "DELETE",
    headers: i ? {
      Authorization: `Bearer ${i}`
    } : {}
  }));
};
function De(e = Qg()) {
  const t = xu(e, "auth");
  if (t.isInitialized())
    return t.getImmediate();
  const n = up(e, {
    popupRedirectResolver: T_,
    persistence: [
      wy,
      ad,
      Ko
    ]
  }), r = Au("authTokenSyncURL");
  if (r) {
    const s = x_(r);
    sy(n, s, () => s(n.currentUser)), iy(n, (o) => s(o));
  }
  const i = Bm("auth");
  return i && Rp(n, `http://${i}`), n;
}
N_(
  "Browser"
  /* ClientPlatform.BROWSER */
);
const V_ = Cn(), D_ = {
  getError: (e) => e.error,
  getSessionPersistence: (e) => e.is_session_persistant,
  getCurrentUser: (e) => e.current_user,
  getUid: (e) => {
    var t;
    return ((t = e == null ? void 0 : e.current_user) == null ? void 0 : t.uid) || null;
  },
  getDisplayName: (e) => {
    var t;
    return ((t = e == null ? void 0 : e.current_user) == null ? void 0 : t.displayName) || null;
  },
  getEmail: (e) => {
    var t;
    return ((t = e == null ? void 0 : e.current_user) == null ? void 0 : t.email) || null;
  },
  getPhotoURL: (e) => {
    var t;
    return ((t = e == null ? void 0 : e.current_user) == null ? void 0 : t.photoURL) || null;
  },
  getPhoneNumber: (e) => {
    var t;
    return ((t = e == null ? void 0 : e.current_user) == null ? void 0 : t.phoneNumber) || null;
  },
  getMetadata: () => {
    const e = De(V_.config.globalProperties.$authGuardFirebaseApp).currentUser;
    return e ? e.metadata : null;
  },
  isLoading: (e) => e.is_loading,
  isAuthenticated: (e) => !!(e != null && e.current_user),
  isAnonymous: (e) => {
    var t;
    return ((t = e == null ? void 0 : e.current_user) == null ? void 0 : t.isAnonymous) || null;
  },
  isVerified: (e) => {
    var t;
    return ((t = e == null ? void 0 : e.current_user) == null ? void 0 : t.emailVerified) || null;
  },
  isRoutePublic: (e) => e.is_route_public,
  isFromPublicToAuth: (e) => e.is_from_public_to_auth,
  isUserRegistrationAllowed: (e) => e.config.registration,
  isEmailVerificationRequired: (e) => e.config.verification,
  isEmailVerificationScrenShown: (e) => e.is_email_verification_screen_shown,
  isEmailVerificationLinkSent: (e) => e.is_email_verification_link_sent,
  isEmailResetPasswordLinkSent: (e) => e.is_email_reset_password_link_sent,
  isResetPasswordScreenShown: (e) => e.is_reset_password_screen_shown,
  isLoginWithPhoneShown: (e) => e.is_login_with_phone_shown,
  isLoginWithProvidersActive: (e) => e.config.google || e.config.facebook || e.config.phone || e.config.saml,
  isOnlySingleProvider: (e) => {
    let t = 0;
    return ["google", "facebook", "phone", "saml"].forEach((r) => {
      e.config[r] === !0 && t++;
    }), t === 1;
  }
};
/*!
  * vue-router v4.1.6
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
var Al;
(function(e) {
  e.pop = "pop", e.push = "push";
})(Al || (Al = {}));
var Nl;
(function(e) {
  e.back = "back", e.forward = "forward", e.unknown = "";
})(Nl || (Nl = {}));
var Pl;
(function(e) {
  e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated";
})(Pl || (Pl = {}));
const L_ = Symbol({}.NODE_ENV !== "production" ? "router" : ""), $_ = Symbol({}.NODE_ENV !== "production" ? "route location" : "");
function M_() {
  return me(L_);
}
function B_() {
  return me($_);
}
const ct = (...e) => {
  Xe().config.debug && console.log.apply(console, e);
}, Qo = () => {
  const e = Xe();
  ct("[ auth check ]: execution started...");
  let t = !1;
  const r = De(e.config.firebase).currentUser, i = !!r, s = e.config.verification, o = e.is_route_public, a = e.is_from_public_to_auth;
  if (s && ct("[ auth check ]: email verification required: [", s, "]"), s && r && r.isAnonymous)
    ct("[ auth check ]: anonymous user BLOCKED unable to verify email!"), e.is_authguard_dialog_shown = !0, e.is_authguard_dialog_persistent = !1;
  else if (o)
    t = !0, e.is_authguard_dialog_shown = !1, e.is_authguard_dialog_persistent = !1;
  else if (!o && a && !i)
    e.is_authguard_dialog_shown = !0, e.is_authguard_dialog_persistent = !1;
  else if (i) {
    ct("[ auth check ]: authenticated currentUser ID: [", r.uid, "]");
    let l = r.emailVerified || !1;
    const c = r.email ? r.email.split("@")[1] : "";
    ct("[ auth check ]: user email verified: [", l, "]"), t = l, s === !1 ? (ct("[ auth check ]: authguard config does not require email verification"), t = !0) : Array.isArray(s) && !s.includes(c) ? (ct(
      "[ auth check ]: user email domain: [",
      c,
      "] not included on domain list that requires email verification to authenticate:",
      s
    ), t = !0) : (ct("[ auth check ]: authguard config requires email verification"), e.error = null, e.is_email_verification_screen_shown = !0), t ? (e.is_authguard_dialog_shown = !1, e.is_authguard_dialog_persistent = !1) : (e.is_authguard_dialog_shown = !0, a ? e.is_authguard_dialog_persistent = !1 : e.is_authguard_dialog_persistent = !0);
  } else
    ct("[ auth check ]: currentUser is NOT authenticated"), e.is_authguard_dialog_shown = !0, e.is_authguard_dialog_persistent = !1;
  return ct("[ auth check ]: is route ALLOWED: [", t, "]"), t;
}, F_ = {
  SET_EMAIL_VERIFICATION_SCREEN_SHOWN(e) {
    this.is_email_verification_screen_shown = e, e === !1 && (this.error = null);
  },
  SET_PASSWORD_RESET_SCREEN_SHOWN(e) {
    this.tab = e ? 1 : 0, this.is_reset_password_screen_shown = e, e === !1 && (this.is_email_reset_password_link_sent = !1);
  },
  SET_SHOW_LOGIN_WITH_PHONE(e) {
    this.tab = 0, this.is_login_with_phone_shown = e, e === !1 && (this.sign_by_phone_step = 1);
  },
  authGuardOnRouterReady() {
    this.config.debug && console.log("[ auth guard ]: revalidate when vue router ready");
  },
  //
  initializeGuard() {
    const e = this.config.debug, t = De(this.config.firebase).currentUser;
    if (t) {
      const { uid: n, displayName: r, email: i, emailVerified: s, isAnonymous: o, phoneNumber: a, photoURL: l } = t, c = { uid: n, displayName: r, email: i, emailVerified: s, isAnonymous: o, phoneNumber: a, photoURL: l };
      this.current_user = { ...c };
    } else
      this.current_user = null;
    e && console.log("[ auth guard ]: component initialized for user: [", t ? t.uid : null, "]"), this.is_email_verification_screen_shown = !1, Qo(), this.authGuardOnRouterReady();
  },
  //
  loginWithEmail({ email: e, password: t }) {
    return new Promise(async (n, r) => {
      try {
        const i = De(this.config.firebase), s = M_();
        return this.is_loading = !0, await _l(i), this.config.session === "browser" ? await yl(i, Ko) : await yl(i, ad), await gl(i, e, t), s.currentRoute.name === null && s.push(s.currentRoute.path).catch(() => {
        }), this.is_loading = !1, n();
      } catch (i) {
        return this.error = i, this.is_loading = !1, r();
      }
    });
  },
  //
  loginWithGoogle() {
    const e = new _t(), t = De(this.config.firebase);
    ks(t, e);
  },
  //
  loginWithFacebook() {
    const e = new yt(), t = De(this.config.firebase);
    ks(t, e);
  },
  //
  loginWithPhone() {
  },
  loginWithSaml() {
    const e = new Vi(this.config.saml_provider_id), t = De(this.config.firebase);
    ks(t, e);
  },
  //
  async textPhoneVerificationCode({ phoneNumber: e, recaptchaVerifier: t }) {
    try {
      this.is_loading = !0, this.text_confirmation = null;
      const n = "+1" + e.replace(/\D/g, ""), r = De(this.config.firebase), i = await By(r, n, t);
      this.is_loading = !1, this.sign_by_phone_step = 2, this.text_confirmation = i;
    } catch (n) {
      this.error = n, this.is_loading = !1;
    }
  },
  //
  async confirmCode(e) {
    try {
      this.is_loading = !0, console.log("confirmationCode", e.join()), await this.text_confirmation.confirm(e.join()), this.is_loading = !1, this.sign_by_phone_step = 1;
    } catch (t) {
      this.error = t, this.is_loading = !1, this.sign_by_phone_step = 1;
    }
  },
  //
  async registerUser({ displayName: e, email: t, password: n }) {
    try {
      this.is_loading = !0;
      const r = this.config.email, i = De(this.config.firebase);
      await ty(i, t, n), await gl(i, t, n), await ry(i.currentUser, { displayName: e });
      const s = "XXX";
      (r === !0 || Array.isArray(r) && r.includes(s)) && await pl(i.currentUser), this.is_loading = !1;
    } catch (r) {
      this.error = r, this.is_loading = !1;
    }
  },
  async emailPasswordResetLink(e) {
    try {
      this.is_loading = !0;
      const t = De(this.config.firebase);
      await ey(t, e), this.error = !1, this.is_loading = !1, this.is_email_reset_password_link_sent = !0;
    } catch (t) {
      this.error = t, this.is_loading = !1;
    }
  },
  //
  signOut() {
    const e = this.config.debug, t = De(this.config.firebase);
    return e && console.log("[ auth guard ]: signOut request"), _l(t);
  },
  //
  sendVerificationEmail() {
    return new Promise(async (e, t) => {
      try {
        this.is_loading = !0;
        const n = De(this.config.firebase);
        return await pl(n.currentUser), this.is_loading = !1, this.is_email_verification_link_sent = !0, e();
      } catch (n) {
        return this.error = n, this.is_loading = !1, t();
      }
    });
  }
}, Xe = Nm("auth", {
  state: Pm,
  getters: D_,
  actions: F_
});
function Rl(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rl(Object(n), !0).forEach(function(r) {
      bd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rl(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function pr(e) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? pr = function(t) {
    return typeof t;
  } : pr = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, pr(e);
}
function bd(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var wd = "_", U_ = "function", H_ = [];
function j_() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : H_, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : wd;
  if (!Sd(e))
    throw new Error("Text-mask:convertMaskToPlaceholder; The mask property must be an array.");
  if (e.indexOf(t) !== -1)
    throw new Error(`Placeholder character must not be used as part of the mask. Please specify a character that is not present in your mask as your placeholder character.

` + "The placeholder character that was received is: ".concat(JSON.stringify(t), `

`) + "The mask that was received is: ".concat(JSON.stringify(e)));
  return e.map(function(n) {
    return n instanceof RegExp ? t : n;
  }).join("");
}
function Sd(e) {
  return Array.isArray && Array.isArray(e) || e instanceof Array;
}
var W_ = "[]";
function z_(e) {
  for (var t = [], n; n = e.indexOf(W_), n !== -1; )
    t.push(n), e.splice(n, 1);
  return {
    maskWithoutCaretTraps: e,
    indexes: t
  };
}
var G_ = [], nn = "";
function Ed() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : nn, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : G_, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!Sd(t))
    if (pr(t) === U_)
      t = t(e, n), t = z_(t).maskWithoutCaretTraps;
    else
      throw new Error("Text-mask:conformToMask; The mask property must be an array.");
  var r = n.guide, i = r === void 0 ? !0 : r, s = n.previousConformedValue, o = s === void 0 ? nn : s, a = n.placeholderChar, l = a === void 0 ? wd : a, c = n.placeholder, d = c === void 0 ? j_(t, l) : c, u = n.currentCaretPosition, f = n.keepCharPositions, h = i === !1 && o !== void 0, m = e.length, g = o.length, w = d.length, C = t.length, E = m - g, p = E > 0, O = u + (p ? -E : 0), A = O + Math.abs(E);
  if (f === !0 && !p) {
    for (var N = nn, I = O; I < A; I++)
      d[I] === l && (N += l);
    e = e.slice(0, O) + N + e.slice(O, m);
  }
  for (var _ = e.split(nn).map(function(en, ce) {
    return {
      char: en,
      isNew: ce >= O && ce < A
    };
  }), b = m - 1; b >= 0; b--) {
    var S = _[b].char;
    if (S !== l) {
      var P = b >= O && g === C;
      S === d[P ? b - E : b] && _.splice(b, 1);
    }
  }
  var k = nn, R = !1;
  e:
    for (var x = 0; x < w; x++) {
      var j = d[x];
      if (j === l) {
        if (_.length > 0)
          for (; _.length > 0; ) {
            var G = _.shift(), M = G.char, ee = G.isNew;
            if (M === l && h !== !0) {
              k += l;
              continue e;
            } else if (t[x].test(M)) {
              if (f !== !0 || ee === !1 || o === nn || i === !1 || !p)
                k += M;
              else {
                for (var Z = _.length, $ = null, W = 0; W < Z; W++) {
                  var ae = _[W];
                  if (ae.char !== l && ae.isNew === !1)
                    break;
                  if (ae.char === l) {
                    $ = W;
                    break;
                  }
                }
                $ !== null ? (k += M, _.splice($, 1)) : x--;
              }
              continue e;
            } else
              R = !0;
          }
        h === !1 && (k += d.substr(x, w));
        break;
      } else
        k += j;
    }
  if (h && p === !1) {
    for (var Qe = null, Ze = 0; Ze < k.length; Ze++)
      d[Ze] === l && (Qe = Ze);
    Qe !== null ? k = k.substr(0, Qe + 1) : k = nn;
  }
  return {
    conformedValue: k,
    meta: {
      someCharsRejected: R
    }
  };
}
var ro = {
  __nextCharOptional__: !0
}, ts = {
  "#": /\d/,
  A: /[a-z]/i,
  N: /[a-z0-9]/i,
  "?": ro,
  X: /./
}, q_ = function(t) {
  var n = t.lastIndexOf("/");
  return new RegExp(t.slice(1, n), t.slice(n + 1));
}, K_ = function(t) {
  return q_(t.toString().replace(/.(\/)[gmiyus]{0,6}$/, function(n) {
    return n.replace("/", "?/");
  }));
}, J_ = function(t) {
  return "[\\^$.|?*+()".indexOf(t) > -1 ? "\\".concat(t) : t;
}, Y_ = function(t) {
  return new RegExp("/[".concat(J_(t), "]/"));
}, X_ = function(t) {
  return t instanceof RegExp;
}, Q_ = function(t) {
  return X_(t) ? t : Y_(t);
};
function Id(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ts;
  return e.map(function(n, r, i) {
    var s = t[n] || n, o = i[r - 1], a = t[o] || o;
    return s === ro ? null : a === ro ? K_(Q_(s)) : s;
  }).filter(Boolean);
}
function Z_(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ts;
  return Id(e.split(""), t);
}
function eb(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ts, n = e.map(function(r) {
    return r instanceof RegExp ? r : typeof r == "string" ? r.split("") : null;
  }).filter(Boolean).reduce(function(r, i) {
    return r.concat(i);
  }, []);
  return Id(n, t);
}
var tb = function(t, n) {
  var r = document.createEvent("HTMLEvents");
  r.initEvent(n, !0, !0), t.dispatchEvent(r);
}, Os = function(t) {
  return t instanceof HTMLInputElement ? t : t.querySelector("input") || t;
}, Cd = function(t) {
  return typeof t == "function";
}, Zo = function(t) {
  return typeof t == "string";
}, nb = function(t) {
  return t instanceof RegExp;
};
function kd(e, t) {
  return Array.isArray(e) ? eb(e, t) : Cd(e) ? e : Zo(e) && e.length > 0 ? Z_(e, t) : e;
}
function rb() {
  var e = /* @__PURE__ */ new Map(), t = {
    previousValue: "",
    mask: []
  };
  function n(s) {
    return e.get(s) || gr({}, t);
  }
  function r(s, o) {
    e.set(s, gr(gr({}, n(s)), o));
  }
  function i(s) {
    e.delete(s);
  }
  return {
    partiallyUpdate: r,
    remove: i,
    get: n
  };
}
function Td(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ts;
  return e === null || Array.isArray(e) || pr(e) !== "object" ? t : Object.keys(e).reduce(function(n, r) {
    var i = e[r];
    return i !== null && !(i instanceof RegExp) ? n : gr(gr({}, n), {}, bd({}, r, i));
  }, t);
}
var Mi = rb();
function ib(e) {
  tb(e, "input");
}
function xl(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = e.value, r = Mi.get(e), i = r.previousValue, s = r.mask, o = n !== i, a = n.length > i.length, l = n && o && a;
  if ((t || l) && s) {
    var c = Ed(n, s, {
      guide: !1
    }), d = c.conformedValue;
    e.value = d, ib(e);
  }
  Mi.partiallyUpdate(e, {
    previousValue: n
  });
}
function Vl(e, t, n) {
  var r = kd(t, n);
  Mi.partiallyUpdate(e, {
    mask: r
  });
}
function Dl(e) {
  var t = Array.isArray(e) ? e : [e], n = t.filter(function(r) {
    return Zo(r) || nb(r);
  });
  return n.toString();
}
function sb() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = Td(e && e.placeholders);
  return {
    bind: function(r, i) {
      var s = i.value;
      r = Os(r), Vl(r, s, t), xl(r);
    },
    componentUpdated: function(r, i) {
      var s = i.value, o = i.oldValue;
      r = Os(r);
      var a = Cd(s) || Dl(o) !== Dl(s);
      a && Vl(r, s, t), xl(r, a);
    },
    unbind: function(r) {
      r = Os(r), Mi.remove(r);
    }
  };
}
var ob = sb();
function ab() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = Td(e && e.placeholders);
  return function(n, r) {
    if (!Zo(n) && !Number.isFinite(n))
      return n;
    var i = kd(r, t), s = Ed("".concat(n), i, {
      guide: !1
    }), o = s.conformedValue;
    return o;
  };
}
ab();
const lb = {
  debug: !1,
  store: null,
  // vuex store
  router: null,
  // routes
  firebase: null,
  // pass on firebase middleware app init
  session: "local",
  saml: !1,
  // allow authentication with saml
  saml_text: "Login with SAML",
  // saml button text
  saml_provider_id: "saml.okta",
  // saml provider id
  email: !0,
  // allow authentication with email
  phone: !1,
  // allow authentication with phone
  google: !1,
  // allow authentication with gmail account
  facebook: !1,
  // allow authentication with facebook account
  title: "Authenticate",
  subtitle: "Firebase Vuetify Authentication NPM package",
  icon: "mdi-brightness-7",
  // authentication prompt icon
  iconColor: "orange",
  // authentication prompt icon color
  verification: !1,
  // require user email to be verified before granting access
  registration: !0
  // allow new user registrations
};
function Od(e, t, n) {
  const r = t.length - 1;
  if (r < 0)
    return e === void 0 ? n : e;
  for (let i = 0; i < r; i++) {
    if (e == null)
      return n;
    e = e[t[i]];
  }
  return e == null || e[t[r]] === void 0 ? n : e[t[r]];
}
function ea(e, t) {
  if (e === t)
    return !0;
  if (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime() || e !== Object(e) || t !== Object(t))
    return !1;
  const n = Object.keys(e);
  return n.length !== Object.keys(t).length ? !1 : n.every((r) => ea(e[r], t[r]));
}
function cb(e, t, n) {
  return e == null || !t || typeof t != "string" ? n : e[t] !== void 0 ? e[t] : (t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, ""), Od(e, t.split("."), n));
}
function nr(e, t, n) {
  if (t == null)
    return e === void 0 ? n : e;
  if (e !== Object(e)) {
    if (typeof t != "function")
      return n;
    const i = t(e, n);
    return typeof i > "u" ? n : i;
  }
  if (typeof t == "string")
    return cb(e, t, n);
  if (Array.isArray(t))
    return Od(e, t, n);
  if (typeof t != "function")
    return n;
  const r = t(e, n);
  return typeof r > "u" ? n : r;
}
function Y(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (!(e == null || e === ""))
    return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0;
}
function io(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function ub(e) {
  return e == null ? void 0 : e.$el;
}
const Ll = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
});
function Ad(e) {
  return Object.keys(e);
}
function Wr(e, t) {
  const n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (const i in e)
    t.some((s) => s instanceof RegExp ? s.test(i) : s === i) ? n[i] = e[i] : r[i] = e[i];
  return [n, r];
}
function ta(e, t) {
  const n = {
    ...e
  };
  return t.forEach((r) => delete n[r]), n;
}
function na(e) {
  return Wr(e, ["class", "style", "id", /^data-/]);
}
function mn(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function so(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(t, Math.min(n, e));
}
function Bi() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  const r = {};
  for (const i in e)
    r[i] = e[i];
  for (const i in t) {
    const s = e[i], o = t[i];
    if (io(s) && io(o)) {
      r[i] = Bi(s, o, n);
      continue;
    }
    if (Array.isArray(s) && Array.isArray(o) && n) {
      r[i] = n(s, o);
      continue;
    }
    r[i] = o;
  }
  return r;
}
function Ut() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (Ut.cache.has(e))
    return Ut.cache.get(e);
  const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return Ut.cache.set(e, t), t;
}
Ut.cache = /* @__PURE__ */ new Map();
function _i(e, t) {
  if (!t || typeof t != "object")
    return [];
  if (Array.isArray(t))
    return t.map((n) => _i(e, n)).flat(1);
  if (Array.isArray(t.children))
    return t.children.map((n) => _i(e, n)).flat(1);
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e))
      return [t.component];
    if (t.component.subTree)
      return _i(e, t.component.subTree).flat(1);
  }
  return [];
}
function ra(e) {
  const t = In({}), n = y(e);
  return Gn(() => {
    for (const r in n.value)
      t[r] = n.value[r];
  }, {
    flush: "sync"
  }), ki(t);
}
function Fi(e, t) {
  return e.includes(t);
}
const db = /^on[^a-z]/, Nd = (e) => db.test(e), gn = [Function, Array];
function $l(e, t) {
  return t = "on" + ht(t), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`]);
}
function fb(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  if (Array.isArray(e))
    for (const i of e)
      i(...n);
  else
    typeof e == "function" && e(...n);
}
const Pd = ["top", "bottom"], hb = ["start", "end", "left", "right"];
function oo(e, t) {
  let [n, r] = e.split(" ");
  return r || (r = Fi(Pd, n) ? "start" : Fi(hb, n) ? "top" : "center"), {
    side: Ml(n, t),
    align: Ml(r, t)
  };
}
function Ml(e, t) {
  return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e;
}
function As(e) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.side],
    align: e.align
  };
}
function Ns(e) {
  return {
    side: e.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.align]
  };
}
function Bl(e) {
  return {
    side: e.align,
    align: e.side
  };
}
function Fl(e) {
  return Fi(Pd, e.side) ? "y" : "x";
}
class Un {
  constructor(t) {
    let {
      x: n,
      y: r,
      width: i,
      height: s
    } = t;
    this.x = n, this.y = r, this.width = i, this.height = s;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function Ul(e, t) {
  return {
    x: {
      before: Math.max(0, t.left - e.left),
      after: Math.max(0, e.right - t.right)
    },
    y: {
      before: Math.max(0, t.top - e.top),
      after: Math.max(0, e.bottom - t.bottom)
    }
  };
}
function ia(e) {
  const t = e.getBoundingClientRect(), n = getComputedStyle(e), r = n.transform;
  if (r) {
    let i, s, o, a, l;
    if (r.startsWith("matrix3d("))
      i = r.slice(9, -1).split(/, /), s = +i[0], o = +i[5], a = +i[12], l = +i[13];
    else if (r.startsWith("matrix("))
      i = r.slice(7, -1).split(/, /), s = +i[0], o = +i[3], a = +i[4], l = +i[5];
    else
      return new Un(t);
    const c = n.transformOrigin, d = t.x - a - (1 - s) * parseFloat(c), u = t.y - l - (1 - o) * parseFloat(c.slice(c.indexOf(" ") + 1)), f = s ? t.width / s : e.offsetWidth + 1, h = o ? t.height / o : e.offsetHeight + 1;
    return new Un({
      x: d,
      y: u,
      width: f,
      height: h
    });
  } else
    return new Un(t);
}
function cn(e, t, n) {
  if (typeof e.animate > "u")
    return {
      finished: Promise.resolve()
    };
  let r;
  try {
    r = e.animate(t, n);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof r.finished > "u" && (r.finished = new Promise((i) => {
    r.onfinish = () => {
      i(r);
    };
  })), r;
}
function Rd(e, t, n) {
  if (n && (t = {
    __isVue: !0,
    $parent: n,
    $options: t
  }), t) {
    if (t.$_alreadyWarned = t.$_alreadyWarned || [], t.$_alreadyWarned.includes(e))
      return;
    t.$_alreadyWarned.push(e);
  }
  return `[Vuetify] ${e}` + (t ? pb(t) : "");
}
function sa(e, t, n) {
  const r = Rd(e, t, n);
  r != null && console.warn(r);
}
function vb(e, t, n) {
  const r = Rd(e, t, n);
  r != null && console.error(r);
}
const mb = /(?:^|[-_])(\w)/g, gb = (e) => e.replace(mb, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function Ps(e, t) {
  if (e.$root === e)
    return "<Root>";
  const n = typeof e == "function" && e.cid != null ? e.options : e.__isVue ? e.$options || e.constructor.options : e || {};
  let r = n.name || n._componentTag;
  const i = n.__file;
  if (!r && i) {
    const s = i.match(/([^/\\]+)\.vue$/);
    r = s == null ? void 0 : s[1];
  }
  return (r ? `<${gb(r)}>` : "<Anonymous>") + (i && t !== !1 ? ` at ${i}` : "");
}
function pb(e) {
  if (e.__isVue && e.$parent) {
    const t = [];
    let n = 0;
    for (; e; ) {
      if (t.length > 0) {
        const r = t[t.length - 1];
        if (r.constructor === e.constructor) {
          n++, e = e.$parent;
          continue;
        } else
          n > 0 && (t[t.length - 1] = [r, n], n = 0);
      }
      t.push(e), e = e.$parent;
    }
    return `

found in

` + t.map((r, i) => `${i === 0 ? "---> " : " ".repeat(5 + i * 2)}${Array.isArray(r) ? `${Ps(r[0])}... (${r[1]} recursive calls)` : Ps(r)}`).join(`
`);
  } else
    return `

(found in ${Ps(e)})`;
}
function Hl(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e);
}
function Ue(e, t) {
  const n = Cn();
  if (!n)
    throw new Error(`[Vuetify] ${e} ${t || "must be called from inside a setup function"}`);
  return n;
}
function Ot() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const t = Ue(e).type;
  return Ut((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name));
}
let xd = 0, bi = /* @__PURE__ */ new WeakMap();
function vt() {
  const e = Ue("getUid");
  if (bi.has(e))
    return bi.get(e);
  {
    const t = xd++;
    return bi.set(e, t), t;
  }
}
vt.reset = () => {
  xd = 0, bi = /* @__PURE__ */ new WeakMap();
};
function yb(e) {
  const {
    provides: t
  } = Ue("injectSelf");
  if (t && e in t)
    return t[e];
}
function z(e, t) {
  return (n) => Object.keys(e).reduce((r, i) => {
    const o = typeof e[i] == "object" && e[i] != null && !Array.isArray(e[i]) ? e[i] : {
      type: e[i]
    };
    return n && i in n ? r[i] = {
      ...o,
      default: n[i]
    } : r[i] = o, t && !r[i].source && (r[i].source = t), r;
  }, {});
}
const oa = Symbol.for("vuetify:defaults");
function Vd() {
  const e = me(oa);
  if (!e)
    throw new Error("[Vuetify] Could not find defaults instance");
  return e;
}
function On(e, t) {
  const n = Vd(), r = D(e), i = y(() => {
    if (T(t == null ? void 0 : t.disabled))
      return n.value;
    const o = T(t == null ? void 0 : t.scoped), a = T(t == null ? void 0 : t.reset), l = T(t == null ? void 0 : t.root);
    let c = Bi(r.value, {
      prev: n.value
    });
    if (o)
      return c;
    if (a || l) {
      const d = Number(a || 1 / 0);
      for (let u = 0; u <= d && !(!c || !("prev" in c)); u++)
        c = c.prev;
      return c;
    }
    return c.prev ? Bi(c.prev, c) : c;
  });
  return Je(oa, i), i;
}
function wn(e, t) {
  let n;
  function r() {
    n = Lr(), n.run(() => t.length ? t(() => {
      n == null || n.stop(), r();
    }) : t());
  }
  te(e, (i) => {
    i && !n ? r() : i || (n == null || n.stop(), n = void 0);
  }, {
    immediate: !0
  }), xe(() => {
    n == null || n.stop();
  });
}
function _b(e, t) {
  var n, r;
  return typeof ((n = e.props) == null ? void 0 : n[t]) < "u" || typeof ((r = e.props) == null ? void 0 : r[Ut(t)]) < "u";
}
function Yn(e) {
  if (e._setup = e._setup ?? e.setup, !e.name)
    return sa("The component is missing an explicit name, unable to generate default prop value"), e;
  if (e._setup) {
    e.props = z(e.props ?? {}, Ut(e.name))();
    const t = Object.keys(e.props);
    e.filterProps = function(r) {
      return Wr(r, t);
    }, e.props._as = String, e.setup = function(r, i) {
      const s = Vd();
      if (!s.value)
        return e._setup(r, i);
      const o = Cn(), a = y(() => s.value[r._as ?? e.name]), l = new Proxy(r, {
        get(u, f) {
          var m, g;
          const h = Reflect.get(u, f);
          return typeof f == "string" && !_b(o.vnode, f) ? ((m = a.value) == null ? void 0 : m[f]) ?? ((g = s.value.global) == null ? void 0 : g[f]) ?? h : h;
        }
      }), c = Hh();
      Gn(() => {
        if (a.value) {
          const u = Object.entries(a.value).filter((f) => {
            let [h] = f;
            return h.startsWith(h[0].toUpperCase());
          });
          u.length && (c.value = Object.fromEntries(u));
        }
      });
      const d = e._setup(l, i);
      return wn(c, () => {
        var u;
        On(Bi(((u = yb(oa)) == null ? void 0 : u.value) ?? {}, c.value));
      }), d;
    };
  }
  return e;
}
function H() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (t) => (e ? Yn : bv)(t);
}
function Xn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", n = arguments.length > 2 ? arguments[2] : void 0;
  return H()({
    name: n ?? ht(Hn(e.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: t
      }
    },
    setup(r, i) {
      let {
        slots: s
      } = i;
      return () => {
        var o;
        return kn(r.tag, {
          class: e
        }, (o = s.default) == null ? void 0 : o.call(s));
      };
    }
  });
}
function Dd(e) {
  if (typeof e.getRootNode != "function") {
    for (; e.parentNode; )
      e = e.parentNode;
    return e !== document ? null : document;
  }
  const t = e.getRootNode();
  return t !== document && t.getRootNode({
    composed: !0
  }) !== document ? null : t;
}
const Rr = "cubic-bezier(0.4, 0, 0.2, 1)", bb = "cubic-bezier(0.0, 0, 0.2, 1)", wb = "cubic-bezier(0.4, 0, 1, 1)";
function Sb(e) {
  for (; e; ) {
    if (aa(e))
      return e;
    e = e.parentElement;
  }
  return document.scrollingElement;
}
function Ui(e, t) {
  const n = [];
  if (t && e && !t.contains(e))
    return n;
  for (; e && (aa(e) && n.push(e), e !== t); )
    e = e.parentElement;
  return n;
}
function aa(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const t = window.getComputedStyle(e);
  return t.overflowY === "scroll" || t.overflowY === "auto" && e.scrollHeight > e.clientHeight;
}
const He = typeof window < "u", la = He && "IntersectionObserver" in window, ao = He && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports("selector(:focus-visible)");
function Eb(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === "fixed")
      return !0;
    e = e.offsetParent;
  }
  return !1;
}
function J(e) {
  const t = Ue("useRender");
  t.render = e;
}
const oe = [String, Function, Object], Ib = Symbol.for("vuetify:icons"), ns = z({
  icon: {
    type: oe
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: !0
  }
}, "icon"), jl = H()({
  name: "VComponentIcon",
  props: ns(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => v(e.tag, null, {
      default: () => {
        var r;
        return [e.icon ? v(e.icon, null, null) : (r = n.default) == null ? void 0 : r.call(n)];
      }
    });
  }
});
Yn({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: ns(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => v(e.tag, re(n, {
      style: null
    }), {
      default: () => [v("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [v("path", {
        d: e.icon
      }, null)])]
    });
  }
});
Yn({
  name: "VLigatureIcon",
  props: ns(),
  setup(e) {
    return () => v(e.tag, null, {
      default: () => [e.icon]
    });
  }
});
Yn({
  name: "VClassIcon",
  props: ns(),
  setup(e) {
    return () => v(e.tag, {
      class: e.icon
    }, null);
  }
});
const Cb = (e) => {
  const t = me(Ib);
  if (!t)
    throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: y(() => {
      var l;
      const r = K(e) ? e.value : e.icon;
      if (!r)
        return {
          component: jl
        };
      let i = r;
      if (typeof i == "string" && (i = i.trim(), i.startsWith("$") && (i = (l = t.aliases) == null ? void 0 : l[i.slice(1)])), !i)
        throw new Error(`Could not find aliased icon "${r}"`);
      if (typeof i != "string")
        return {
          component: jl,
          icon: i
        };
      const s = Object.keys(t.sets).find((c) => typeof i == "string" && i.startsWith(`${c}:`)), o = s ? i.slice(s.length + 1) : i;
      return {
        component: t.sets[s ?? t.defaultSet].component,
        icon: o
      };
    })
  };
}, kb = ["x-small", "small", "default", "large", "x-large"], rs = z({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function is(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot();
  return ra(() => {
    let n, r;
    return Fi(kb, e.size) ? n = `${t}--size-${e.size}` : e.size && (r = {
      width: Y(e.size),
      height: Y(e.size)
    }), {
      sizeClasses: n,
      sizeStyles: r
    };
  });
}
const _e = z({
  tag: {
    type: String,
    default: "div"
  }
}, "tag"), Wl = Symbol.for("vuetify:theme"), Ie = z({
  theme: String
}, "theme");
function Ve(e) {
  Ue("provideTheme");
  const t = me(Wl, null);
  if (!t)
    throw new Error("Could not find Vuetify theme injection");
  const n = y(() => e.theme ?? (t == null ? void 0 : t.name.value)), r = y(() => t.isDisabled ? void 0 : `v-theme--${n.value}`), i = {
    ...t,
    name: n,
    themeClasses: r
  };
  return Je(Wl, i), i;
}
function ca(e) {
  return ra(() => {
    const t = [], n = {};
    return e.value.background && (Hl(e.value.background) ? n.backgroundColor = e.value.background : t.push(`bg-${e.value.background}`)), e.value.text && (Hl(e.value.text) ? (n.color = e.value.text, n.caretColor = e.value.text) : t.push(`text-${e.value.text}`)), {
      colorClasses: t,
      colorStyles: n
    };
  });
}
function ot(e, t) {
  const n = y(() => ({
    text: K(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: r,
    colorStyles: i
  } = ca(n);
  return {
    textColorClasses: r,
    textColorStyles: i
  };
}
function zn(e, t) {
  const n = y(() => ({
    background: K(e) ? e.value : t ? e[t] : null
  })), {
    colorClasses: r,
    colorStyles: i
  } = ca(n);
  return {
    backgroundColorClasses: r,
    backgroundColorStyles: i
  };
}
const Tb = z({
  color: String,
  start: Boolean,
  end: Boolean,
  icon: oe,
  ...rs(),
  ..._e({
    tag: "i"
  }),
  ...Ie()
}, "v-icon"), pe = H()({
  name: "VIcon",
  props: Tb(),
  setup(e, t) {
    let {
      attrs: n,
      slots: r
    } = t, i;
    r.default && (i = y(() => {
      var u, f;
      const d = (u = r.default) == null ? void 0 : u.call(r);
      if (d)
        return (f = d.filter((h) => h.type === Vo && h.children && typeof h.children == "string")[0]) == null ? void 0 : f.children;
    }));
    const {
      themeClasses: s
    } = Ve(e), {
      iconData: o
    } = Cb(i || e), {
      sizeClasses: a
    } = is(e), {
      textColorClasses: l,
      textColorStyles: c
    } = ot(U(e, "color"));
    return J(() => v(o.value.component, {
      tag: e.tag,
      icon: o.value.icon,
      class: ["v-icon", "notranslate", s.value, a.value, l.value, {
        "v-icon--clickable": !!n.onClick,
        "v-icon--start": e.start,
        "v-icon--end": e.end
      }],
      style: [a.value ? void 0 : {
        fontSize: Y(e.size),
        height: Y(e.size),
        width: Y(e.size)
      }, c.value],
      role: n.onClick ? "button" : void 0,
      "aria-hidden": !n.onClick
    }, {
      default: () => {
        var d;
        return [(d = r.default) == null ? void 0 : d.call(r)];
      }
    })), {};
  }
});
const Ob = H()({
  name: "VDivider",
  props: {
    color: String,
    inset: Boolean,
    length: [Number, String],
    thickness: [Number, String],
    vertical: Boolean,
    ...Ie()
  },
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const {
      themeClasses: r
    } = Ve(e), {
      textColorClasses: i,
      textColorStyles: s
    } = ot(U(e, "color")), o = y(() => {
      const a = {};
      return e.length && (a[e.vertical ? "maxHeight" : "maxWidth"] = Y(e.length)), e.thickness && (a[e.vertical ? "borderRightWidth" : "borderTopWidth"] = Y(e.thickness)), a;
    });
    return J(() => v("hr", {
      class: [{
        "v-divider": !0,
        "v-divider--inset": e.inset,
        "v-divider--vertical": e.vertical
      }, r.value, i.value],
      style: [o.value, s.value],
      "aria-orientation": !n.role || n.role === "separator" ? e.vertical ? "vertical" : "horizontal" : void 0,
      role: `${n.role || "separator"}`
    }, null)), {};
  }
}), Ge = H(!1)({
  name: "VDefaultsProvider",
  props: {
    defaults: Object,
    disabled: Boolean,
    reset: [Number, String],
    root: Boolean,
    scoped: Boolean
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      defaults: r,
      disabled: i,
      reset: s,
      root: o,
      scoped: a
    } = ki(e);
    return On(r, {
      reset: s,
      root: o,
      scoped: a,
      disabled: i
    }), () => {
      var l;
      return (l = n.default) == null ? void 0 : l.call(n);
    };
  }
});
function je(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "center center", n = arguments.length > 2 ? arguments[2] : void 0;
  return H()({
    name: e,
    props: {
      disabled: Boolean,
      group: Boolean,
      hideOnLeave: Boolean,
      leaveAbsolute: Boolean,
      mode: {
        type: String,
        default: n
      },
      origin: {
        type: String,
        default: t
      }
    },
    setup(r, i) {
      let {
        slots: s
      } = i;
      const o = {
        onBeforeEnter(a) {
          a.style.transformOrigin = r.origin;
        },
        onLeave(a) {
          if (r.leaveAbsolute) {
            const {
              offsetTop: l,
              offsetLeft: c,
              offsetWidth: d,
              offsetHeight: u
            } = a;
            a._transitionInitialStyles = {
              position: a.style.position,
              top: a.style.top,
              left: a.style.left,
              width: a.style.width,
              height: a.style.height
            }, a.style.position = "absolute", a.style.top = `${l}px`, a.style.left = `${c}px`, a.style.width = `${d}px`, a.style.height = `${u}px`;
          }
          r.hideOnLeave && a.style.setProperty("display", "none", "important");
        },
        onAfterLeave(a) {
          if (r.leaveAbsolute && (a != null && a._transitionInitialStyles)) {
            const {
              position: l,
              top: c,
              left: d,
              width: u,
              height: f
            } = a._transitionInitialStyles;
            delete a._transitionInitialStyles, a.style.position = l || "", a.style.top = c || "", a.style.left = d || "", a.style.width = u || "", a.style.height = f || "";
          }
        }
      };
      return () => {
        const a = r.group ? Jv : Ct;
        return kn(a, {
          name: r.disabled ? "" : e,
          css: !r.disabled,
          ...r.group ? void 0 : {
            mode: r.mode
          },
          ...r.disabled ? {} : o
        }, s.default);
      };
    }
  });
}
function Ld(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return H()({
    name: e,
    props: {
      mode: {
        type: String,
        default: n
      },
      disabled: Boolean
    },
    setup(r, i) {
      let {
        slots: s
      } = i;
      return () => kn(Ct, {
        name: r.disabled ? "" : e,
        css: !r.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...r.disabled ? {} : t
      }, s.default);
    }
  });
}
function $d() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", r = Hn(`offset-${n}`);
  return {
    onBeforeEnter(o) {
      o._parent = o.parentNode, o._initialStyle = {
        transition: o.style.transition,
        overflow: o.style.overflow,
        [n]: o.style[n]
      };
    },
    onEnter(o) {
      const a = o._initialStyle;
      o.style.setProperty("transition", "none", "important"), o.style.overflow = "hidden";
      const l = `${o[r]}px`;
      o.style[n] = "0", o.offsetHeight, o.style.transition = a.transition, e && o._parent && o._parent.classList.add(e), requestAnimationFrame(() => {
        o.style[n] = l;
      });
    },
    onAfterEnter: s,
    onEnterCancelled: s,
    onLeave(o) {
      o._initialStyle = {
        transition: "",
        overflow: o.style.overflow,
        [n]: o.style[n]
      }, o.style.overflow = "hidden", o.style[n] = `${o[r]}px`, o.offsetHeight, requestAnimationFrame(() => o.style[n] = "0");
    },
    onAfterLeave: i,
    onLeaveCancelled: i
  };
  function i(o) {
    e && o._parent && o._parent.classList.remove(e), s(o);
  }
  function s(o) {
    const a = o._initialStyle[n];
    o.style.overflow = o._initialStyle.overflow, a != null && (o.style[n] = a), delete o._initialStyle;
  }
}
const Ab = H()({
  name: "VDialogTransition",
  props: {
    target: Object
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = {
      onBeforeEnter(i) {
        i.style.pointerEvents = "none", i.style.visibility = "hidden";
      },
      async onEnter(i, s) {
        var f;
        await new Promise((h) => requestAnimationFrame(h)), await new Promise((h) => requestAnimationFrame(h)), i.style.visibility = "";
        const {
          x: o,
          y: a,
          sx: l,
          sy: c,
          speed: d
        } = Gl(e.target, i), u = cn(i, [{
          transform: `translate(${o}px, ${a}px) scale(${l}, ${c})`,
          opacity: 0
        }, {}], {
          duration: 225 * d,
          easing: bb
        });
        (f = zl(i)) == null || f.forEach((h) => {
          cn(h, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * d,
            easing: Rr
          });
        }), u.finished.then(() => s());
      },
      onAfterEnter(i) {
        i.style.removeProperty("pointer-events");
      },
      onBeforeLeave(i) {
        i.style.pointerEvents = "none";
      },
      async onLeave(i, s) {
        var f;
        await new Promise((h) => requestAnimationFrame(h));
        const {
          x: o,
          y: a,
          sx: l,
          sy: c,
          speed: d
        } = Gl(e.target, i);
        cn(i, [{}, {
          transform: `translate(${o}px, ${a}px) scale(${l}, ${c})`,
          opacity: 0
        }], {
          duration: 125 * d,
          easing: wb
        }).finished.then(() => s()), (f = zl(i)) == null || f.forEach((h) => {
          cn(h, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * d,
            easing: Rr
          });
        });
      },
      onAfterLeave(i) {
        i.style.removeProperty("pointer-events");
      }
    };
    return () => e.target ? v(Ct, re({
      name: "dialog-transition"
    }, r, {
      css: !1
    }), n) : v(Ct, {
      name: "dialog-transition"
    }, n);
  }
});
function zl(e) {
  var n;
  const t = (n = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : n.children;
  return t && [...t];
}
function Gl(e, t) {
  const n = e.getBoundingClientRect(), r = ia(t), [i, s] = getComputedStyle(t).transformOrigin.split(" ").map((C) => parseFloat(C)), [o, a] = getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let l = n.left + n.width / 2;
  o === "left" || a === "left" ? l -= n.width / 2 : (o === "right" || a === "right") && (l += n.width / 2);
  let c = n.top + n.height / 2;
  o === "top" || a === "top" ? c -= n.height / 2 : (o === "bottom" || a === "bottom") && (c += n.height / 2);
  const d = n.width / r.width, u = n.height / r.height, f = Math.max(1, d, u), h = d / f || 0, m = u / f || 0, g = r.width * r.height / (window.innerWidth * window.innerHeight), w = g > 0.12 ? Math.min(1.5, (g - 0.12) * 10 + 1) : 1;
  return {
    x: l - (i + r.left),
    y: c - (s + r.top),
    sx: h,
    sy: m,
    speed: w
  };
}
je("fab-transition", "center center", "out-in");
je("dialog-bottom-transition");
je("dialog-top-transition");
const ql = je("fade-transition");
je("scale-transition");
je("scroll-x-transition");
je("scroll-x-reverse-transition");
je("scroll-y-transition");
je("scroll-y-reverse-transition");
je("slide-x-transition");
je("slide-x-reverse-transition");
const Md = je("slide-y-transition");
je("slide-y-reverse-transition");
const Nb = Ld("expand-transition", $d()), Pb = Ld("expand-x-transition", $d("", !0)), lo = Symbol.for("vuetify:list");
function Bd() {
  const e = me(lo, {
    hasPrepend: D(!1),
    updateHasPrepend: () => null
  }), t = {
    hasPrepend: D(!1),
    updateHasPrepend: (n) => {
      n && (t.hasPrepend.value = n);
    }
  };
  return Je(lo, t), e;
}
function Fd() {
  return me(lo, null);
}
const ss = z({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (e) => e !== !0
  }
}, "transition"), St = (e, t) => {
  let {
    slots: n
  } = t;
  const {
    transition: r,
    ...i
  } = e, {
    component: s = Ct,
    ...o
  } = typeof r == "object" ? r : {};
  return kn(s, re(typeof r == "string" ? {
    name: r
  } : o, i), n);
};
function be(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (u) => u, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (u) => u;
  const s = Ue("useProxiedModel"), o = D(e[t] !== void 0 ? e[t] : n), a = Ut(t), c = y(a !== t ? () => {
    var u, f, h, m;
    return e[t], !!(((u = s.vnode.props) != null && u.hasOwnProperty(t) || (f = s.vnode.props) != null && f.hasOwnProperty(a)) && ((h = s.vnode.props) != null && h.hasOwnProperty(`onUpdate:${t}`) || (m = s.vnode.props) != null && m.hasOwnProperty(`onUpdate:${a}`)));
  } : () => {
    var u, f;
    return e[t], !!((u = s.vnode.props) != null && u.hasOwnProperty(t) && ((f = s.vnode.props) != null && f.hasOwnProperty(`onUpdate:${t}`)));
  });
  wn(() => !c.value, () => {
    te(() => e[t], (u) => {
      o.value = u;
    });
  });
  const d = y({
    get() {
      return r(c.value ? e[t] : o.value);
    },
    set(u) {
      const f = i(u), h = B(c.value ? e[t] : o.value);
      h === f || r(h) === u || (o.value = f, s == null || s.emit(`update:${t}`, f));
    }
  });
  return Object.defineProperty(d, "externalValue", {
    get: () => c.value ? e[t] : o.value
  }), d;
}
const Rb = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: r,
      parents: i
    } = e;
    if (n) {
      const s = /* @__PURE__ */ new Set();
      s.add(t);
      let o = i.get(t);
      for (; o != null; )
        s.add(o), o = i.get(o);
      return s;
    } else
      return r.delete(t), r;
  },
  select: () => null
}, Ud = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: r,
      parents: i
    } = e;
    if (n) {
      let s = i.get(t);
      for (r.add(t); s != null && s !== t; )
        r.add(s), s = i.get(s);
      return r;
    } else
      r.delete(t);
    return r;
  },
  select: () => null
}, xb = {
  open: Ud.open,
  select: (e) => {
    let {
      id: t,
      value: n,
      opened: r,
      parents: i
    } = e;
    if (!n)
      return r;
    const s = [];
    let o = i.get(t);
    for (; o != null; )
      s.push(o), o = i.get(o);
    return new Set(s);
  }
}, ua = (e) => {
  const t = {
    select: (n) => {
      let {
        id: r,
        value: i,
        selected: s
      } = n;
      if (r = B(r), e && !i) {
        const o = Array.from(s.entries()).reduce((a, l) => {
          let [c, d] = l;
          return d === "on" ? [...a, c] : a;
        }, []);
        if (o.length === 1 && o[0] === r)
          return s;
      }
      return s.set(r, i ? "on" : "off"), s;
    },
    in: (n, r, i) => {
      let s = /* @__PURE__ */ new Map();
      for (const o of n || [])
        s = t.select({
          id: o,
          value: !0,
          selected: new Map(s),
          children: r,
          parents: i
        });
      return s;
    },
    out: (n) => {
      const r = [];
      for (const [i, s] of n.entries())
        s === "on" && r.push(i);
      return r;
    }
  };
  return t;
}, Hd = (e) => {
  const t = ua(e);
  return {
    select: (r) => {
      let {
        selected: i,
        id: s,
        ...o
      } = r;
      s = B(s);
      const a = i.has(s) ? /* @__PURE__ */ new Map([[s, i.get(s)]]) : /* @__PURE__ */ new Map();
      return t.select({
        ...o,
        id: s,
        selected: a
      });
    },
    in: (r, i, s) => {
      let o = /* @__PURE__ */ new Map();
      return r != null && r.length && (o = t.in(r.slice(0, 1), i, s)), o;
    },
    out: (r, i, s) => t.out(r, i, s)
  };
}, Vb = (e) => {
  const t = ua(e);
  return {
    select: (r) => {
      let {
        id: i,
        selected: s,
        children: o,
        ...a
      } = r;
      return i = B(i), o.has(i) ? s : t.select({
        id: i,
        selected: s,
        children: o,
        ...a
      });
    },
    in: t.in,
    out: t.out
  };
}, Db = (e) => {
  const t = Hd(e);
  return {
    select: (r) => {
      let {
        id: i,
        selected: s,
        children: o,
        ...a
      } = r;
      return i = B(i), o.has(i) ? s : t.select({
        id: i,
        selected: s,
        children: o,
        ...a
      });
    },
    in: t.in,
    out: t.out
  };
}, Lb = (e) => {
  const t = {
    select: (n) => {
      let {
        id: r,
        value: i,
        selected: s,
        children: o,
        parents: a
      } = n;
      r = B(r);
      const l = new Map(s), c = [r];
      for (; c.length; ) {
        const u = c.shift();
        s.set(u, i ? "on" : "off"), o.has(u) && c.push(...o.get(u));
      }
      let d = a.get(r);
      for (; d; ) {
        const u = o.get(d), f = u.every((m) => s.get(m) === "on"), h = u.every((m) => !s.has(m) || s.get(m) === "off");
        s.set(d, f ? "on" : h ? "off" : "indeterminate"), d = a.get(d);
      }
      return e && !i && Array.from(s.entries()).reduce((f, h) => {
        let [m, g] = h;
        return g === "on" ? [...f, m] : f;
      }, []).length === 0 ? l : s;
    },
    in: (n, r, i) => {
      let s = /* @__PURE__ */ new Map();
      for (const o of n || [])
        s = t.select({
          id: o,
          value: !0,
          selected: new Map(s),
          children: r,
          parents: i
        });
      return s;
    },
    out: (n, r) => {
      const i = [];
      for (const [s, o] of n.entries())
        o === "on" && !r.has(s) && i.push(s);
      return i;
    }
  };
  return t;
}, xr = Symbol.for("vuetify:nested"), jd = {
  id: D(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: D(/* @__PURE__ */ new Map()),
    children: D(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    select: () => null,
    opened: D(/* @__PURE__ */ new Set()),
    selected: D(/* @__PURE__ */ new Map()),
    selectedValues: D([])
  }
}, $b = z({
  selectStrategy: [String, Function],
  openStrategy: [String, Object],
  opened: Array,
  selected: Array,
  mandatory: Boolean
}, "nested"), Mb = (e) => {
  let t = !1;
  const n = D(/* @__PURE__ */ new Map()), r = D(/* @__PURE__ */ new Map()), i = be(e, "opened", e.opened, (u) => new Set(u), (u) => [...u.values()]), s = y(() => {
    if (typeof e.selectStrategy == "object")
      return e.selectStrategy;
    switch (e.selectStrategy) {
      case "single-leaf":
        return Db(e.mandatory);
      case "leaf":
        return Vb(e.mandatory);
      case "independent":
        return ua(e.mandatory);
      case "single-independent":
        return Hd(e.mandatory);
      case "classic":
      default:
        return Lb(e.mandatory);
    }
  }), o = y(() => {
    if (typeof e.openStrategy == "object")
      return e.openStrategy;
    switch (e.openStrategy) {
      case "list":
        return xb;
      case "single":
        return Rb;
      case "multiple":
      default:
        return Ud;
    }
  }), a = be(e, "selected", e.selected, (u) => s.value.in(u, n.value, r.value), (u) => s.value.out(u, n.value, r.value));
  Kt(() => {
    t = !0;
  });
  function l(u) {
    const f = [];
    let h = u;
    for (; h != null; )
      f.unshift(h), h = r.value.get(h);
    return f;
  }
  const c = Ue("nested"), d = {
    id: D(),
    root: {
      opened: i,
      selected: a,
      selectedValues: y(() => {
        const u = [];
        for (const [f, h] of a.value.entries())
          h === "on" && u.push(f);
        return u;
      }),
      register: (u, f, h) => {
        f && u !== f && r.value.set(u, f), h && n.value.set(u, []), f != null && n.value.set(f, [...n.value.get(f) || [], u]);
      },
      unregister: (u) => {
        if (t)
          return;
        n.value.delete(u);
        const f = r.value.get(u);
        if (f) {
          const h = n.value.get(f) ?? [];
          n.value.set(f, h.filter((m) => m !== u));
        }
        r.value.delete(u), i.value.delete(u);
      },
      open: (u, f, h) => {
        c.emit("click:open", {
          id: u,
          value: f,
          path: l(u),
          event: h
        });
        const m = o.value.open({
          id: u,
          value: f,
          opened: new Set(i.value),
          children: n.value,
          parents: r.value,
          event: h
        });
        m && (i.value = m);
      },
      openOnSelect: (u, f, h) => {
        const m = o.value.select({
          id: u,
          value: f,
          selected: new Map(a.value),
          opened: new Set(i.value),
          children: n.value,
          parents: r.value,
          event: h
        });
        m && (i.value = m);
      },
      select: (u, f, h) => {
        c.emit("click:select", {
          id: u,
          value: f,
          path: l(u),
          event: h
        });
        const m = s.value.select({
          id: u,
          value: f,
          selected: new Map(a.value),
          children: n.value,
          parents: r.value,
          event: h
        });
        m && (a.value = m), d.root.openOnSelect(u, f, h);
      },
      children: n,
      parents: r
    }
  };
  return Je(xr, d), d.root;
}, Wd = (e, t) => {
  const n = me(xr, jd), r = Symbol(vt()), i = y(() => e.value ?? r), s = {
    ...n,
    id: i,
    open: (o, a) => n.root.open(i.value, o, a),
    openOnSelect: (o, a) => n.root.openOnSelect(i.value, o, a),
    isOpen: y(() => n.root.opened.value.has(i.value)),
    parent: y(() => n.root.parents.value.get(i.value)),
    select: (o, a) => n.root.select(i.value, o, a),
    isSelected: y(() => n.root.selected.value.get(B(i.value)) === "on"),
    isIndeterminate: y(() => n.root.selected.value.get(i.value) === "indeterminate"),
    isLeaf: y(() => !n.root.children.value.get(i.value)),
    isGroupActivator: n.isGroupActivator
  };
  return !n.isGroupActivator && n.root.register(i.value, n.id.value, t), Kt(() => {
    !n.isGroupActivator && n.root.unregister(i.value);
  }), t && Je(xr, s), s;
}, Bb = () => {
  const e = me(xr, jd);
  Je(xr, {
    ...e,
    isGroupActivator: !0
  });
};
function zd() {
  const e = D(!1);
  return qt(() => {
    window.requestAnimationFrame(() => {
      e.value = !0;
    });
  }), {
    ssrBootStyles: y(() => e.value ? void 0 : {
      transition: "none !important"
    }),
    isBooted: $r(e)
  };
}
const Fb = Yn({
  name: "VListGroupActivator",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Bb(), () => {
      var r;
      return (r = n.default) == null ? void 0 : r.call(n);
    };
  }
}), Ub = z({
  activeColor: String,
  color: String,
  collapseIcon: {
    type: oe,
    default: "$collapse"
  },
  expandIcon: {
    type: oe,
    default: "$expand"
  },
  prependIcon: oe,
  appendIcon: oe,
  fluid: Boolean,
  subgroup: Boolean,
  value: null,
  ..._e()
}, "v-list-group"), Kl = H()({
  name: "VListGroup",
  props: {
    title: String,
    ...Ub()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isOpen: r,
      open: i,
      id: s
    } = Wd(U(e, "value"), !0), o = y(() => `v-list-group--id-${String(s.value)}`), a = Fd(), {
      isBooted: l
    } = zd();
    function c(h) {
      i(!r.value, h);
    }
    const d = y(() => ({
      onClick: c,
      class: "v-list-group__header",
      id: o.value
    })), u = y(() => r.value ? e.collapseIcon : e.expandIcon), f = y(() => ({
      VListItem: {
        active: r.value,
        activeColor: e.activeColor,
        color: e.color,
        prependIcon: e.prependIcon || e.subgroup && u.value,
        appendIcon: e.appendIcon || !e.subgroup && u.value,
        title: e.title,
        value: e.value
      }
    }));
    return J(() => v(e.tag, {
      class: ["v-list-group", {
        "v-list-group--prepend": a == null ? void 0 : a.hasPrepend.value,
        "v-list-group--fluid": e.fluid,
        "v-list-group--subgroup": e.subgroup,
        "v-list-group--open": r.value
      }]
    }, {
      default: () => [n.activator && v(Ge, {
        defaults: f.value
      }, {
        default: () => [v(Fb, null, {
          default: () => [n.activator({
            props: d.value,
            isOpen: r.value
          })]
        })]
      }), v(St, {
        transition: {
          component: Nb
        },
        disabled: !l.value
      }, {
        default: () => {
          var h;
          return [Ae(v("div", {
            class: "v-list-group__items",
            role: "group",
            "aria-labelledby": o.value
          }, [(h = n.default) == null ? void 0 : h.call(n)]), [[qn, r.value]])];
        }
      })]
    })), {};
  }
});
const An = z({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function Nn(e) {
  return {
    dimensionStyles: y(() => ({
      height: Y(e.height),
      maxHeight: Y(e.maxHeight),
      maxWidth: Y(e.maxWidth),
      minHeight: Y(e.minHeight),
      minWidth: Y(e.minWidth),
      width: Y(e.width)
    }))
  };
}
function Hb(e) {
  return {
    aspectStyles: y(() => {
      const t = Number(e.aspectRatio);
      return t ? {
        paddingBottom: String(1 / t * 100) + "%"
      } : void 0;
    })
  };
}
const jb = H()({
  name: "VResponsive",
  props: {
    aspectRatio: [String, Number],
    contentClass: String,
    ...An()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      aspectStyles: r
    } = Hb(e), {
      dimensionStyles: i
    } = Nn(e);
    return J(() => {
      var s;
      return v("div", {
        class: "v-responsive",
        style: i.value
      }, [v("div", {
        class: "v-responsive__sizer",
        style: r.value
      }, null), (s = n.additional) == null ? void 0 : s.call(n), n.default && v("div", {
        class: ["v-responsive__content", e.contentClass]
      }, [n.default()])]);
    }), {};
  }
});
function Wb(e, t) {
  if (!la)
    return;
  const n = t.modifiers || {}, r = t.value, {
    handler: i,
    options: s
  } = typeof r == "object" ? r : {
    handler: r,
    options: {}
  }, o = new IntersectionObserver(function() {
    var u;
    let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], l = arguments.length > 1 ? arguments[1] : void 0;
    const c = (u = e._observe) == null ? void 0 : u[t.instance.$.uid];
    if (!c)
      return;
    const d = a.some((f) => f.isIntersecting);
    i && (!n.quiet || c.init) && (!n.once || d || c.init) && i(d, a, l), d && n.once ? Gd(e, t) : c.init = !0;
  }, s);
  e._observe = Object(e._observe), e._observe[t.instance.$.uid] = {
    init: !1,
    observer: o
  }, o.observe(e);
}
function Gd(e, t) {
  var r;
  const n = (r = e._observe) == null ? void 0 : r[t.instance.$.uid];
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid]);
}
const zb = {
  mounted: Wb,
  unmounted: Gd
}, qd = zb, Kd = H()({
  name: "VImg",
  directives: {
    intersect: qd
  },
  props: {
    aspectRatio: [String, Number],
    alt: String,
    cover: Boolean,
    eager: Boolean,
    gradient: String,
    lazySrc: String,
    options: {
      type: Object,
      // For more information on types, navigate to:
      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    },
    sizes: String,
    src: {
      type: [String, Object],
      default: ""
    },
    srcset: String,
    width: [String, Number],
    ...ss()
  },
  emits: {
    loadstart: (e) => !0,
    load: (e) => !0,
    error: (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: r
    } = t;
    const i = D(""), s = D(), o = D(e.eager ? "loading" : "idle"), a = D(), l = D(), c = y(() => e.src && typeof e.src == "object" ? {
      src: e.src.src,
      srcset: e.srcset || e.src.srcset,
      lazySrc: e.lazySrc || e.src.lazySrc,
      aspect: Number(e.aspectRatio || e.src.aspect || 0)
    } : {
      src: e.src,
      srcset: e.srcset,
      lazySrc: e.lazySrc,
      aspect: Number(e.aspectRatio || 0)
    }), d = y(() => c.value.aspect || a.value / l.value || 0);
    te(() => e.src, () => {
      u(o.value !== "idle");
    }), te(d, (_, b) => {
      !_ && b && s.value && w(s.value);
    }), jc(() => u());
    function u(_) {
      if (!(e.eager && _) && !(la && !_ && !e.eager)) {
        if (o.value = "loading", c.value.lazySrc) {
          const b = new Image();
          b.src = c.value.lazySrc, w(b, null);
        }
        c.value.src && Oe(() => {
          var b, S;
          if (n("loadstart", ((b = s.value) == null ? void 0 : b.currentSrc) || c.value.src), (S = s.value) != null && S.complete) {
            if (s.value.naturalWidth || h(), o.value === "error")
              return;
            d.value || w(s.value, null), f();
          } else
            d.value || w(s.value), m();
        });
      }
    }
    function f() {
      var _;
      m(), o.value = "loaded", n("load", ((_ = s.value) == null ? void 0 : _.currentSrc) || c.value.src);
    }
    function h() {
      var _;
      o.value = "error", n("error", ((_ = s.value) == null ? void 0 : _.currentSrc) || c.value.src);
    }
    function m() {
      const _ = s.value;
      _ && (i.value = _.currentSrc || _.src);
    }
    let g = -1;
    function w(_) {
      let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const S = () => {
        clearTimeout(g);
        const {
          naturalHeight: P,
          naturalWidth: k
        } = _;
        P || k ? (a.value = k, l.value = P) : !_.complete && o.value === "loading" && b != null ? g = window.setTimeout(S, b) : (_.currentSrc.endsWith(".svg") || _.currentSrc.startsWith("data:image/svg+xml")) && (a.value = 1, l.value = 1);
      };
      S();
    }
    const C = y(() => ({
      "v-img__img--cover": e.cover,
      "v-img__img--contain": !e.cover
    })), E = () => {
      var S;
      if (!c.value.src || o.value === "idle")
        return null;
      const _ = v("img", {
        class: ["v-img__img", C.value],
        src: c.value.src,
        srcset: c.value.srcset,
        alt: e.alt,
        sizes: e.sizes,
        ref: s,
        onLoad: f,
        onError: h
      }, null), b = (S = r.sources) == null ? void 0 : S.call(r);
      return v(St, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => [Ae(b ? v("picture", {
          class: "v-img__picture"
        }, [b, _]) : _, [[qn, o.value === "loaded"]])]
      });
    }, p = () => v(St, {
      transition: e.transition
    }, {
      default: () => [c.value.lazySrc && o.value !== "loaded" && v("img", {
        class: ["v-img__img", "v-img__img--preload", C.value],
        src: c.value.lazySrc,
        alt: e.alt
      }, null)]
    }), O = () => r.placeholder ? v(St, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [(o.value === "loading" || o.value === "error" && !r.error) && v("div", {
        class: "v-img__placeholder"
      }, [r.placeholder()])]
    }) : null, A = () => r.error ? v(St, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [o.value === "error" && v("div", {
        class: "v-img__error"
      }, [r.error()])]
    }) : null, N = () => e.gradient ? v("div", {
      class: "v-img__gradient",
      style: {
        backgroundImage: `linear-gradient(${e.gradient})`
      }
    }, null) : null, I = D(!1);
    {
      const _ = te(d, (b) => {
        b && (requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            I.value = !0;
          });
        }), _());
      });
    }
    return J(() => Ae(v(jb, {
      class: ["v-img", {
        "v-img--booting": !I.value
      }],
      style: {
        width: Y(e.width === "auto" ? a.value : e.width)
      },
      aspectRatio: d.value,
      "aria-label": e.alt,
      role: e.alt ? "img" : void 0
    }, {
      additional: () => v(Pe, null, [v(E, null, null), v(p, null, null), v(N, null, null), v(O, null, null), v(A, null, null)]),
      default: r.default
    }), [[Tt("intersect"), {
      handler: u,
      options: e.options
    }, null, {
      once: !0
    }]])), {
      currentSrc: i,
      image: s,
      state: o,
      naturalWidth: a,
      naturalHeight: l
    };
  }
}), Gb = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function zr(e, t) {
  return v(Pe, null, [e && v("span", {
    key: "overlay",
    class: `${t}__overlay`
  }, null), v("span", {
    key: "underlay",
    class: `${t}__underlay`
  }, null)]);
}
const Pn = z({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (e) => Gb.includes(e)
  }
}, "variant");
function Gr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot();
  const n = y(() => {
    const {
      variant: s
    } = T(e);
    return `${t}--variant-${s}`;
  }), {
    colorClasses: r,
    colorStyles: i
  } = ca(y(() => {
    const {
      variant: s,
      color: o
    } = T(e);
    return {
      [["elevated", "flat"].includes(s) ? "background" : "text"]: o
    };
  }));
  return {
    colorClasses: r,
    colorStyles: i,
    variantClasses: n
  };
}
const qb = [null, "default", "comfortable", "compact"], lt = z({
  density: {
    type: String,
    default: "default",
    validator: (e) => qb.includes(e)
  }
}, "density");
function mt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot();
  return {
    densityClasses: y(() => `${t}--density-${e.density}`)
  };
}
const Qt = z({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  }
}, "rounded");
function Zt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot();
  return {
    roundedClasses: y(() => {
      const r = K(e) ? e.value : e.rounded, i = [];
      if (r === !0 || r === "")
        i.push(`${t}--rounded`);
      else if (typeof r == "string" || r === 0)
        for (const s of String(r).split(" "))
          i.push(`rounded-${s}`);
      return i;
    })
  };
}
const Kb = z({
  start: Boolean,
  end: Boolean,
  icon: oe,
  image: String,
  ...lt(),
  ...Qt(),
  ...rs(),
  ..._e(),
  ...Ie(),
  ...Pn({
    variant: "flat"
  })
}, "v-avatar"), Hi = H()({
  name: "VAvatar",
  props: Kb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: r
    } = Ve(e), {
      colorClasses: i,
      colorStyles: s,
      variantClasses: o
    } = Gr(e), {
      densityClasses: a
    } = mt(e), {
      roundedClasses: l
    } = Zt(e), {
      sizeClasses: c,
      sizeStyles: d
    } = is(e);
    return J(() => v(e.tag, {
      class: ["v-avatar", {
        "v-avatar--start": e.start,
        "v-avatar--end": e.end
      }, r.value, i.value, a.value, l.value, c.value, o.value],
      style: [s.value, d.value]
    }, {
      default: () => {
        var u;
        return [e.image ? v(Kd, {
          key: "image",
          src: e.image,
          alt: "",
          cover: !0
        }, null) : e.icon ? v(pe, {
          key: "icon",
          icon: e.icon
        }, null) : (u = n.default) == null ? void 0 : u.call(n), zr(!1, "v-avatar")];
      }
    })), {};
  }
}), Jb = Xn("v-list-item-subtitle"), Yb = Xn("v-list-item-title");
const co = Symbol("rippleStop"), Xb = 80;
function Jl(e, t) {
  e.style.transform = t, e.style.webkitTransform = t;
}
function uo(e) {
  return e.constructor.name === "TouchEvent";
}
function Jd(e) {
  return e.constructor.name === "KeyboardEvent";
}
const Qb = function(e, t) {
  var u;
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = 0, i = 0;
  if (!Jd(e)) {
    const f = t.getBoundingClientRect(), h = uo(e) ? e.touches[e.touches.length - 1] : e;
    r = h.clientX - f.left, i = h.clientY - f.top;
  }
  let s = 0, o = 0.3;
  (u = t._ripple) != null && u.circle ? (o = 0.15, s = t.clientWidth / 2, s = n.center ? s : s + Math.sqrt((r - s) ** 2 + (i - s) ** 2) / 4) : s = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
  const a = `${(t.clientWidth - s * 2) / 2}px`, l = `${(t.clientHeight - s * 2) / 2}px`, c = n.center ? a : `${r - s}px`, d = n.center ? l : `${i - s}px`;
  return {
    radius: s,
    scale: o,
    x: c,
    y: d,
    centerX: a,
    centerY: l
  };
}, ji = {
  /* eslint-disable max-statements */
  show(e, t) {
    var h;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!((h = t == null ? void 0 : t._ripple) != null && h.enabled))
      return;
    const r = document.createElement("span"), i = document.createElement("span");
    r.appendChild(i), r.className = "v-ripple__container", n.class && (r.className += ` ${n.class}`);
    const {
      radius: s,
      scale: o,
      x: a,
      y: l,
      centerX: c,
      centerY: d
    } = Qb(e, t, n), u = `${s * 2}px`;
    i.className = "v-ripple__animation", i.style.width = u, i.style.height = u, t.appendChild(r);
    const f = window.getComputedStyle(t);
    f && f.position === "static" && (t.style.position = "relative", t.dataset.previousPosition = "static"), i.classList.add("v-ripple__animation--enter"), i.classList.add("v-ripple__animation--visible"), Jl(i, `translate(${a}, ${l}) scale3d(${o},${o},${o})`), i.dataset.activated = String(performance.now()), setTimeout(() => {
      i.classList.remove("v-ripple__animation--enter"), i.classList.add("v-ripple__animation--in"), Jl(i, `translate(${c}, ${d}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(e) {
    var s;
    if (!((s = e == null ? void 0 : e._ripple) != null && s.enabled))
      return;
    const t = e.getElementsByClassName("v-ripple__animation");
    if (t.length === 0)
      return;
    const n = t[t.length - 1];
    if (n.dataset.isHiding)
      return;
    n.dataset.isHiding = "true";
    const r = performance.now() - Number(n.dataset.activated), i = Math.max(250 - r, 0);
    setTimeout(() => {
      n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => {
        var a;
        e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), ((a = n.parentNode) == null ? void 0 : a.parentNode) === e && e.removeChild(n.parentNode);
      }, 300);
    }, i);
  }
};
function Yd(e) {
  return typeof e > "u" || !!e;
}
function Vr(e) {
  const t = {}, n = e.currentTarget;
  if (!(!(n != null && n._ripple) || n._ripple.touched || e[co])) {
    if (e[co] = !0, uo(e))
      n._ripple.touched = !0, n._ripple.isTouch = !0;
    else if (n._ripple.isTouch)
      return;
    if (t.center = n._ripple.centered || Jd(e), n._ripple.class && (t.class = n._ripple.class), uo(e)) {
      if (n._ripple.showTimerCommit)
        return;
      n._ripple.showTimerCommit = () => {
        ji.show(e, n, t);
      }, n._ripple.showTimer = window.setTimeout(() => {
        var r;
        (r = n == null ? void 0 : n._ripple) != null && r.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null);
      }, Xb);
    } else
      ji.show(e, n, t);
  }
}
function Yl(e) {
  e[co] = !0;
}
function $e(e) {
  const t = e.currentTarget;
  if (t != null && t._ripple) {
    if (window.clearTimeout(t._ripple.showTimer), e.type === "touchend" && t._ripple.showTimerCommit) {
      t._ripple.showTimerCommit(), t._ripple.showTimerCommit = null, t._ripple.showTimer = window.setTimeout(() => {
        $e(e);
      });
      return;
    }
    window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1);
    }), ji.hide(t);
  }
}
function Xd(e) {
  const t = e.currentTarget;
  t != null && t._ripple && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer));
}
let Dr = !1;
function Qd(e) {
  !Dr && (e.keyCode === Ll.enter || e.keyCode === Ll.space) && (Dr = !0, Vr(e));
}
function Zd(e) {
  Dr = !1, $e(e);
}
function ef(e) {
  Dr && (Dr = !1, $e(e));
}
function tf(e, t, n) {
  const {
    value: r,
    modifiers: i
  } = t, s = Yd(r);
  if (s || ji.hide(e), e._ripple = e._ripple ?? {}, e._ripple.enabled = s, e._ripple.centered = i.center, e._ripple.circle = i.circle, io(r) && r.class && (e._ripple.class = r.class), s && !n) {
    if (i.stop) {
      e.addEventListener("touchstart", Yl, {
        passive: !0
      }), e.addEventListener("mousedown", Yl);
      return;
    }
    e.addEventListener("touchstart", Vr, {
      passive: !0
    }), e.addEventListener("touchend", $e, {
      passive: !0
    }), e.addEventListener("touchmove", Xd, {
      passive: !0
    }), e.addEventListener("touchcancel", $e), e.addEventListener("mousedown", Vr), e.addEventListener("mouseup", $e), e.addEventListener("mouseleave", $e), e.addEventListener("keydown", Qd), e.addEventListener("keyup", Zd), e.addEventListener("blur", ef), e.addEventListener("dragstart", $e, {
      passive: !0
    });
  } else
    !s && n && nf(e);
}
function nf(e) {
  e.removeEventListener("mousedown", Vr), e.removeEventListener("touchstart", Vr), e.removeEventListener("touchend", $e), e.removeEventListener("touchmove", Xd), e.removeEventListener("touchcancel", $e), e.removeEventListener("mouseup", $e), e.removeEventListener("mouseleave", $e), e.removeEventListener("keydown", Qd), e.removeEventListener("keyup", Zd), e.removeEventListener("dragstart", $e), e.removeEventListener("blur", ef);
}
function Zb(e, t) {
  tf(e, t, !1);
}
function ew(e) {
  delete e._ripple, nf(e);
}
function tw(e, t) {
  if (t.value === t.oldValue)
    return;
  const n = Yd(t.oldValue);
  tf(e, t, n);
}
const os = {
  mounted: Zb,
  unmounted: ew,
  updated: tw
}, qr = z({
  border: [Boolean, Number, String]
}, "border");
function Kr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot();
  return {
    borderClasses: y(() => {
      const r = K(e) ? e.value : e.border, i = [];
      if (r === !0 || r === "")
        i.push(`${t}--border`);
      else if (typeof r == "string" || r === 0)
        for (const s of String(r).split(" "))
          i.push(`border-${s}`);
      return i;
    })
  };
}
const Qn = z({
  elevation: {
    type: [Number, String],
    validator(e) {
      const t = parseInt(e);
      return !isNaN(t) && t >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      t <= 24;
    }
  }
}, "elevation");
function Zn(e) {
  return {
    elevationClasses: y(() => {
      const n = K(e) ? e.value : e.elevation, r = [];
      return n == null || r.push(`elevation-${n}`), r;
    })
  };
}
function nw() {
  var e, t;
  return (t = (e = Ue("useRouter")) == null ? void 0 : e.proxy) == null ? void 0 : t.$router;
}
function da(e, t) {
  const n = Iv("RouterLink"), r = y(() => !!(e.href || e.to)), i = y(() => (r == null ? void 0 : r.value) || $l(t, "click") || $l(e, "click"));
  if (typeof n == "string")
    return {
      isLink: r,
      isClickable: i,
      href: U(e, "href")
    };
  const s = e.to ? n.useLink(e) : void 0;
  return {
    isLink: r,
    isClickable: i,
    route: s == null ? void 0 : s.route,
    navigate: s == null ? void 0 : s.navigate,
    isActive: s && y(() => {
      var o, a;
      return e.exact ? (o = s.isExactActive) == null ? void 0 : o.value : (a = s.isActive) == null ? void 0 : a.value;
    }),
    href: y(() => e.to ? s == null ? void 0 : s.route.value.href : e.href)
  };
}
const fa = z({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let Rs = !1;
function rw(e, t) {
  let n = !1, r, i;
  He && (Oe(() => {
    window.addEventListener("popstate", s), r = e == null ? void 0 : e.beforeEach((o, a, l) => {
      Rs ? n ? t(l) : l() : setTimeout(() => n ? t(l) : l()), Rs = !0;
    }), i = e == null ? void 0 : e.afterEach(() => {
      Rs = !1;
    });
  }), xe(() => {
    window.removeEventListener("popstate", s), r == null || r(), i == null || i();
  }));
  function s(o) {
    var a;
    (a = o.state) != null && a.replaced || (n = !0, setTimeout(() => n = !1));
  }
}
const fo = H()({
  name: "VListItem",
  directives: {
    Ripple: os
  },
  props: {
    active: {
      type: Boolean,
      default: void 0
    },
    activeClass: String,
    activeColor: String,
    appendAvatar: String,
    appendIcon: oe,
    disabled: Boolean,
    lines: String,
    link: {
      type: Boolean,
      default: void 0
    },
    nav: Boolean,
    prependAvatar: String,
    prependIcon: oe,
    ripple: {
      type: Boolean,
      default: !0
    },
    subtitle: [String, Number, Boolean],
    title: [String, Number, Boolean],
    value: null,
    onClick: gn,
    onClickOnce: gn,
    ...qr(),
    ...lt(),
    ...An(),
    ...Qn(),
    ...Qt(),
    ...fa(),
    ..._e(),
    ...Ie(),
    ...Pn({
      variant: "text"
    })
  },
  emits: {
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: r,
      emit: i
    } = t;
    const s = da(e, n), o = y(() => e.value ?? s.href.value), {
      select: a,
      isSelected: l,
      isIndeterminate: c,
      isGroupActivator: d,
      root: u,
      parent: f,
      openOnSelect: h
    } = Wd(o, !1), m = Fd(), g = y(() => {
      var M;
      return e.active !== !1 && (e.active || ((M = s.isActive) == null ? void 0 : M.value) || l.value);
    }), w = y(() => e.link !== !1 && s.isLink.value), C = y(() => !e.disabled && e.link !== !1 && (e.link || s.isClickable.value || e.value != null && !!m)), E = y(() => e.rounded || e.nav), p = y(() => ({
      color: g.value ? e.activeColor ?? e.color : e.color,
      variant: e.variant
    }));
    te(() => {
      var M;
      return (M = s.isActive) == null ? void 0 : M.value;
    }, (M) => {
      M && f.value != null && u.open(f.value, !0), M && h(M);
    }, {
      immediate: !0
    });
    const {
      themeClasses: O
    } = Ve(e), {
      borderClasses: A
    } = Kr(e), {
      colorClasses: N,
      colorStyles: I,
      variantClasses: _
    } = Gr(p), {
      densityClasses: b
    } = mt(e), {
      dimensionStyles: S
    } = Nn(e), {
      elevationClasses: P
    } = Zn(e), {
      roundedClasses: k
    } = Zt(E), R = y(() => e.lines ? `v-list-item--${e.lines}-line` : void 0), x = y(() => ({
      isActive: g.value,
      select: a,
      isSelected: l.value,
      isIndeterminate: c.value
    }));
    function j(M) {
      var ee;
      i("click", M), !(d || !C.value) && ((ee = s.navigate) == null || ee.call(s, M), e.value != null && a(!l.value, M));
    }
    function G(M) {
      (M.key === "Enter" || M.key === " ") && (M.preventDefault(), j(M));
    }
    return J(() => {
      const M = w.value ? "a" : e.tag, ee = !m || l.value || g.value, Z = r.title || e.title, $ = r.subtitle || e.subtitle, W = !!(e.appendAvatar || e.appendIcon), ae = !!(W || r.append), Qe = !!(e.prependAvatar || e.prependIcon), Ze = !!(Qe || r.prepend);
      return m == null || m.updateHasPrepend(Ze), Ae(v(M, {
        class: ["v-list-item", {
          "v-list-item--active": g.value,
          "v-list-item--disabled": e.disabled,
          "v-list-item--link": C.value,
          "v-list-item--nav": e.nav,
          "v-list-item--prepend": !Ze && (m == null ? void 0 : m.hasPrepend.value),
          [`${e.activeClass}`]: e.activeClass && g.value
        }, O.value, A.value, ee ? N.value : void 0, b.value, P.value, R.value, k.value, _.value],
        style: [ee ? I.value : void 0, S.value],
        href: s.href.value,
        tabindex: C.value ? 0 : void 0,
        onClick: j,
        onKeydown: C.value && !w.value && G
      }, {
        default: () => {
          var en;
          return [zr(C.value || g.value, "v-list-item"), Ze && v("div", {
            key: "prepend",
            class: "v-list-item__prepend"
          }, [r.prepend ? v(Ge, {
            key: "prepend-defaults",
            disabled: !Qe,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.prependAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.prependIcon
              },
              VListItemAction: {
                start: !0
              }
            }
          }, {
            default: () => {
              var ce;
              return [(ce = r.prepend) == null ? void 0 : ce.call(r, x.value)];
            }
          }) : v(Pe, null, [e.prependAvatar && v(Hi, {
            key: "prepend-avatar",
            density: e.density,
            image: e.prependAvatar
          }, null), e.prependIcon && v(pe, {
            key: "prepend-icon",
            density: e.density,
            icon: e.prependIcon
          }, null)])]), v("div", {
            class: "v-list-item__content",
            "data-no-activator": ""
          }, [Z && v(Yb, {
            key: "title"
          }, {
            default: () => {
              var ce;
              return [((ce = r.title) == null ? void 0 : ce.call(r, {
                title: e.title
              })) ?? e.title];
            }
          }), $ && v(Jb, {
            key: "subtitle"
          }, {
            default: () => {
              var ce;
              return [((ce = r.subtitle) == null ? void 0 : ce.call(r, {
                subtitle: e.subtitle
              })) ?? e.subtitle];
            }
          }), (en = r.default) == null ? void 0 : en.call(r, x.value)]), ae && v("div", {
            key: "append",
            class: "v-list-item__append"
          }, [r.append ? v(Ge, {
            key: "append-defaults",
            disabled: !W,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.appendAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.appendIcon
              },
              VListItemAction: {
                end: !0
              }
            }
          }, {
            default: () => {
              var ce;
              return [(ce = r.append) == null ? void 0 : ce.call(r, x.value)];
            }
          }) : v(Pe, null, [e.appendIcon && v(pe, {
            key: "append-icon",
            density: e.density,
            icon: e.appendIcon
          }, null), e.appendAvatar && v(Hi, {
            key: "append-avatar",
            density: e.density,
            image: e.appendAvatar
          }, null)])])];
        }
      }), [[Tt("ripple"), C.value && e.ripple]]);
    }), {};
  }
}), iw = H()({
  name: "VListSubheader",
  props: {
    color: String,
    inset: Boolean,
    sticky: Boolean,
    title: String,
    ..._e()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: r,
      textColorStyles: i
    } = ot(U(e, "color"));
    return J(() => {
      const s = !!(n.default || e.title);
      return v(e.tag, {
        class: ["v-list-subheader", {
          "v-list-subheader--inset": e.inset,
          "v-list-subheader--sticky": e.sticky
        }, r.value],
        style: {
          textColorStyles: i
        }
      }, {
        default: () => {
          var o;
          return [s && v("div", {
            class: "v-list-subheader__text"
          }, [((o = n.default) == null ? void 0 : o.call(n)) ?? e.title])];
        }
      });
    }), {};
  }
}), rf = H()({
  name: "VListChildren",
  props: {
    items: Array
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Bd(), () => {
      var r, i;
      return ((r = n.default) == null ? void 0 : r.call(n)) ?? ((i = e.items) == null ? void 0 : i.map((s) => {
        var h, m;
        let {
          children: o,
          props: a,
          type: l,
          raw: c
        } = s;
        if (l === "divider")
          return ((h = n.divider) == null ? void 0 : h.call(n, {
            props: a
          })) ?? v(Ob, a, null);
        if (l === "subheader")
          return ((m = n.subheader) == null ? void 0 : m.call(n, {
            props: a
          })) ?? v(iw, a, {
            default: n.subheader
          });
        const d = {
          subtitle: n.subtitle ? (g) => {
            var w;
            return (w = n.subtitle) == null ? void 0 : w.call(n, {
              ...g,
              item: c
            });
          } : void 0,
          prepend: n.prepend ? (g) => {
            var w;
            return (w = n.prepend) == null ? void 0 : w.call(n, {
              ...g,
              item: c
            });
          } : void 0,
          append: n.append ? (g) => {
            var w;
            return (w = n.append) == null ? void 0 : w.call(n, {
              ...g,
              item: c
            });
          } : void 0,
          default: n.default ? (g) => {
            var w;
            return (w = n.default) == null ? void 0 : w.call(n, {
              ...g,
              item: c
            });
          } : void 0,
          title: n.title ? (g) => {
            var w;
            return (w = n.title) == null ? void 0 : w.call(n, {
              ...g,
              item: c
            });
          } : void 0
        }, [u, f] = Kl.filterProps(a);
        return o ? v(Kl, re({
          value: a == null ? void 0 : a.value
        }, u), {
          activator: (g) => {
            let {
              props: w
            } = g;
            return n.header ? n.header({
              props: {
                ...a,
                ...w
              }
            }) : v(fo, re(a, w), d);
          },
          default: () => v(rf, {
            items: o
          }, n)
        }) : n.item ? n.item(a) : v(fo, a, d);
      }));
    };
  }
}), sw = z({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean
}, "item");
function ow(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean";
}
function aw(e, t) {
  const n = nr(t, e.itemType, "item"), r = ow(t) ? t : nr(t, e.itemTitle), i = nr(t, e.itemValue, void 0), s = nr(t, e.itemChildren), o = e.itemProps === !0 ? Wr(t, ["children"])[1] : nr(t, e.itemProps), a = {
    title: r,
    value: i,
    ...o
  };
  return {
    type: n,
    title: a.title,
    value: a.value,
    props: a,
    children: n === "item" && s ? sf(e, s) : void 0,
    raw: t
  };
}
function sf(e, t) {
  const n = [];
  for (const r of t)
    n.push(aw(e, r));
  return n;
}
function lw(e) {
  return {
    items: y(() => sf(e, e.items))
  };
}
const cw = H()({
  name: "VList",
  props: {
    activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    lines: {
      type: [Boolean, String],
      default: "one"
    },
    nav: Boolean,
    ...$b({
      selectStrategy: "single-leaf",
      openStrategy: "list"
    }),
    ...qr(),
    ...lt(),
    ...An(),
    ...Qn(),
    itemType: {
      type: String,
      default: "type"
    },
    ...sw(),
    ...Qt(),
    ..._e(),
    ...Ie(),
    ...Pn({
      variant: "text"
    })
  },
  emits: {
    "update:selected": (e) => !0,
    "update:opened": (e) => !0,
    "click:open": (e) => !0,
    "click:select": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: r
    } = lw(e), {
      themeClasses: i
    } = Ve(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: o
    } = zn(U(e, "bgColor")), {
      borderClasses: a
    } = Kr(e), {
      densityClasses: l
    } = mt(e), {
      dimensionStyles: c
    } = Nn(e), {
      elevationClasses: d
    } = Zn(e), {
      roundedClasses: u
    } = Zt(e), {
      open: f,
      select: h
    } = Mb(e), m = y(() => e.lines ? `v-list--${e.lines}-line` : void 0), g = U(e, "activeColor"), w = U(e, "color");
    Bd(), On({
      VListGroup: {
        activeColor: g,
        color: w
      },
      VListItem: {
        activeClass: U(e, "activeClass"),
        activeColor: g,
        color: w,
        density: U(e, "density"),
        disabled: U(e, "disabled"),
        lines: U(e, "lines"),
        nav: U(e, "nav"),
        variant: U(e, "variant")
      }
    });
    const C = D(!1), E = D();
    function p(_) {
      C.value = !0;
    }
    function O(_) {
      C.value = !1;
    }
    function A(_) {
      var b;
      !C.value && !(_.relatedTarget && ((b = E.value) != null && b.contains(_.relatedTarget))) && I();
    }
    function N(_) {
      if (E.value) {
        if (_.key === "ArrowDown")
          I("next");
        else if (_.key === "ArrowUp")
          I("prev");
        else if (_.key === "Home")
          I("first");
        else if (_.key === "End")
          I("last");
        else
          return;
        _.preventDefault();
      }
    }
    function I(_) {
      var P, k, R;
      if (!E.value)
        return;
      const b = [...E.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter((x) => !x.hasAttribute("disabled")), S = b.indexOf(document.activeElement);
      if (!_)
        E.value.contains(document.activeElement) || (P = b[0]) == null || P.focus();
      else if (_ === "first")
        (k = b[0]) == null || k.focus();
      else if (_ === "last")
        (R = b.at(-1)) == null || R.focus();
      else {
        let x, j = S;
        const G = _ === "next" ? 1 : -1;
        do
          j += G, x = b[j];
        while ((!x || x.offsetParent == null) && j < b.length && j >= 0);
        x ? x.focus() : I(_ === "next" ? "first" : "last");
      }
    }
    return J(() => v(e.tag, {
      ref: E,
      class: ["v-list", {
        "v-list--disabled": e.disabled,
        "v-list--nav": e.nav
      }, i.value, s.value, a.value, l.value, d.value, m.value, u.value],
      style: [o.value, c.value],
      role: "listbox",
      "aria-activedescendant": void 0,
      onFocusin: p,
      onFocusout: O,
      onFocus: A,
      onKeydown: N
    }, {
      default: () => [v(rf, {
        items: r.value
      }, n)]
    })), {
      open: f,
      select: h,
      focus: I
    };
  }
}), as = {
  __name: "AuthBranding",
  setup(e) {
    const t = Xe(), { config: n } = Tn(t);
    return (r, i) => (F(), X(cw, {
      lines: "two",
      dense: ""
    }, {
      default: V(() => [
        v(fo, {
          title: T(n).title,
          subtitle: T(n).subtitle
        }, {
          title: V(() => [
            v(pe, {
              color: T(n).iconColor
            }, {
              default: V(() => [
                q(it(T(n).icon), 1)
              ]),
              _: 1
            }, 8, ["color"]),
            q(" " + it(T(n).title), 1)
          ]),
          _: 1
        }, 8, ["title", "subtitle"])
      ]),
      _: 1
    }));
  }
};
const uw = Xn("v-alert-title");
const of = z({
  divided: Boolean,
  ...qr(),
  ...lt(),
  ...Qn(),
  ...Qt(),
  ..._e(),
  ...Ie(),
  ...Pn()
}, "v-btn-group"), Xl = H()({
  name: "VBtnGroup",
  props: of(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: r
    } = Ve(e), {
      densityClasses: i
    } = mt(e), {
      borderClasses: s
    } = Kr(e), {
      elevationClasses: o
    } = Zn(e), {
      roundedClasses: a
    } = Zt(e);
    On({
      VBtn: {
        height: "auto",
        color: U(e, "color"),
        density: U(e, "density"),
        flat: !0,
        variant: U(e, "variant")
      }
    }), J(() => v(e.tag, {
      class: ["v-btn-group", {
        "v-btn-group--divided": e.divided
      }, r.value, s.value, i.value, o.value, a.value]
    }, n));
  }
}), af = z({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group"), lf = z({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function cf(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const r = Ue("useGroupItem");
  if (!r)
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  const i = vt();
  Je(Symbol.for(`${t.description}:id`), i);
  const s = me(t, null);
  if (!s) {
    if (!n)
      return s;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`);
  }
  const o = U(e, "value"), a = y(() => s.disabled.value || e.disabled);
  s.register({
    id: i,
    value: o,
    disabled: a
  }, r), Kt(() => {
    s.unregister(i);
  });
  const l = y(() => s.isSelected(i)), c = y(() => l.value && [s.selectedClass.value, e.selectedClass]);
  return te(l, (d) => {
    r.emit("group:selected", {
      value: d
    });
  }), {
    id: i,
    isSelected: l,
    toggle: () => s.select(i, !l.value),
    select: (d) => s.select(i, d),
    selectedClass: c,
    value: o,
    disabled: a,
    group: s
  };
}
function ha(e, t) {
  let n = !1;
  const r = In([]), i = be(e, "modelValue", [], (f) => f == null ? [] : uf(r, mn(f)), (f) => {
    const h = fw(r, f);
    return e.multiple ? h : h[0];
  }), s = Ue("useGroup");
  function o(f, h) {
    const m = f, g = Symbol.for(`${t.description}:id`), C = _i(g, s == null ? void 0 : s.vnode).indexOf(h);
    C > -1 ? r.splice(C, 0, m) : r.push(m);
  }
  function a(f) {
    if (n)
      return;
    l();
    const h = r.findIndex((m) => m.id === f);
    r.splice(h, 1);
  }
  function l() {
    const f = r.find((h) => !h.disabled);
    f && e.mandatory === "force" && !i.value.length && (i.value = [f.id]);
  }
  qt(() => {
    l();
  }), Kt(() => {
    n = !0;
  });
  function c(f, h) {
    const m = r.find((g) => g.id === f);
    if (!(h && (m != null && m.disabled)))
      if (e.multiple) {
        const g = i.value.slice(), w = g.findIndex((E) => E === f), C = ~w;
        if (h = h ?? !C, C && e.mandatory && g.length <= 1 || !C && e.max != null && g.length + 1 > e.max)
          return;
        w < 0 && h ? g.push(f) : w >= 0 && !h && g.splice(w, 1), i.value = g;
      } else {
        const g = i.value.includes(f);
        if (e.mandatory && g)
          return;
        i.value = h ?? !g ? [f] : [];
      }
  }
  function d(f) {
    if (e.multiple && sa('This method is not supported when using "multiple" prop'), i.value.length) {
      const h = i.value[0], m = r.findIndex((C) => C.id === h);
      let g = (m + f) % r.length, w = r[g];
      for (; w.disabled && g !== m; )
        g = (g + f) % r.length, w = r[g];
      if (w.disabled)
        return;
      i.value = [r[g].id];
    } else {
      const h = r.find((m) => !m.disabled);
      h && (i.value = [h.id]);
    }
  }
  const u = {
    register: o,
    unregister: a,
    selected: i,
    select: c,
    disabled: U(e, "disabled"),
    prev: () => d(r.length - 1),
    next: () => d(1),
    isSelected: (f) => i.value.includes(f),
    selectedClass: y(() => e.selectedClass),
    items: y(() => r),
    getItemIndex: (f) => dw(r, f)
  };
  return Je(t, u), u;
}
function dw(e, t) {
  const n = uf(e, [t]);
  return n.length ? e.findIndex((r) => r.id === n[0]) : -1;
}
function uf(e, t) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    i.value != null ? t.find((s) => ea(s, i.value)) != null && n.push(i.id) : t.includes(r) && n.push(i.id);
  }
  return n;
}
function fw(e, t) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    t.includes(i.id) && n.push(i.value != null ? i.value : r);
  }
  return n;
}
const df = Symbol.for("vuetify:v-btn-toggle");
H()({
  name: "VBtnToggle",
  props: {
    ...of(),
    ...af()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: r,
      next: i,
      prev: s,
      select: o,
      selected: a
    } = ha(e, df);
    return J(() => {
      const [l] = Xl.filterProps(e);
      return v(Xl, re({
        class: "v-btn-toggle"
      }, l), {
        default: () => {
          var c;
          return [(c = n.default) == null ? void 0 : c.call(n, {
            isSelected: r,
            next: i,
            prev: s,
            select: o,
            selected: a
          })];
        }
      });
    }), {
      next: i,
      prev: s,
      select: o
    };
  }
});
function ff(e) {
  const t = D(), n = D(!1);
  if (la) {
    const r = new IntersectionObserver((i) => {
      e == null || e(i, r), n.value = !!i.find((s) => s.isIntersecting);
    });
    Kt(() => {
      r.disconnect();
    }), te(t, (i, s) => {
      s && (r.unobserve(s), n.value = !1), i && r.observe(i);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: t,
    isIntersecting: n
  };
}
function ho(e) {
  const t = D(), n = D();
  if (He) {
    const r = new ResizeObserver((i) => {
      e == null || e(i, r), i.length && (n.value = i[0].contentRect);
    });
    Kt(() => {
      r.disconnect();
    }), te(t, (i, s) => {
      s && (r.unobserve(s), n.value = void 0), i && r.observe(i);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef: t,
    contentRect: $r(n)
  };
}
const hw = H()({
  name: "VProgressCircular",
  props: {
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
      type: [Number, String],
      default: 0
    },
    rotate: {
      type: [Number, String],
      default: 0
    },
    width: {
      type: [Number, String],
      default: 4
    },
    ...rs(),
    ..._e({
      tag: "div"
    }),
    ...Ie()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = 20, i = 2 * Math.PI * r, s = D(), {
      themeClasses: o
    } = Ve(e), {
      sizeClasses: a,
      sizeStyles: l
    } = is(e), {
      textColorClasses: c,
      textColorStyles: d
    } = ot(U(e, "color")), {
      textColorClasses: u,
      textColorStyles: f
    } = ot(U(e, "bgColor")), {
      intersectionRef: h,
      isIntersecting: m
    } = ff(), {
      resizeRef: g,
      contentRect: w
    } = ho(), C = y(() => Math.max(0, Math.min(100, parseFloat(e.modelValue)))), E = y(() => Number(e.width)), p = y(() => l.value ? Number(e.size) : w.value ? w.value.width : Math.max(E.value, 32)), O = y(() => r / (1 - E.value / p.value) * 2), A = y(() => E.value / p.value * O.value), N = y(() => Y((100 - C.value) / 100 * i));
    return Gn(() => {
      h.value = s.value, g.value = s.value;
    }), J(() => v(e.tag, {
      ref: s,
      class: ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!e.indeterminate,
        "v-progress-circular--visible": m.value,
        "v-progress-circular--disable-shrink": e.indeterminate === "disable-shrink"
      }, o.value, a.value, c.value],
      style: [l.value, d.value],
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": e.indeterminate ? void 0 : C.value
    }, {
      default: () => [v("svg", {
        style: {
          transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))`
        },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${O.value} ${O.value}`
      }, [v("circle", {
        class: ["v-progress-circular__underlay", u.value],
        style: f.value,
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r,
        "stroke-width": A.value,
        "stroke-dasharray": i,
        "stroke-dashoffset": 0
      }, null), v("circle", {
        class: "v-progress-circular__overlay",
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r,
        "stroke-width": A.value,
        "stroke-dasharray": i,
        "stroke-dashoffset": N.value
      }, null)]), n.default && v("div", {
        class: "v-progress-circular__content"
      }, [n.default({
        value: C.value
      })])]
    })), {};
  }
});
const hf = Symbol.for("vuetify:locale");
function va() {
  const e = me(hf);
  if (!e)
    throw new Error("[Vuetify] Could not find injected locale instance");
  return e;
}
function Jr() {
  const e = me(hf);
  if (!e)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: e.isRtl,
    rtlClasses: e.rtlClasses
  };
}
const Ql = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, ls = z({
  location: String
}, "location");
function cs(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: r
  } = Jr();
  return {
    locationStyles: y(() => {
      if (!e.location)
        return {};
      const {
        side: s,
        align: o
      } = oo(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, r.value);
      function a(c) {
        return n ? n(c) : 0;
      }
      const l = {};
      return s !== "center" && (t ? l[Ql[s]] = `calc(100% - ${a(s)}px)` : l[s] = 0), o !== "center" ? t ? l[Ql[o]] = `calc(100% - ${a(o)}px)` : l[o] = 0 : (s === "center" ? l.top = l.left = "50%" : l[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[s]] = "50%", l.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[s]), l;
    })
  };
}
const vf = H()({
  name: "VProgressLinear",
  props: {
    absolute: Boolean,
    active: {
      type: Boolean,
      default: !0
    },
    bgColor: String,
    bgOpacity: [Number, String],
    bufferValue: {
      type: [Number, String],
      default: 0
    },
    clickable: Boolean,
    color: String,
    height: {
      type: [Number, String],
      default: 4
    },
    indeterminate: Boolean,
    max: {
      type: [Number, String],
      default: 100
    },
    modelValue: {
      type: [Number, String],
      default: 0
    },
    reverse: Boolean,
    stream: Boolean,
    striped: Boolean,
    roundedBar: Boolean,
    ...ls({
      location: "top"
    }),
    ...Qt(),
    ..._e(),
    ...Ie()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = be(e, "modelValue"), {
      isRtl: i
    } = Jr(), {
      themeClasses: s
    } = Ve(e), {
      locationStyles: o
    } = cs(e), {
      textColorClasses: a,
      textColorStyles: l
    } = ot(e, "color"), {
      backgroundColorClasses: c,
      backgroundColorStyles: d
    } = zn(y(() => e.bgColor || e.color)), {
      backgroundColorClasses: u,
      backgroundColorStyles: f
    } = zn(e, "color"), {
      roundedClasses: h
    } = Zt(e), {
      intersectionRef: m,
      isIntersecting: g
    } = ff(), w = y(() => parseInt(e.max, 10)), C = y(() => parseInt(e.height, 10)), E = y(() => parseFloat(e.bufferValue) / w.value * 100), p = y(() => parseFloat(r.value) / w.value * 100), O = y(() => i.value !== e.reverse), A = y(() => e.indeterminate ? "fade-transition" : "slide-x-transition"), N = y(() => e.bgOpacity == null ? e.bgOpacity : parseFloat(e.bgOpacity));
    function I(_) {
      if (!m.value)
        return;
      const {
        left: b,
        right: S,
        width: P
      } = m.value.getBoundingClientRect(), k = O.value ? P - _.clientX + (S - P) : _.clientX - b;
      r.value = Math.round(k / P * w.value);
    }
    return J(() => v(e.tag, {
      ref: m,
      class: ["v-progress-linear", {
        "v-progress-linear--absolute": e.absolute,
        "v-progress-linear--active": e.active && g.value,
        "v-progress-linear--reverse": O.value,
        "v-progress-linear--rounded": e.rounded,
        "v-progress-linear--rounded-bar": e.roundedBar,
        "v-progress-linear--striped": e.striped
      }, h.value, s.value],
      style: {
        bottom: e.location === "bottom" ? 0 : void 0,
        top: e.location === "top" ? 0 : void 0,
        height: e.active ? Y(C.value) : 0,
        "--v-progress-linear-height": Y(C.value),
        ...o.value
      },
      role: "progressbar",
      "aria-hidden": e.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      "aria-valuenow": e.indeterminate ? void 0 : p.value,
      onClick: e.clickable && I
    }, {
      default: () => [e.stream && v("div", {
        key: "stream",
        class: ["v-progress-linear__stream", a.value],
        style: {
          ...l.value,
          [O.value ? "left" : "right"]: Y(-C.value),
          borderTop: `${Y(C.value / 2)} dotted`,
          opacity: N.value,
          top: `calc(50% - ${Y(C.value / 4)})`,
          width: Y(100 - E.value, "%"),
          "--v-progress-linear-stream-to": Y(C.value * (O.value ? 1 : -1))
        }
      }, null), v("div", {
        class: ["v-progress-linear__background", c.value],
        style: [d.value, {
          opacity: N.value,
          width: Y(e.stream ? E.value : 100, "%")
        }]
      }, null), v(Ct, {
        name: A.value
      }, {
        default: () => [e.indeterminate ? v("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((_) => v("div", {
          key: _,
          class: ["v-progress-linear__indeterminate", _, u.value],
          style: f.value
        }, null))]) : v("div", {
          class: ["v-progress-linear__determinate", u.value],
          style: [f.value, {
            width: Y(p.value, "%")
          }]
        }, null)]
      }), n.default && v("div", {
        class: "v-progress-linear__content"
      }, [n.default({
        value: p.value,
        buffer: E.value
      })])]
    })), {};
  }
}), ma = z({
  loading: [Boolean, String]
}, "loader");
function ga(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot();
  return {
    loaderClasses: y(() => ({
      [`${t}--loading`]: e.loading
    }))
  };
}
function mf(e, t) {
  var r;
  let {
    slots: n
  } = t;
  return v("div", {
    class: `${e.name}__loader`
  }, [((r = n.default) == null ? void 0 : r.call(n, {
    color: e.color,
    isActive: e.active
  })) || v(vf, {
    active: e.active,
    color: e.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const vw = ["static", "relative", "fixed", "absolute", "sticky"], pa = z({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (e) => vw.includes(e)
    )
  }
}, "position");
function ya(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot();
  return {
    positionClasses: y(() => e.position ? `${t}--${e.position}` : void 0)
  };
}
function mw(e, t) {
  te(() => {
    var n;
    return (n = e.isActive) == null ? void 0 : n.value;
  }, (n) => {
    e.isLink.value && n && t && Oe(() => {
      t(!0);
    });
  }, {
    immediate: !0
  });
}
const gf = z({
  active: {
    type: Boolean,
    default: void 0
  },
  symbol: {
    type: null,
    default: df
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: oe,
  appendIcon: oe,
  block: Boolean,
  stacked: Boolean,
  ripple: {
    type: Boolean,
    default: !0
  },
  ...qr(),
  ...Qt(),
  ...lt(),
  ...An(),
  ...Qn(),
  ...lf(),
  ...ma(),
  ...ls(),
  ...pa(),
  ...fa(),
  ...rs(),
  ..._e({
    tag: "button"
  }),
  ...Ie(),
  ...Pn({
    variant: "elevated"
  })
}, "VBtn"), le = H()({
  name: "VBtn",
  directives: {
    Ripple: os
  },
  props: gf(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: r
    } = t;
    const {
      themeClasses: i
    } = Ve(e), {
      borderClasses: s
    } = Kr(e), {
      colorClasses: o,
      colorStyles: a,
      variantClasses: l
    } = Gr(e), {
      densityClasses: c
    } = mt(e), {
      dimensionStyles: d
    } = Nn(e), {
      elevationClasses: u
    } = Zn(e), {
      loaderClasses: f
    } = ga(e), {
      locationStyles: h
    } = cs(e), {
      positionClasses: m
    } = ya(e), {
      roundedClasses: g
    } = Zt(e), {
      sizeClasses: w,
      sizeStyles: C
    } = is(e), E = cf(e, e.symbol, !1), p = da(e, n), O = y(() => {
      var _;
      return e.active !== void 0 ? e.active : p.isLink.value ? (_ = p.isActive) == null ? void 0 : _.value : E == null ? void 0 : E.isSelected.value;
    }), A = y(() => (E == null ? void 0 : E.disabled.value) || e.disabled), N = y(() => e.variant === "elevated" && !(e.disabled || e.flat || e.border)), I = y(() => {
      if (e.value !== void 0)
        return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value;
    });
    return mw(p, E == null ? void 0 : E.select), J(() => {
      var R, x;
      const _ = p.isLink.value ? "a" : e.tag, b = !!(e.prependIcon || r.prepend), S = !!(e.appendIcon || r.append), P = !!(e.icon && e.icon !== !0), k = (E == null ? void 0 : E.isSelected.value) && (!p.isLink.value || ((R = p.isActive) == null ? void 0 : R.value)) || !E || ((x = p.isActive) == null ? void 0 : x.value);
      return Ae(v(_, {
        type: _ === "a" ? void 0 : "button",
        class: ["v-btn", E == null ? void 0 : E.selectedClass.value, {
          "v-btn--active": O.value,
          "v-btn--block": e.block,
          "v-btn--disabled": A.value,
          "v-btn--elevated": N.value,
          "v-btn--flat": e.flat,
          "v-btn--icon": !!e.icon,
          "v-btn--loading": e.loading,
          "v-btn--stacked": e.stacked
        }, i.value, s.value, k ? o.value : void 0, c.value, u.value, f.value, m.value, g.value, w.value, l.value],
        style: [k ? a.value : void 0, d.value, h.value, C.value],
        disabled: A.value || void 0,
        href: p.href.value,
        onClick: (j) => {
          var G;
          A.value || ((G = p.navigate) == null || G.call(p, j), E == null || E.toggle());
        },
        value: I.value
      }, {
        default: () => {
          var j;
          return [zr(!0, "v-btn"), !e.icon && b && v("span", {
            key: "prepend",
            class: "v-btn__prepend"
          }, [r.prepend ? v(Ge, {
            key: "prepend-defaults",
            disabled: !e.prependIcon,
            defaults: {
              VIcon: {
                icon: e.prependIcon
              }
            }
          }, r.prepend) : v(pe, {
            key: "prepend-icon",
            icon: e.prependIcon
          }, null)]), v("span", {
            class: "v-btn__content",
            "data-no-activator": ""
          }, [!r.default && P ? v(pe, {
            key: "content-icon",
            icon: e.icon
          }, null) : v(Ge, {
            key: "content-defaults",
            disabled: !P,
            defaults: {
              VIcon: {
                icon: e.icon
              }
            }
          }, r.default)]), !e.icon && S && v("span", {
            key: "append",
            class: "v-btn__append"
          }, [r.append ? v(Ge, {
            key: "append-defaults",
            disabled: !e.appendIcon,
            defaults: {
              VIcon: {
                icon: e.appendIcon
              }
            }
          }, r.append) : v(pe, {
            key: "append-icon",
            icon: e.appendIcon
          }, null)]), !!e.loading && v("span", {
            key: "loader",
            class: "v-btn__loader"
          }, [((j = r.loader) == null ? void 0 : j.call(r)) ?? v(hw, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            size: "23",
            width: "2"
          }, null)])];
        }
      }), [[Tt("ripple"), !A.value && e.ripple, null]]);
    }), {};
  }
}), gw = ["success", "info", "warning", "error"], Yr = H()({
  name: "VAlert",
  props: {
    border: {
      type: [Boolean, String],
      validator: (e) => typeof e == "boolean" || ["top", "end", "bottom", "start"].includes(e)
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
      type: oe,
      default: "$close"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    icon: {
      type: [Boolean, String, Function, Object],
      default: null
    },
    modelValue: {
      type: Boolean,
      default: !0
    },
    prominent: Boolean,
    title: String,
    text: String,
    type: {
      type: String,
      validator: (e) => gw.includes(e)
    },
    ...lt(),
    ...An(),
    ...Qn(),
    ...ls(),
    ...pa(),
    ...Qt(),
    ..._e(),
    ...Ie(),
    ...Pn({
      variant: "flat"
    })
  },
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: r
    } = t;
    const i = be(e, "modelValue"), s = y(() => {
      if (e.icon !== !1)
        return e.type ? e.icon ?? `$${e.type}` : e.icon;
    }), o = y(() => ({
      color: e.color ?? e.type,
      variant: e.variant
    })), {
      themeClasses: a
    } = Ve(e), {
      colorClasses: l,
      colorStyles: c,
      variantClasses: d
    } = Gr(o), {
      densityClasses: u
    } = mt(e), {
      dimensionStyles: f
    } = Nn(e), {
      elevationClasses: h
    } = Zn(e), {
      locationStyles: m
    } = cs(e), {
      positionClasses: g
    } = ya(e), {
      roundedClasses: w
    } = Zt(e), {
      textColorClasses: C,
      textColorStyles: E
    } = ot(U(e, "borderColor")), {
      t: p
    } = va(), O = y(() => ({
      "aria-label": p(e.closeLabel),
      onClick(A) {
        i.value = !1, n("click:close", A);
      }
    }));
    return () => {
      const A = !!(r.prepend || s.value), N = !!(r.title || e.title), I = !!(e.text || r.text), _ = !!(r.close || e.closable);
      return i.value && v(e.tag, {
        class: ["v-alert", e.border && {
          "v-alert--border": !!e.border,
          [`v-alert--border-${e.border === !0 ? "start" : e.border}`]: !0
        }, {
          "v-alert--prominent": e.prominent
        }, a.value, l.value, u.value, h.value, g.value, w.value, d.value],
        style: [c.value, f.value, m.value],
        role: "alert"
      }, {
        default: () => {
          var b, S;
          return [zr(!1, "v-alert"), e.border && v("div", {
            key: "border",
            class: ["v-alert__border", C.value],
            style: E.value
          }, null), A && v("div", {
            key: "prepend",
            class: "v-alert__prepend"
          }, [r.prepend ? v(Ge, {
            key: "prepend-defaults",
            disabled: !s.value,
            defaults: {
              VIcon: {
                density: e.density,
                icon: s.value,
                size: e.prominent ? 44 : 28
              }
            }
          }, r.prepend) : v(pe, {
            key: "prepend-icon",
            density: e.density,
            icon: s.value,
            size: e.prominent ? 44 : 28
          }, null)]), v("div", {
            class: "v-alert__content"
          }, [N && v(uw, {
            key: "title"
          }, {
            default: () => {
              var P;
              return [((P = r.title) == null ? void 0 : P.call(r)) ?? e.title];
            }
          }), I && (((b = r.text) == null ? void 0 : b.call(r)) ?? e.text), (S = r.default) == null ? void 0 : S.call(r)]), r.append && v("div", {
            key: "append",
            class: "v-alert__append"
          }, [r.append()]), _ && v("div", {
            key: "close",
            class: "v-alert__close"
          }, [r.close ? v(Ge, {
            key: "close-defaults",
            defaults: {
              VBtn: {
                icon: e.closeIcon,
                size: "x-small",
                variant: "text"
              }
            }
          }, {
            default: () => {
              var P;
              return [(P = r.close) == null ? void 0 : P.call(r, {
                props: O.value
              })];
            }
          }) : v(le, re({
            key: "close-btn",
            icon: e.closeIcon,
            size: "x-small",
            variant: "text"
          }, O.value), null)])];
        }
      });
    };
  }
});
const Sn = Yn({
  name: "VCardActions",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return On({
      VBtn: {
        variant: "text"
      }
    }), J(() => {
      var r;
      return v("div", {
        class: "v-card-actions"
      }, [(r = n.default) == null ? void 0 : r.call(n)]);
    }), {};
  }
}), pw = Xn("v-card-subtitle"), yw = Xn("v-card-title"), _w = H()({
  name: "VCardItem",
  props: {
    appendAvatar: String,
    appendIcon: oe,
    prependAvatar: String,
    prependIcon: oe,
    subtitle: String,
    title: String,
    ...lt()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return J(() => {
      var c;
      const r = !!(e.prependAvatar || e.prependIcon), i = !!(r || n.prepend), s = !!(e.appendAvatar || e.appendIcon), o = !!(s || n.append), a = !!(e.title || n.title), l = !!(e.subtitle || n.subtitle);
      return v("div", {
        class: "v-card-item"
      }, [i && v("div", {
        key: "prepend",
        class: "v-card-item__prepend"
      }, [n.prepend ? v(Ge, {
        key: "prepend-defaults",
        disabled: !r,
        defaults: {
          VAvatar: {
            density: e.density,
            icon: e.prependIcon,
            image: e.prependAvatar
          }
        }
      }, n.prepend) : r && v(Hi, {
        key: "prepend-avatar",
        density: e.density,
        icon: e.prependIcon,
        image: e.prependAvatar
      }, null)]), v("div", {
        class: "v-card-item__content"
      }, [a && v(yw, {
        key: "title"
      }, {
        default: () => {
          var d;
          return [((d = n.title) == null ? void 0 : d.call(n)) ?? e.title];
        }
      }), l && v(pw, {
        key: "subtitle"
      }, {
        default: () => {
          var d;
          return [((d = n.subtitle) == null ? void 0 : d.call(n)) ?? e.subtitle];
        }
      }), (c = n.default) == null ? void 0 : c.call(n)]), o && v("div", {
        key: "append",
        class: "v-card-item__append"
      }, [n.append ? v(Ge, {
        key: "append-defaults",
        disabled: !s,
        defaults: {
          VAvatar: {
            density: e.density,
            icon: e.appendIcon,
            image: e.appendAvatar
          }
        }
      }, n.append) : s && v(Hi, {
        key: "append-avatar",
        density: e.density,
        icon: e.appendIcon,
        image: e.appendAvatar
      }, null)])]);
    }), {};
  }
}), Ht = Xn("v-card-text"), En = H()({
  name: "VCard",
  directives: {
    Ripple: os
  },
  props: {
    appendAvatar: String,
    appendIcon: oe,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: {
      type: Boolean,
      default: void 0
    },
    prependAvatar: String,
    prependIcon: oe,
    ripple: {
      type: Boolean,
      default: !0
    },
    subtitle: String,
    text: String,
    title: String,
    ...Ie(),
    ...qr(),
    ...lt(),
    ...An(),
    ...Qn(),
    ...ma(),
    ...ls(),
    ...pa(),
    ...Qt(),
    ...fa(),
    ..._e(),
    ...Pn({
      variant: "elevated"
    })
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: r
    } = t;
    const {
      themeClasses: i
    } = Ve(e), {
      borderClasses: s
    } = Kr(e), {
      colorClasses: o,
      colorStyles: a,
      variantClasses: l
    } = Gr(e), {
      densityClasses: c
    } = mt(e), {
      dimensionStyles: d
    } = Nn(e), {
      elevationClasses: u
    } = Zn(e), {
      loaderClasses: f
    } = ga(e), {
      locationStyles: h
    } = cs(e), {
      positionClasses: m
    } = ya(e), {
      roundedClasses: g
    } = Zt(e), w = da(e, n), C = y(() => e.link !== !1 && w.isLink.value), E = y(() => !e.disabled && e.link !== !1 && (e.link || w.isClickable.value));
    return J(() => {
      const p = C.value ? "a" : e.tag, O = !!(r.title || e.title), A = !!(r.subtitle || e.subtitle), N = O || A, I = !!(r.append || e.appendAvatar || e.appendIcon), _ = !!(r.prepend || e.prependAvatar || e.prependIcon), b = !!(r.image || e.image), S = N || _ || I, P = !!(r.text || e.text);
      return Ae(v(p, {
        class: ["v-card", {
          "v-card--disabled": e.disabled,
          "v-card--flat": e.flat,
          "v-card--hover": e.hover && !(e.disabled || e.flat),
          "v-card--link": E.value
        }, i.value, s.value, o.value, c.value, u.value, f.value, m.value, g.value, l.value],
        style: [a.value, d.value, h.value],
        href: w.href.value,
        onClick: E.value && w.navigate,
        tabindex: e.disabled ? -1 : void 0
      }, {
        default: () => {
          var k;
          return [b && v("div", {
            key: "image",
            class: "v-card__image"
          }, [r.image ? v(Ge, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                cover: !0,
                src: e.image
              }
            }
          }, r.image) : v(Kd, {
            key: "image-img",
            cover: !0,
            src: e.image
          }, null)]), v(mf, {
            name: "v-card",
            active: !!e.loading,
            color: typeof e.loading == "boolean" ? void 0 : e.loading
          }, {
            default: r.loader
          }), S && v(_w, {
            key: "item",
            prependAvatar: e.prependAvatar,
            prependIcon: e.prependIcon,
            title: e.title,
            subtitle: e.subtitle,
            appendAvatar: e.appendAvatar,
            appendIcon: e.appendIcon
          }, {
            default: r.item,
            prepend: r.prepend,
            title: r.title,
            subtitle: r.subtitle,
            append: r.append
          }), P && v(Ht, {
            key: "text"
          }, {
            default: () => {
              var R;
              return [((R = r.text) == null ? void 0 : R.call(r)) ?? e.text];
            }
          }), (k = r.default) == null ? void 0 : k.call(r), r.actions && v(Sn, null, {
            default: r.actions
          }), zr(E.value, "v-card")];
        }
      }), [[Tt("ripple"), E.value && e.ripple]]);
    }), {};
  }
});
const bw = H()({
  name: "VMessages",
  props: {
    active: Boolean,
    color: String,
    messages: {
      type: [Array, String],
      default: () => []
    },
    ...ss({
      transition: {
        component: Md,
        leaveAbsolute: !0,
        group: !0
      }
    })
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = y(() => mn(e.messages)), {
      textColorClasses: i,
      textColorStyles: s
    } = ot(y(() => e.color));
    return J(() => v(St, {
      transition: e.transition,
      tag: "div",
      class: ["v-messages", i.value],
      style: s.value,
      role: "alert",
      "aria-live": "polite"
    }, {
      default: () => [e.active && r.value.map((o, a) => v("div", {
        class: "v-messages__message",
        key: `${a}-${r.value}`
      }, [n.message ? n.message({
        message: o
      }) : o]))]
    })), {};
  }
}), pf = Symbol.for("vuetify:form"), ww = z({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function Sw(e) {
  const t = be(e, "modelValue"), n = y(() => e.disabled), r = y(() => e.readonly), i = D(!1), s = D([]), o = D([]);
  async function a() {
    const d = [];
    let u = !0;
    o.value = [], i.value = !0;
    for (const f of s.value) {
      const h = await f.validate();
      if (h.length > 0 && (u = !1, d.push({
        id: f.id,
        errorMessages: h
      })), !u && e.fastFail)
        break;
    }
    return o.value = d, i.value = !1, {
      valid: u,
      errors: o.value
    };
  }
  function l() {
    s.value.forEach((d) => d.reset()), t.value = null;
  }
  function c() {
    s.value.forEach((d) => d.resetValidation()), o.value = [], t.value = null;
  }
  return te(s, () => {
    let d = 0, u = 0;
    const f = [];
    for (const h of s.value)
      h.isValid === !1 ? (u++, f.push({
        id: h.id,
        errorMessages: h.errorMessages
      })) : h.isValid === !0 && d++;
    o.value = f, t.value = u > 0 ? !1 : d === s.value.length ? !0 : null;
  }, {
    deep: !0
  }), Je(pf, {
    register: (d) => {
      let {
        id: u,
        validate: f,
        reset: h,
        resetValidation: m
      } = d;
      s.value.some((g) => g.id === u) && sa(`Duplicate input name "${u}"`), s.value.push({
        id: u,
        validate: f,
        reset: h,
        resetValidation: m,
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (d) => {
      s.value = s.value.filter((u) => u.id !== d);
    },
    update: (d, u, f) => {
      const h = s.value.find((m) => m.id === d);
      h && (h.isValid = u, h.errorMessages = f);
    },
    isDisabled: n,
    isReadonly: r,
    isValidating: i,
    items: s,
    validateOn: U(e, "validateOn")
  }), {
    errors: o,
    isDisabled: n,
    isReadonly: r,
    isValidating: i,
    items: s,
    validate: a,
    reset: l,
    resetValidation: c
  };
}
function Ew() {
  return me(pf, null);
}
const yf = z({
  focused: Boolean
}, "focus");
function _a(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot();
  const n = be(e, "focused"), r = y(() => ({
    [`${t}--focused`]: n.value
  }));
  function i() {
    n.value = !0;
  }
  function s() {
    n.value = !1;
  }
  return {
    focusClasses: r,
    isFocused: n,
    focus: i,
    blur: s
  };
}
const Iw = z({
  disabled: Boolean,
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: Boolean,
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...yf()
}, "validation");
function Cw(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ot(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : vt();
  const r = be(e, "modelValue"), i = y(() => e.validationValue === void 0 ? r.value : e.validationValue), s = Ew(), o = D([]), a = D(!0), l = y(() => !!(mn(r.value === "" ? null : r.value).length || mn(i.value === "" ? null : i.value).length)), c = y(() => !!(e.disabled || s != null && s.isDisabled.value)), d = y(() => !!(e.readonly || s != null && s.isReadonly.value)), u = y(() => e.errorMessages.length ? mn(e.errorMessages).slice(0, Math.max(0, +e.maxErrors)) : o.value), f = y(() => e.error || u.value.length ? !1 : e.rules.length && a.value ? null : !0), h = D(!1), m = y(() => ({
    [`${t}--error`]: f.value === !1,
    [`${t}--dirty`]: l.value,
    [`${t}--disabled`]: c.value,
    [`${t}--readonly`]: d.value
  })), g = y(() => e.name ?? T(n));
  jc(() => {
    s == null || s.register({
      id: g.value,
      validate: p,
      reset: C,
      resetValidation: E
    });
  }), Kt(() => {
    s == null || s.unregister(g.value);
  });
  const w = y(() => e.validateOn || (s == null ? void 0 : s.validateOn.value) || "input");
  qt(() => s == null ? void 0 : s.update(g.value, f.value, u.value)), wn(() => w.value === "input", () => {
    te(i, () => {
      if (i.value != null)
        p();
      else if (e.focused) {
        const O = te(() => e.focused, (A) => {
          A || p(), O();
        });
      }
    });
  }), wn(() => w.value === "blur", () => {
    te(() => e.focused, (O) => {
      O || p();
    });
  }), te(f, () => {
    s == null || s.update(g.value, f.value, u.value);
  });
  function C() {
    E(), r.value = null;
  }
  function E() {
    a.value = !0, o.value = [];
  }
  async function p() {
    const O = [];
    h.value = !0;
    for (const A of e.rules) {
      if (O.length >= +(e.maxErrors ?? 1))
        break;
      const I = await (typeof A == "function" ? A : () => A)(i.value);
      if (I !== !0) {
        if (typeof I != "string") {
          console.warn(`${I} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        O.push(I);
      }
    }
    return o.value = O, h.value = !1, a.value = !1, o.value;
  }
  return {
    errorMessages: u,
    isDirty: l,
    isDisabled: c,
    isReadonly: d,
    isPristine: a,
    isValid: f,
    isValidating: h,
    reset: C,
    resetValidation: E,
    validate: p,
    validationClasses: m
  };
}
function _f(e) {
  const {
    t
  } = va();
  function n(r) {
    let {
      name: i
    } = r;
    const s = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[i], o = e[`onClick:${i}`], a = o && s ? t(`$vuetify.input.${s}`, e.label ?? "") : void 0;
    return v(pe, {
      icon: e[`${i}Icon`],
      "aria-label": a,
      onClick: o
    }, null);
  }
  return {
    InputIcon: n
  };
}
const ba = z({
  id: String,
  appendIcon: oe,
  prependIcon: oe,
  hideDetails: [Boolean, String],
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["horizontal", "vertical"].includes(e)
  },
  "onClick:prepend": gn,
  "onClick:append": gn,
  ...lt(),
  ...Iw()
}, "v-input"), wa = H()({
  name: "VInput",
  props: {
    ...ba()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: r,
      emit: i
    } = t;
    const {
      densityClasses: s
    } = mt(e), {
      InputIcon: o
    } = _f(e), a = vt(), l = y(() => e.id || `input-${a}`), c = y(() => `${l.value}-messages`), {
      errorMessages: d,
      isDirty: u,
      isDisabled: f,
      isReadonly: h,
      isPristine: m,
      isValid: g,
      isValidating: w,
      reset: C,
      resetValidation: E,
      validate: p,
      validationClasses: O
    } = Cw(e, "v-input", l), A = y(() => ({
      id: l,
      messagesId: c,
      isDirty: u,
      isDisabled: f,
      isReadonly: h,
      isPristine: m,
      isValid: g,
      isValidating: w,
      reset: C,
      resetValidation: E,
      validate: p
    }));
    return J(() => {
      var S, P, k, R, x;
      const N = !!(r.prepend || e.prependIcon), I = !!(r.append || e.appendIcon), _ = !!((S = e.messages) != null && S.length || d.value.length), b = !e.hideDetails || e.hideDetails === "auto" && (_ || !!r.details);
      return v("div", {
        class: ["v-input", `v-input--${e.direction}`, s.value, O.value]
      }, [N && v("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [(P = r.prepend) == null ? void 0 : P.call(r, A.value), e.prependIcon && v(o, {
        key: "prepend-icon",
        name: "prepend"
      }, null)]), r.default && v("div", {
        class: "v-input__control"
      }, [(k = r.default) == null ? void 0 : k.call(r, A.value)]), I && v("div", {
        key: "append",
        class: "v-input__append"
      }, [e.appendIcon && v(o, {
        key: "append-icon",
        name: "append"
      }, null), (R = r.append) == null ? void 0 : R.call(r, A.value)]), b && v("div", {
        class: "v-input__details"
      }, [v(bw, {
        id: c.value,
        active: _,
        messages: d.value.length > 0 ? d.value : e.messages
      }, {
        message: r.message
      }), (x = r.details) == null ? void 0 : x.call(r, A.value)])]);
    }), {
      reset: C,
      resetValidation: E,
      validate: p
    };
  }
});
function bf(e) {
  const t = Object.keys(wa.props).filter((n) => !Nd(n));
  return Wr(e, t);
}
const wf = H()({
  name: "VLabel",
  props: {
    text: String,
    clickable: Boolean,
    ...Ie()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return J(() => {
      var r;
      return v("label", {
        class: ["v-label", {
          "v-label--clickable": e.clickable
        }]
      }, [e.text, (r = n.default) == null ? void 0 : r.call(n)]);
    }), {};
  }
});
const Sf = Symbol.for("vuetify:selection-control-group"), Ef = z({
  color: String,
  disabled: Boolean,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: oe,
  trueIcon: oe,
  ripple: {
    type: Boolean,
    default: !0
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: Boolean,
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: ea
  },
  ...Ie(),
  ...lt()
}, "v-selection-control-group");
H()({
  name: "VSelectionControlGroup",
  props: {
    defaultsTarget: {
      type: String,
      default: "VSelectionControl"
    },
    ...Ef()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = be(e, "modelValue"), i = vt(), s = y(() => e.id || `v-selection-control-group-${i}`), o = y(() => e.name || s.value), a = /* @__PURE__ */ new Set();
    return Je(Sf, {
      modelValue: r,
      forceUpdate: () => {
        a.forEach((l) => l());
      },
      onForceUpdate: (l) => {
        a.add(l), xe(() => {
          a.delete(l);
        });
      }
    }), On({
      [e.defaultsTarget]: {
        color: U(e, "color"),
        disabled: U(e, "disabled"),
        density: U(e, "density"),
        error: U(e, "error"),
        inline: U(e, "inline"),
        modelValue: r,
        multiple: y(() => !!e.multiple || e.multiple == null && Array.isArray(r.value)),
        name: o,
        falseIcon: U(e, "falseIcon"),
        trueIcon: U(e, "trueIcon"),
        readonly: U(e, "readonly"),
        ripple: U(e, "ripple"),
        type: U(e, "type"),
        valueComparator: U(e, "valueComparator")
      }
    }), J(() => {
      var l;
      return v("div", {
        class: ["v-selection-control-group", {
          "v-selection-control-group--inline": e.inline
        }],
        role: e.type === "radio" ? "radiogroup" : void 0
      }, [(l = n.default) == null ? void 0 : l.call(n)]);
    }), {};
  }
});
const If = z({
  label: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...Ef()
}, "v-selection-control");
function kw(e) {
  const t = me(Sf, void 0), {
    densityClasses: n
  } = mt(e), r = be(e, "modelValue"), i = y(() => e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0), s = y(() => e.falseValue !== void 0 ? e.falseValue : !1), o = y(() => !!e.multiple || e.multiple == null && Array.isArray(r.value)), a = y({
    get() {
      const u = t ? t.modelValue.value : r.value;
      return o.value ? u.some((f) => e.valueComparator(f, i.value)) : e.valueComparator(u, i.value);
    },
    set(u) {
      if (e.readonly)
        return;
      const f = u ? i.value : s.value;
      let h = f;
      o.value && (h = u ? [...mn(r.value), f] : mn(r.value).filter((m) => !e.valueComparator(m, i.value))), t ? t.modelValue.value = h : r.value = h;
    }
  }), {
    textColorClasses: l,
    textColorStyles: c
  } = ot(y(() => a.value && !e.error && !e.disabled ? e.color : void 0)), d = y(() => a.value ? e.trueIcon : e.falseIcon);
  return {
    group: t,
    densityClasses: n,
    trueValue: i,
    falseValue: s,
    model: a,
    textColorClasses: l,
    textColorStyles: c,
    icon: d
  };
}
const Tw = H()({
  name: "VSelectionControl",
  directives: {
    Ripple: os
  },
  inheritAttrs: !1,
  props: If(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: r
    } = t;
    const {
      group: i,
      densityClasses: s,
      icon: o,
      model: a,
      textColorClasses: l,
      textColorStyles: c,
      trueValue: d
    } = kw(e), u = vt(), f = y(() => e.id || `input-${u}`), h = D(!1), m = D(!1), g = D();
    i == null || i.onForceUpdate(() => {
      g.value && (g.value.checked = a.value);
    });
    function w(p) {
      h.value = !0, (!ao || ao && p.target.matches(":focus-visible")) && (m.value = !0);
    }
    function C() {
      h.value = !1, m.value = !1;
    }
    function E(p) {
      e.readonly && i && Oe(() => i.forceUpdate()), a.value = p.target.checked;
    }
    return J(() => {
      var N, I;
      const p = r.label ? r.label({
        label: e.label,
        props: {
          for: f.value
        }
      }) : e.label, [O, A] = na(n);
      return v("div", re({
        class: ["v-selection-control", {
          "v-selection-control--dirty": a.value,
          "v-selection-control--disabled": e.disabled,
          "v-selection-control--error": e.error,
          "v-selection-control--focused": h.value,
          "v-selection-control--focus-visible": m.value,
          "v-selection-control--inline": e.inline
        }, s.value]
      }, O), [v("div", {
        class: ["v-selection-control__wrapper", l.value],
        style: c.value
      }, [(N = r.default) == null ? void 0 : N.call(r), Ae(v("div", {
        class: ["v-selection-control__input"]
      }, [o.value && v(pe, {
        key: "icon",
        icon: o.value
      }, null), v("input", re({
        ref: g,
        checked: a.value,
        disabled: e.disabled,
        id: f.value,
        onBlur: C,
        onFocus: w,
        onInput: E,
        "aria-disabled": e.readonly,
        type: e.type,
        value: d.value,
        name: e.name,
        "aria-checked": e.type === "checkbox" ? a.value : void 0
      }, A), null), (I = r.input) == null ? void 0 : I.call(r, {
        model: a,
        textColorClasses: l,
        textColorStyles: c,
        props: {
          onFocus: w,
          onBlur: C,
          id: f.value
        }
      })]), [[Tt("ripple"), e.ripple && [!e.disabled && !e.readonly, null, ["center", "circle"]]]])]), p && v(wf, {
        for: f.value,
        clickable: !0
      }, {
        default: () => [p]
      })]);
    }), {
      isFocused: h,
      input: g
    };
  }
}), Cf = z({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: oe,
    default: "$checkboxIndeterminate"
  },
  ...If({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "v-checkbox-btn"), Zl = H()({
  name: "VCheckboxBtn",
  props: Cf(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = be(e, "indeterminate"), i = be(e, "modelValue");
    function s(l) {
      r.value && (r.value = !1);
    }
    const o = y(() => e.indeterminate ? e.indeterminateIcon : e.falseIcon), a = y(() => e.indeterminate ? e.indeterminateIcon : e.trueIcon);
    return J(() => v(Tw, re(e, {
      modelValue: i.value,
      "onUpdate:modelValue": [(l) => i.value = l, s],
      class: "v-checkbox-btn",
      type: "checkbox",
      inline: !0,
      falseIcon: o.value,
      trueIcon: a.value,
      "aria-checked": e.indeterminate ? "mixed" : void 0
    }), n)), {};
  }
}), Ow = H()({
  name: "VCheckbox",
  inheritAttrs: !1,
  props: {
    ...ba(),
    ...ta(Cf(), ["inline"])
  },
  emits: {
    "update:focused": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: r
    } = t;
    const {
      isFocused: i,
      focus: s,
      blur: o
    } = _a(e), a = vt(), l = y(() => e.id || `checkbox-${a}`);
    return J(() => {
      const [c, d] = na(n), [u, f] = bf(e), [h, m] = Zl.filterProps(e);
      return v(wa, re({
        class: "v-checkbox"
      }, c, u, {
        id: l.value,
        focused: i.value
      }), {
        ...r,
        default: (g) => {
          let {
            id: w,
            messagesId: C,
            isDisabled: E,
            isReadonly: p
          } = g;
          return v(Zl, re(h, {
            id: w.value,
            "aria-describedby": C.value,
            disabled: E.value,
            readonly: p.value
          }, d, {
            onFocus: s,
            onBlur: o
          }), r);
        }
      });
    }), {};
  }
});
const qe = H()({
  name: "VContainer",
  props: {
    fluid: {
      type: Boolean,
      default: !1
    },
    ..._e()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return J(() => v(e.tag, {
      class: ["v-container", {
        "v-container--fluid": e.fluid
      }]
    }, n)), {};
  }
}), us = ["sm", "md", "lg", "xl", "xxl"], Aw = Symbol.for("vuetify:display");
function kf() {
  const e = me(Aw);
  if (!e)
    throw new Error("Could not find Vuetify display injection");
  return e;
}
const Tf = (() => us.reduce((e, t) => (e[t] = {
  type: [Boolean, String, Number],
  default: !1
}, e), {}))(), Of = (() => us.reduce((e, t) => {
  const n = "offset" + ht(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}))(), Af = (() => us.reduce((e, t) => {
  const n = "order" + ht(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}))(), ec = {
  col: Object.keys(Tf),
  offset: Object.keys(Of),
  order: Object.keys(Af)
};
function Nw(e, t, n) {
  let r = e;
  if (!(n == null || n === !1)) {
    if (t) {
      const i = t.replace(e, "");
      r += `-${i}`;
    }
    return e === "col" && (r = "v-" + r), e === "col" && (n === "" || n === !0) || (r += `-${n}`), r.toLowerCase();
  }
}
const Pw = ["auto", "start", "end", "center", "baseline", "stretch"], Rw = H()({
  name: "VCol",
  props: {
    cols: {
      type: [Boolean, String, Number],
      default: !1
    },
    ...Tf,
    offset: {
      type: [String, Number],
      default: null
    },
    ...Of,
    order: {
      type: [String, Number],
      default: null
    },
    ...Af,
    alignSelf: {
      type: String,
      default: null,
      validator: (e) => Pw.includes(e)
    },
    ..._e()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = y(() => {
      const i = [];
      let s;
      for (s in ec)
        ec[s].forEach((a) => {
          const l = e[a], c = Nw(s, a, l);
          c && i.push(c);
        });
      const o = i.some((a) => a.startsWith("v-col-"));
      return i.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !o || !e.cols,
        [`v-col-${e.cols}`]: e.cols,
        [`offset-${e.offset}`]: e.offset,
        [`order-${e.order}`]: e.order,
        [`align-self-${e.alignSelf}`]: e.alignSelf
      }), i;
    });
    return () => {
      var i;
      return kn(e.tag, {
        class: r.value
      }, (i = n.default) == null ? void 0 : i.call(n));
    };
  }
}), Sa = ["start", "end", "center"], Nf = ["space-between", "space-around", "space-evenly"];
function Ea(e, t) {
  return us.reduce((n, r) => {
    const i = e + ht(r);
    return n[i] = t(), n;
  }, {});
}
const xw = [...Sa, "baseline", "stretch"], Pf = (e) => xw.includes(e), Rf = Ea("align", () => ({
  type: String,
  default: null,
  validator: Pf
})), Vw = [...Sa, ...Nf], xf = (e) => Vw.includes(e), Vf = Ea("justify", () => ({
  type: String,
  default: null,
  validator: xf
})), Dw = [...Sa, ...Nf, "stretch"], Df = (e) => Dw.includes(e), Lf = Ea("alignContent", () => ({
  type: String,
  default: null,
  validator: Df
})), tc = {
  align: Object.keys(Rf),
  justify: Object.keys(Vf),
  alignContent: Object.keys(Lf)
}, Lw = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function $w(e, t, n) {
  let r = Lw[e];
  if (n != null) {
    if (t) {
      const i = t.replace(e, "");
      r += `-${i}`;
    }
    return r += `-${n}`, r.toLowerCase();
  }
}
const Mw = H()({
  name: "VRow",
  props: {
    dense: Boolean,
    noGutters: Boolean,
    align: {
      type: String,
      default: null,
      validator: Pf
    },
    ...Rf,
    justify: {
      type: String,
      default: null,
      validator: xf
    },
    ...Vf,
    alignContent: {
      type: String,
      default: null,
      validator: Df
    },
    ...Lf,
    ..._e()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = y(() => {
      const i = [];
      let s;
      for (s in tc)
        tc[s].forEach((o) => {
          const a = e[o], l = $w(s, o, a);
          l && i.push(l);
        });
      return i.push({
        "v-row--no-gutters": e.noGutters,
        "v-row--dense": e.dense,
        [`align-${e.align}`]: e.align,
        [`justify-${e.justify}`]: e.justify,
        [`align-content-${e.alignContent}`]: e.alignContent
      }), i;
    });
    return () => {
      var i;
      return kn(e.tag, {
        class: ["v-row", r.value]
      }, (i = n.default) == null ? void 0 : i.call(n));
    };
  }
});
const ai = H()({
  name: "VFieldLabel",
  props: {
    floating: Boolean
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return J(() => v(wf, {
      class: ["v-field-label", {
        "v-field-label--floating": e.floating
      }],
      "aria-hidden": e.floating || void 0
    }, n)), {};
  }
}), Bw = ["underlined", "outlined", "filled", "solo", "plain"], $f = z({
  appendInnerIcon: oe,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: oe,
    default: "$clear"
  },
  active: Boolean,
  color: String,
  dirty: Boolean,
  disabled: Boolean,
  error: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: oe,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (e) => Bw.includes(e)
  },
  "onClick:clear": gn,
  "onClick:appendInner": gn,
  "onClick:prependInner": gn,
  ...Ie(),
  ...ma()
}, "v-field"), Mf = H()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    ...yf(),
    ...$f()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: r,
      slots: i
    } = t;
    const {
      themeClasses: s
    } = Ve(e), {
      loaderClasses: o
    } = ga(e), {
      focusClasses: a,
      isFocused: l,
      focus: c,
      blur: d
    } = _a(e), {
      InputIcon: u
    } = _f(e), f = y(() => e.dirty || e.active), h = y(() => !e.singleLine && !!(e.label || i.label)), m = vt(), g = y(() => e.id || `input-${m}`), w = y(() => `${g.value}-messages`), C = D(), E = D(), p = D(), {
      backgroundColorClasses: O,
      backgroundColorStyles: A
    } = zn(U(e, "bgColor")), {
      textColorClasses: N,
      textColorStyles: I
    } = ot(y(() => f.value && l.value && !e.error && !e.disabled ? e.color : void 0));
    te(f, (S) => {
      if (h.value) {
        const P = C.value.$el, k = E.value.$el;
        requestAnimationFrame(() => {
          const R = ia(P), x = k.getBoundingClientRect(), j = x.x - R.x, G = x.y - R.y - (R.height / 2 - x.height / 2), M = x.width / 0.75, ee = Math.abs(M - R.width) > 1 ? {
            maxWidth: Y(M)
          } : void 0, Z = getComputedStyle(P), $ = getComputedStyle(k), W = parseFloat(Z.transitionDuration) * 1e3 || 150, ae = parseFloat($.getPropertyValue("--v-field-label-scale")), Qe = $.getPropertyValue("color");
          P.style.visibility = "visible", k.style.visibility = "hidden", cn(P, {
            transform: `translate(${j}px, ${G}px) scale(${ae})`,
            color: Qe,
            ...ee
          }, {
            duration: W,
            easing: Rr,
            direction: S ? "normal" : "reverse"
          }).finished.then(() => {
            P.style.removeProperty("visibility"), k.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const _ = y(() => ({
      isActive: f,
      isFocused: l,
      controlRef: p,
      blur: d,
      focus: c
    }));
    function b(S) {
      S.target !== document.activeElement && S.preventDefault();
    }
    return J(() => {
      var j, G, M;
      const S = e.variant === "outlined", P = i["prepend-inner"] || e.prependInnerIcon, k = !!(e.clearable || i.clear), R = !!(i["append-inner"] || e.appendInnerIcon || k), x = i.label ? i.label({
        label: e.label,
        props: {
          for: g.value
        }
      }) : e.label;
      return v("div", re({
        class: ["v-field", {
          "v-field--active": f.value,
          "v-field--appended": R,
          "v-field--disabled": e.disabled,
          "v-field--dirty": e.dirty,
          "v-field--error": e.error,
          "v-field--has-background": !!e.bgColor,
          "v-field--persistent-clear": e.persistentClear,
          "v-field--prepended": P,
          "v-field--reverse": e.reverse,
          "v-field--single-line": e.singleLine,
          "v-field--no-label": !x,
          [`v-field--variant-${e.variant}`]: !0
        }, s.value, O.value, a.value, o.value],
        style: [A.value, I.value],
        onClick: b
      }, n), [v("div", {
        class: "v-field__overlay"
      }, null), v(mf, {
        name: "v-field",
        active: !!e.loading,
        color: e.error ? "error" : e.color
      }, {
        default: i.loader
      }), P && v("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [e.prependInnerIcon && v(u, {
        key: "prepend-icon",
        name: "prependInner"
      }, null), (j = i["prepend-inner"]) == null ? void 0 : j.call(i, _.value)]), v("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["solo", "filled"].includes(e.variant) && h.value && v(ai, {
        key: "floating-label",
        ref: E,
        class: [N.value],
        floating: !0,
        for: g.value
      }, {
        default: () => [x]
      }), v(ai, {
        ref: C,
        for: g.value
      }, {
        default: () => [x]
      }), (G = i.default) == null ? void 0 : G.call(i, {
        ..._.value,
        props: {
          id: g.value,
          class: "v-field__input",
          "aria-describedby": w.value
        },
        focus: c,
        blur: d
      })]), k && v(Pb, {
        key: "clear"
      }, {
        default: () => [Ae(v("div", {
          class: "v-field__clearable",
          onMousedown: (ee) => {
            ee.preventDefault(), ee.stopPropagation();
          }
        }, [i.clear ? i.clear() : v(u, {
          name: "clear"
        }, null)]), [[qn, e.dirty]])]
      }), R && v("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [(M = i["append-inner"]) == null ? void 0 : M.call(i, _.value), e.appendInnerIcon && v(u, {
        key: "append-icon",
        name: "appendInner"
      }, null)]), v("div", {
        class: ["v-field__outline", N.value]
      }, [S && v(Pe, null, [v("div", {
        class: "v-field__outline__start"
      }, null), h.value && v("div", {
        class: "v-field__outline__notch"
      }, [v(ai, {
        ref: E,
        floating: !0,
        for: g.value
      }, {
        default: () => [x]
      })]), v("div", {
        class: "v-field__outline__end"
      }, null)]), ["plain", "underlined"].includes(e.variant) && h.value && v(ai, {
        ref: E,
        floating: !0,
        for: g.value
      }, {
        default: () => [x]
      })])]);
    }), {
      controlRef: p
    };
  }
});
function Fw(e) {
  const t = Object.keys(Mf.props).filter((n) => !Nd(n));
  return Wr(e, t);
}
const Uw = H()({
  name: "VCounter",
  functional: !0,
  props: {
    active: Boolean,
    max: [Number, String],
    value: {
      type: [Number, String],
      default: 0
    },
    ...ss({
      transition: {
        component: Md
      }
    })
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = y(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
    return J(() => v(St, {
      transition: e.transition
    }, {
      default: () => [Ae(v("div", {
        class: "v-counter"
      }, [n.default ? n.default({
        counter: r.value,
        max: e.max,
        value: e.value
      }) : r.value]), [[qn, e.active]])]
    })), {};
  }
}), xs = Symbol("Forwarded refs");
function Vs(e, t) {
  let n = e;
  for (; n; ) {
    const r = Reflect.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Object.getPrototypeOf(n);
  }
}
function ds(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return e[xs] = n, new Proxy(e, {
    get(i, s) {
      if (Reflect.has(i, s))
        return Reflect.get(i, s);
      if (!(typeof s == "symbol" || s.startsWith("__"))) {
        for (const o of n)
          if (o.value && Reflect.has(o.value, s)) {
            const a = Reflect.get(o.value, s);
            return typeof a == "function" ? a.bind(o.value) : a;
          }
      }
    },
    has(i, s) {
      if (Reflect.has(i, s))
        return !0;
      if (typeof s == "symbol" || s.startsWith("__"))
        return !1;
      for (const o of n)
        if (o.value && Reflect.has(o.value, s))
          return !0;
      return !1;
    },
    getOwnPropertyDescriptor(i, s) {
      var a;
      const o = Reflect.getOwnPropertyDescriptor(i, s);
      if (o)
        return o;
      if (!(typeof s == "symbol" || s.startsWith("__"))) {
        for (const l of n) {
          if (!l.value)
            continue;
          const c = Vs(l.value, s) ?? ("_" in l.value ? Vs((a = l.value._) == null ? void 0 : a.setupState, s) : void 0);
          if (c)
            return c;
        }
        for (const l of n) {
          const c = l.value && l.value[xs];
          if (!c)
            continue;
          const d = c.slice();
          for (; d.length; ) {
            const u = d.shift(), f = Vs(u.value, s);
            if (f)
              return f;
            const h = u.value && u.value[xs];
            h && d.push(...h);
          }
        }
      }
    }
  });
}
const Hw = ["color", "file", "time", "date", "datetime-local", "week", "month"], jw = z({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  hint: String,
  persistentHint: Boolean,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  type: {
    type: String,
    default: "text"
  },
  ...ba(),
  ...$f()
}, "v-text-field"), Et = H()({
  name: "VTextField",
  directives: {
    Intersect: qd
  },
  inheritAttrs: !1,
  props: jw(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: r,
      slots: i
    } = t;
    const s = be(e, "modelValue"), {
      isFocused: o,
      focus: a,
      blur: l
    } = _a(e), c = y(() => typeof e.counterValue == "function" ? e.counterValue(s.value) : (s.value ?? "").toString().length), d = y(() => {
      if (n.maxlength)
        return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    });
    function u(N, I) {
      var _, b;
      !e.autofocus || !N || (b = (_ = I[0].target) == null ? void 0 : _.focus) == null || b.call(_);
    }
    const f = D(), h = D(), m = D(), g = y(() => Hw.includes(e.type) || e.persistentPlaceholder || o.value), w = y(() => e.messages.length ? e.messages : o.value || e.persistentHint ? e.hint : "");
    function C() {
      var N;
      m.value !== document.activeElement && ((N = m.value) == null || N.focus()), o.value || a();
    }
    function E(N) {
      r("mousedown:control", N), N.target !== m.value && (C(), N.preventDefault());
    }
    function p(N) {
      C(), r("click:control", N);
    }
    function O(N) {
      N.stopPropagation(), C(), Oe(() => {
        s.value = null, fb(e["onClick:clear"], N);
      });
    }
    function A(N) {
      const I = N.target;
      if (s.value = I.value, ["text", "search", "password", "tel", "url"].includes(e.type)) {
        const _ = [I.selectionStart, I.selectionEnd];
        Oe(() => {
          I.selectionStart = _[0], I.selectionEnd = _[1];
        });
      }
    }
    return J(() => {
      const N = !!(i.counter || e.counter || e.counterValue), I = !!(N || i.details), [_, b] = na(n), [{
        modelValue: S,
        ...P
      }] = bf(e), [k] = Fw(e);
      return v(wa, re({
        ref: f,
        modelValue: s.value,
        "onUpdate:modelValue": (R) => s.value = R,
        class: ["v-text-field", {
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-text-field--flush-details": ["plain", "underlined"].includes(e.variant)
        }],
        "onClick:prepend": e["onClick:prepend"],
        "onClick:append": e["onClick:append"]
      }, _, P, {
        focused: o.value,
        messages: w.value
      }), {
        ...i,
        default: (R) => {
          let {
            id: x,
            isDisabled: j,
            isDirty: G,
            isReadonly: M,
            isValid: ee
          } = R;
          return v(Mf, re({
            ref: h,
            onMousedown: E,
            onClick: p,
            "onClick:clear": O,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"],
            role: "textbox"
          }, k, {
            id: x.value,
            active: g.value || G.value,
            dirty: G.value || e.dirty,
            disabled: j.value,
            focused: o.value,
            error: ee.value === !1
          }), {
            ...i,
            default: (Z) => {
              let {
                props: {
                  class: $,
                  ...W
                }
              } = Z;
              const ae = Ae(v("input", re({
                ref: m,
                value: s.value,
                onInput: A,
                autofocus: e.autofocus,
                readonly: M.value,
                disabled: j.value,
                name: e.name,
                placeholder: e.placeholder,
                size: 1,
                type: e.type,
                onFocus: C,
                onBlur: l
              }, W, b), null), [[Tt("intersect"), {
                handler: u
              }, null, {
                once: !0
              }]]);
              return v(Pe, null, [e.prefix && v("span", {
                class: "v-text-field__prefix"
              }, [e.prefix]), i.default ? v("div", {
                class: $,
                "data-no-activator": ""
              }, [i.default(), ae]) : Gt(ae, {
                class: $
              }), e.suffix && v("span", {
                class: "v-text-field__suffix"
              }, [e.suffix])]);
            }
          });
        },
        details: I ? (R) => {
          var x;
          return v(Pe, null, [(x = i.details) == null ? void 0 : x.call(i, R), N && v(Pe, null, [v("span", null, null), v(Uw, {
            active: e.persistentCounter || o.value,
            value: c.value,
            max: d.value
          }, i.counter)])]);
        } : void 0
      });
    }), ds({}, f, h, m);
  }
}), Ww = { class: "text-center pb-4" }, zw = {
  __name: "LoginCard",
  setup(e) {
    const t = Xe(), { loginWithEmail: n, SET_PASSWORD_RESET_SCREEN_SHOWN: r } = t, { config: i, error: s, is_session_persistant: o, getSessionPersistence: a, getError: l } = Tn(t);
    let c = "", d = "", u = !0;
    return qt(() => {
      u = a;
    }), (f, h) => (F(), X(qe, null, {
      default: V(() => [
        v(En, { flat: "" }, {
          default: V(() => [
            T(l) ? (F(), X(Yr, {
              key: 0,
              type: "error",
              dismissible: "",
              onClick: h[0] || (h[0] = (m) => s.value = null)
            }, {
              default: V(() => [
                q(it(T(l).message), 1)
              ]),
              _: 1
            })) : (F(), X(as, {
              key: 1,
              class: "text-center"
            }))
          ]),
          _: 1
        }),
        T(i).email ? (F(), X(En, {
          key: 0,
          flat: ""
        }, {
          default: V(() => [
            v(Ht, { class: "mb-0 pb-0" }, {
              default: V(() => [
                v(Et, {
                  modelValue: T(c),
                  "onUpdate:modelValue": h[1] || (h[1] = (m) => K(c) ? c.value = m : c = m),
                  required: "",
                  class: "mr-2",
                  label: "Email",
                  "prepend-icon": "mdi-account"
                }, null, 8, ["modelValue"]),
                v(Et, {
                  modelValue: T(d),
                  "onUpdate:modelValue": h[2] || (h[2] = (m) => K(d) ? d.value = m : d = m),
                  autocomplete: "off",
                  class: "mr-2",
                  name: "password",
                  type: "password",
                  label: "Password",
                  "prepend-icon": "mdi-lock"
                }, null, 8, ["modelValue"]),
                v(Ow, {
                  modelValue: T(u),
                  "onUpdate:modelValue": h[3] || (h[3] = (m) => K(u) ? u.value = m : u = m),
                  dense: "",
                  class: "ml-8",
                  name: "remember",
                  label: "remember me",
                  onChange: h[4] || (h[4] = (m) => o.value = T(u))
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            ye("div", Ww, [
              v(le, {
                variant: "text",
                size: "x-small",
                color: "primary",
                onClick: h[5] || (h[5] = (m) => T(r)(!0))
              }, {
                default: V(() => [
                  q(" Forgot Password? ")
                ]),
                _: 1
              })
            ]),
            v(Sn, null, {
              default: V(() => [
                v(le, {
                  block: "",
                  size: "large",
                  variant: "outlined",
                  color: "primary",
                  type: "submit",
                  onClick: h[6] || (h[6] = (m) => T(n)({ email: T(c), password: T(d) }))
                }, {
                  default: V(() => [
                    q(" Login ")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : se("", !0)
      ]),
      _: 1
    }));
  }
}, Ia = H()({
  name: "VForm",
  props: {
    ...ww()
  },
  emits: {
    "update:modelValue": (e) => !0,
    submit: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: r
    } = t;
    const i = Sw(e), s = D();
    function o(l) {
      l.preventDefault(), i.reset();
    }
    function a(l) {
      const c = l, d = i.validate();
      c.then = d.then.bind(d), c.catch = d.catch.bind(d), c.finally = d.finally.bind(d), r("submit", c), c.defaultPrevented || d.then((u) => {
        var h;
        let {
          valid: f
        } = u;
        f && ((h = s.value) == null || h.submit());
      }), c.preventDefault();
    }
    return J(() => {
      var l;
      return v("form", {
        ref: s,
        class: "v-form",
        novalidate: !0,
        onReset: o,
        onSubmit: a
      }, [(l = n.default) == null ? void 0 : l.call(n, i)]);
    }), ds(i, s);
  }
}), Gw = {
  __name: "RegisterUser",
  setup(e) {
    const t = Xe(), { error: n, registerUser: r } = t;
    let i = "", s = "", o = "", a = "", l = !1;
    const c = y(() => ({
      email: this.email == "" ? "Email cannot be empty" : !0,
      password: this.password == "" ? "Password cannot be empty" : !0,
      displayName: this.displayName == "" ? "Name cannot be empty" : !0,
      confirm: this.password !== this.confirm ? "Passwords do not match" : !0
    })), d = () => {
      const { displayName: u, email: f, password: h } = this;
      this.$refs.form.validate() && r({ displayName: u, email: f, password: h });
    };
    return (u, f) => (F(), X(qe, null, {
      default: V(() => [
        v(En, { flat: "" }, {
          default: V(() => [
            v(Ia, {
              ref: "form",
              modelValue: T(l),
              "onUpdate:modelValue": f[5] || (f[5] = (h) => K(l) ? l.value = h : l = h),
              onSubmit: f[6] || (f[6] = $o((h) => d(), ["prevent"]))
            }, {
              default: V(() => [
                T(n) ? (F(), X(Yr, {
                  key: 0,
                  type: "error",
                  dismissible: "",
                  onClick: f[0] || (f[0] = (h) => n.value = null)
                }, {
                  default: V(() => [
                    q(it(T(n).message), 1)
                  ]),
                  _: 1
                })) : (F(), X(as, {
                  key: 1,
                  class: "text-center"
                })),
                v(Ht, { class: "mb-0 pb-0" }, {
                  default: V(() => [
                    v(Et, {
                      modelValue: T(a),
                      "onUpdate:modelValue": f[1] || (f[1] = (h) => K(a) ? a.value = h : a = h),
                      required: "",
                      class: "mr-2",
                      label: "Name",
                      "prepend-icon": "mdi-account",
                      rules: [T(c).displayName]
                    }, null, 8, ["modelValue", "rules"]),
                    v(Et, {
                      modelValue: T(i),
                      "onUpdate:modelValue": f[2] || (f[2] = (h) => K(i) ? i.value = h : i = h),
                      required: "",
                      class: "mr-2",
                      label: "Email",
                      "prepend-icon": "mdi-email",
                      rules: [T(c).email]
                    }, null, 8, ["modelValue", "rules"]),
                    v(Et, {
                      modelValue: T(s),
                      "onUpdate:modelValue": f[3] || (f[3] = (h) => K(s) ? s.value = h : s = h),
                      autocomplete: "off",
                      required: "",
                      class: "mr-2",
                      type: "password",
                      label: "Password",
                      "prepend-icon": "mdi-lock",
                      rules: [T(c).password]
                    }, null, 8, ["modelValue", "rules"]),
                    v(Et, {
                      modelValue: T(o),
                      "onUpdate:modelValue": f[4] || (f[4] = (h) => K(o) ? o.value = h : o = h),
                      autocomplete: "off",
                      required: "",
                      class: "mr-2",
                      type: "password",
                      label: "Confirm password",
                      "prepend-icon": "mdi-lock",
                      rules: [T(c).confirm]
                    }, null, 8, ["modelValue", "rules"])
                  ]),
                  _: 1
                }),
                v(Sn, null, {
                  default: V(() => [
                    v(le, {
                      block: "",
                      large: "",
                      depressed: "",
                      color: "primary",
                      type: "submit",
                      disabled: !T(l)
                    }, {
                      default: V(() => [
                        q(" Register ")
                      ]),
                      _: 1
                    }, 8, ["disabled"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}, qw = { key: 2 }, Kw = /* @__PURE__ */ ye("div", { class: "mb-5" }, " Enter registered user email address and we will send you a link to reset your password. ", -1), Jw = {
  __name: "PasswordReset",
  setup(e) {
    const t = Xe(), { emailPasswordResetLink: n, SET_PASSWORD_RESET_SCREEN_SHOWN: r } = t, { error: i, isLoading: s, getError: o, isEmailResetPasswordLinkSent: a } = Tn(t);
    let l = "", c = !1;
    const d = y(() => ({
      email: this.email == "" ? "Email cannot be empty" : !0
    }));
    return (u, f) => (F(), X(qe, null, {
      default: V(() => [
        v(En, { flat: "" }, {
          default: V(() => [
            v(Ia, {
              ref: "form",
              modelValue: T(c),
              "onUpdate:modelValue": f[3] || (f[3] = (h) => K(c) ? c.value = h : c = h),
              onSubmit: f[4] || (f[4] = $o((h) => T(n)(T(l)), ["prevent"]))
            }, {
              default: V(() => [
                T(o) ? (F(), X(Yr, {
                  key: 0,
                  type: "error",
                  dismissible: "",
                  onClick: f[0] || (f[0] = (h) => i.value = null)
                }, {
                  default: V(() => [
                    q(it(T(o).message), 1)
                  ]),
                  _: 1
                })) : (F(), X(as, {
                  key: 1,
                  class: "text-center"
                })),
                T(a) ? se("", !0) : (F(), Ne("div", qw, [
                  v(Ht, { class: "mb-0 pb-0" }, {
                    default: V(() => [
                      Kw,
                      v(Et, {
                        modelValue: T(l),
                        "onUpdate:modelValue": f[1] || (f[1] = (h) => K(l) ? l.value = h : l = h),
                        required: "",
                        error: !!T(o),
                        class: "mr-2",
                        label: "Email",
                        "prepend-icon": "mdi-account",
                        rules: [T(d).email]
                      }, null, 8, ["modelValue", "error", "rules"])
                    ]),
                    _: 1
                  }),
                  v(Sn, null, {
                    default: V(() => [
                      v(le, {
                        block: "",
                        large: "",
                        depressed: "",
                        color: "primary",
                        type: "submit",
                        disabled: T(s)
                      }, {
                        default: V(() => [
                          q(" Email Password Reset Link ")
                        ]),
                        _: 1
                      }, 8, ["disabled"])
                    ]),
                    _: 1
                  })
                ])),
                T(a) ? (F(), X(qe, {
                  key: 3,
                  class: "pa-4 text-center"
                }, {
                  default: V(() => [
                    v(Ht, { class: "text-h5" }, {
                      default: V(() => [
                        q(" Email has been sent! ")
                      ]),
                      _: 1
                    }),
                    v(Ht, null, {
                      default: V(() => [
                        q("Please check your inbox and follow the instructions in the email to reset your account password")
                      ]),
                      _: 1
                    }),
                    v(Sn, null, {
                      default: V(() => [
                        v(le, {
                          block: "",
                          large: "",
                          depressed: "",
                          color: "primary",
                          onClick: f[2] || (f[2] = (h) => T(r)(!1))
                        }, {
                          default: V(() => [
                            q(" Login ")
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })) : se("", !0)
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
};
const Yw = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, i] of t)
    n[r] = i;
  return n;
}, Bf = (e) => (hv("data-v-be9a84d5"), e = e(), vv(), e), Xw = /* @__PURE__ */ Bf(() => /* @__PURE__ */ ye("div", { id: "recaptcha-container" }, null, -1)), Qw = { key: 2 }, Zw = /* @__PURE__ */ Bf(() => /* @__PURE__ */ ye("p", { class: "text-center" }, [
  /* @__PURE__ */ q(" enter confirmation code"),
  /* @__PURE__ */ ye("br"),
  /* @__PURE__ */ q(" you have received on your mobile phone ")
], -1)), eS = {
  __name: "LoginWithPhone",
  setup(e) {
    let t = !1, n = [], r = "#", i = "(###) ###-####", s = "", o = null;
    const a = Xe(), l = Cn(), { textPhoneVerificationCode: c, confirmCode: d, SET_SHOW_LOGIN_WITH_PHONE: u } = a, { error: f, sign_by_phone_step: h, getError: m } = Tn(a), g = y(() => ({
      phoneNumber: this.phoneNumber.replace(/\D/g, "") < 1e9 ? "Please enter a valid US phone number" : !0
    }));
    qt(() => {
      o = new Ly(
        "recaptcha-container",
        { size: "invisible" },
        De(l.config.globalProperties.$authGuardFirebaseApp)
      );
    });
    const w = (E) => {
      const p = E.clipboardData.getData("text").substr(0, 6);
      for (var O = 0; O < p.length; O++)
        this.$set(this.code, O, p[O]);
    }, C = (E, p) => {
      let O = E;
      ["Backspace", "ArrowLeft"].includes(p.key) && (O = E > 1 ? E - 1 : 0), ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "ArrowRight"].includes(p.key) && (this.$set(this.code, E, p.key), O = E > 4 ? E : E + 1);
      const A = "code" + O;
      this.$refs[A][0].focus();
    };
    return (E, p) => {
      const O = Tt("mask");
      return F(), X(qe, null, {
        default: V(() => [
          Xw,
          v(En, { flat: "" }, {
            default: V(() => [
              T(m) ? (F(), X(Yr, {
                key: 0,
                type: "error",
                dismissible: "",
                onClick: p[0] || (p[0] = (A) => f.value = null)
              }, {
                default: V(() => [
                  q(it(T(m).message), 1)
                ]),
                _: 1
              })) : (F(), X(as, {
                key: 1,
                class: "text-center"
              })),
              T(h) === 1 ? (F(), Ne("div", Qw, [
                v(Ia, {
                  ref: "form",
                  modelValue: T(t),
                  "onUpdate:modelValue": p[2] || (p[2] = (A) => K(t) ? t.value = A : t = A),
                  onSubmit: p[3] || (p[3] = $o((A) => T(c)({ phoneNumber: T(s), recaptchaVerifier: T(o) }), ["prevent"]))
                }, {
                  default: V(() => [
                    v(Ht, null, {
                      default: V(() => [
                        Ae(v(Et, {
                          modelValue: T(s),
                          "onUpdate:modelValue": p[1] || (p[1] = (A) => K(s) ? s.value = A : s = A),
                          class: "mx-15 px-5 large-font",
                          autocomplete: "off",
                          label: "Phone Number",
                          "prepend-icon": "mdi-cellphone",
                          prefix: "+1",
                          rules: [T(g).phoneNumber]
                        }, null, 8, ["modelValue", "rules"]), [
                          [O, T(i)]
                        ])
                      ]),
                      _: 1
                    }),
                    v(Sn, null, {
                      default: V(() => [
                        v(le, {
                          color: "primary",
                          block: "",
                          large: "",
                          depressed: "",
                          disabled: !T(t),
                          type: "submit"
                        }, {
                          default: V(() => [
                            q(" Send Code ")
                          ]),
                          _: 1
                        }, 8, ["disabled"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ])) : se("", !0),
              T(h) === 2 ? (F(), X(qe, { key: 3 }, {
                default: V(() => [
                  Zw,
                  v(Mw, { class: "centered-input" }, {
                    default: V(() => [
                      (F(), Ne(Pe, null, Cv(6, (A, N) => v(Rw, {
                        key: N,
                        cols: "2"
                      }, {
                        default: V(() => [
                          Ae((F(), X(Et, {
                            ref_for: !0,
                            ref: "code" + N,
                            key: N,
                            modelValue: T(n)[N],
                            "onUpdate:modelValue": (I) => T(n)[N] = I,
                            value: T(n)[N],
                            "item-value": T(n)[N],
                            "item-text": T(n)[N],
                            outlined: "",
                            maxlength: "1",
                            onKeyup: (I) => C(N, I),
                            onPaste: w
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "value", "item-value", "item-text", "onKeyup"])), [
                            [O, T(r)]
                          ])
                        ]),
                        _: 2
                      }, 1024)), 64))
                    ]),
                    _: 1
                  }),
                  v(le, {
                    color: "primary",
                    block: "",
                    large: "",
                    depressed: "",
                    disabled: T(n).length < 6,
                    onClick: p[4] || (p[4] = (A) => T(d)(T(n)))
                  }, {
                    default: V(() => [
                      q(" Confirm Code ")
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ]),
                _: 1
              })) : se("", !0),
              v(qe, { class: "text-center" }, {
                default: V(() => [
                  v(le, {
                    text: "",
                    "x-small": "",
                    color: "primary",
                    onClick: p[5] || (p[5] = (A) => T(u)(!1))
                  }, {
                    default: V(() => [
                      q(" Sign In with email ")
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
}, tS = /* @__PURE__ */ Yw(eS, [["__scopeId", "data-v-be9a84d5"]]), nS = { key: 0 }, rS = /* @__PURE__ */ ye("div", { class: "display-1 grey--text mb-3" }, "Error!", -1), iS = { key: 1 }, sS = { key: 0 }, oS = /* @__PURE__ */ ye("div", { class: "display-1 grey--text mb-3" }, "Verification Required", -1), aS = { key: 1 }, lS = /* @__PURE__ */ ye("div", { class: "display-1 grey--text mb-3" }, "Email sent!", -1), cS = /* @__PURE__ */ ye("div", { class: "grey--text text--darken-2 mb-7 body-2" }, [
  /* @__PURE__ */ ye("p", null, " Please check your email to verify your address. Click at the link in the email we've sent you to confirm your account access. ")
], -1), uS = { key: 2 }, dS = /* @__PURE__ */ ye("p", { class: "grey--text text--darken-2 mb-7 body-2" }, [
  /* @__PURE__ */ q(" If you have not received verification email"),
  /* @__PURE__ */ ye("br"),
  /* @__PURE__ */ q("click at the button below. ")
], -1), fS = { key: 3 }, hS = /* @__PURE__ */ ye("div", { class: "caption mb-2" }, "- or -", -1), vS = {
  __name: "EmailVerification",
  setup(e) {
    const t = Xe(), { error: n, is_loading: r, signOut: i, sendVerificationEmail: s, SET_EMAIL_VERIFICATION_SCREEN_SHOWN: o } = t, { isAuthenticated: a, isEmailResetPasswordLinkSent: l, isEmailVerificationLinkSent: c } = Tn(t);
    return (d, u) => (F(), X(qe, null, {
      default: V(() => [
        v(En, {
          flat: "",
          class: "text-center pa-5"
        }, {
          default: V(() => [
            T(n) ? (F(), Ne("div", nS, [
              rS,
              T(n) ? (F(), X(Yr, {
                key: 0,
                type: "error",
                dismissible: "",
                onClick: u[0] || (u[0] = (f) => n.value = null)
              }, {
                default: V(() => [
                  q(it(T(n).message), 1)
                ]),
                _: 1
              })) : se("", !0),
              v(le, {
                color: "primary",
                onClick: u[1] || (u[1] = (f) => T(o)(!1))
              }, {
                default: V(() => [
                  q(" Back to Login ")
                ]),
                _: 1
              })
            ])) : (F(), Ne("div", iS, [
              T(c) ? se("", !0) : (F(), Ne("div", sS, [
                oS,
                v(pe, {
                  size: "100",
                  color: "grey",
                  class: "ma-4"
                }, {
                  default: V(() => [
                    q("mdi-account")
                  ]),
                  _: 1
                })
              ])),
              T(c) ? (F(), Ne("div", aS, [
                lS,
                v(pe, {
                  size: "100",
                  color: "grey",
                  class: "ma-4"
                }, {
                  default: V(() => [
                    q("mdi-email")
                  ]),
                  _: 1
                })
              ])) : se("", !0),
              cS,
              T(l) ? se("", !0) : (F(), Ne("div", uS, [
                dS,
                v(le, {
                  disabled: T(r),
                  color: "primary",
                  onClick: u[2] || (u[2] = (f) => T(s)())
                }, {
                  default: V(() => [
                    q(" Send Verification Email ")
                  ]),
                  _: 1
                }, 8, ["disabled"])
              ])),
              T(l) ? (F(), Ne("div", fS, [
                v(le, {
                  color: "primary",
                  onClick: u[3] || (u[3] = (f) => T(o)(!1))
                }, {
                  default: V(() => [
                    q(" Back to Login ")
                  ]),
                  _: 1
                })
              ])) : se("", !0),
              v(qe, null, {
                default: V(() => [
                  hS,
                  T(a) ? (F(), X(le, {
                    key: 0,
                    color: "primary",
                    outlined: "",
                    onClick: T(i)
                  }, {
                    default: V(() => [
                      q(" SignOut ")
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : (F(), X(le, {
                    key: 1,
                    color: "primary",
                    outlined: "",
                    onClick: u[4] || (u[4] = (f) => T(o)(!1))
                  }, {
                    default: V(() => [
                      q(" SignIn ")
                    ]),
                    _: 1
                  }))
                ]),
                _: 1
              })
            ]))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
};
const mS = z({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function gS(e, t) {
  const n = {}, r = (i) => () => {
    if (!He)
      return Promise.resolve(!0);
    const s = i === "openDelay";
    return n.closeDelay && window.clearTimeout(n.closeDelay), delete n.closeDelay, n.openDelay && window.clearTimeout(n.openDelay), delete n.openDelay, new Promise((o) => {
      const a = parseInt(e[i] ?? 0, 10);
      n[i] = window.setTimeout(() => {
        t == null || t(s), o(s);
      }, a);
    });
  };
  return {
    runCloseDelay: r("closeDelay"),
    runOpenDelay: r("openDelay")
  };
}
const pS = Symbol.for("vuetify:v-menu"), yS = z({
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...mS()
}, "v-overlay-activator");
function _S(e, t) {
  let {
    isActive: n,
    isTop: r
  } = t;
  const i = D();
  let s = !1, o = !1, a = !0;
  const l = y(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover), c = y(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !l.value), {
    runOpenDelay: d,
    runCloseDelay: u
  } = gS(e, (p) => {
    p === (e.openOnHover && s || l.value && o) && !(e.openOnHover && n.value && !r.value) && (n.value !== p && (a = !0), n.value = p);
  }), f = {
    click: (p) => {
      p.stopPropagation(), i.value = p.currentTarget || p.target, n.value = !n.value;
    },
    mouseenter: (p) => {
      s = !0, i.value = p.currentTarget || p.target, d();
    },
    mouseleave: (p) => {
      s = !1, u();
    },
    focus: (p) => {
      ao && !p.target.matches(":focus-visible") || (o = !0, p.stopPropagation(), i.value = p.currentTarget || p.target, d());
    },
    blur: (p) => {
      o = !1, p.stopPropagation(), u();
    }
  }, h = y(() => {
    const p = {};
    return c.value && (p.click = f.click), e.openOnHover && (p.mouseenter = f.mouseenter, p.mouseleave = f.mouseleave), l.value && (p.focus = f.focus, p.blur = f.blur), p;
  }), m = y(() => {
    const p = {};
    if (e.openOnHover && (p.mouseenter = () => {
      s = !0, d();
    }, p.mouseleave = () => {
      s = !1, u();
    }), e.closeOnContentClick) {
      const O = me(pS, null);
      p.click = () => {
        n.value = !1, O == null || O.closeParents();
      };
    }
    return p;
  }), g = y(() => {
    const p = {};
    return e.openOnHover && (p.mouseenter = () => {
      a && (s = !0, a = !1, d());
    }, p.mouseleave = () => {
      s = !1, u();
    }), p;
  });
  te(r, (p) => {
    p && (e.openOnHover && !s && (!l.value || !o) || l.value && !o && (!e.openOnHover || !s)) && (n.value = !1);
  });
  const w = D();
  Gn(() => {
    w.value && Oe(() => {
      const p = w.value;
      i.value = ub(p) ? p.$el : p;
    });
  });
  const C = Ue("useActivator");
  let E;
  return te(() => !!e.activator, (p) => {
    p && He ? (E = Lr(), E.run(() => {
      bS(e, C, {
        activatorEl: i,
        activatorEvents: h
      });
    })) : E && E.stop();
  }, {
    flush: "post",
    immediate: !0
  }), xe(() => {
    E == null || E.stop();
  }), {
    activatorEl: i,
    activatorRef: w,
    activatorEvents: h,
    contentEvents: m,
    scrimEvents: g
  };
}
function bS(e, t, n) {
  let {
    activatorEl: r,
    activatorEvents: i
  } = n;
  te(() => e.activator, (l, c) => {
    if (c && l !== c) {
      const d = a(c);
      d && o(d);
    }
    l && Oe(() => s());
  }, {
    immediate: !0
  }), te(() => e.activatorProps, () => {
    s();
  }), xe(() => {
    o();
  });
  function s() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a(), c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    l && (Object.entries(i.value).forEach((d) => {
      let [u, f] = d;
      l.addEventListener(u, f);
    }), Object.keys(c).forEach((d) => {
      c[d] == null ? l.removeAttribute(d) : l.setAttribute(d, c[d]);
    }));
  }
  function o() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a(), c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    l && (Object.entries(i.value).forEach((d) => {
      let [u, f] = d;
      l.removeEventListener(u, f);
    }), Object.keys(c).forEach((d) => {
      l.removeAttribute(d);
    }));
  }
  function a() {
    var d, u;
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator, c;
    if (l)
      if (l === "parent") {
        let f = (u = (d = t == null ? void 0 : t.proxy) == null ? void 0 : d.$el) == null ? void 0 : u.parentNode;
        for (; f.hasAttribute("data-no-activator"); )
          f = f.parentNode;
        c = f;
      } else
        typeof l == "string" ? c = document.querySelector(l) : "$el" in l ? c = l.$el : c = l;
    return r.value = (c == null ? void 0 : c.nodeType) === Node.ELEMENT_NODE ? c : null, r.value;
  }
}
const Ff = z({
  eager: Boolean
}, "lazy");
function Uf(e, t) {
  const n = D(!1), r = y(() => n.value || e.eager || t.value);
  te(t, () => n.value = !0);
  function i() {
    e.eager || (n.value = !1);
  }
  return {
    isBooted: n,
    hasContent: r,
    onAfterLeave: i
  };
}
function Ds(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}
function wS(e, t) {
  return {
    x: e.x - t.x,
    y: e.y - t.y
  };
}
function nc(e, t) {
  if (e.side === "top" || e.side === "bottom") {
    const {
      side: n,
      align: r
    } = e, i = r === "left" ? 0 : r === "center" ? t.width / 2 : r === "right" ? t.width : r, s = n === "top" ? 0 : n === "bottom" ? t.height : n;
    return Ds({
      x: i,
      y: s
    }, t);
  } else if (e.side === "left" || e.side === "right") {
    const {
      side: n,
      align: r
    } = e, i = n === "left" ? 0 : n === "right" ? t.width : n, s = r === "top" ? 0 : r === "center" ? t.height / 2 : r === "bottom" ? t.height : r;
    return Ds({
      x: i,
      y: s
    }, t);
  }
  return Ds({
    x: t.width / 2,
    y: t.height / 2
  }, t);
}
const Hf = {
  static: IS,
  // specific viewport position, usually centered
  connected: kS
  // connected to a certain element
}, SS = z({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (e) => typeof e == "function" || e in Hf
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "v-overlay-location-strategies");
function ES(e, t) {
  const n = D({}), r = D();
  He && (wn(() => !!(t.isActive.value && e.locationStrategy), (s) => {
    var o, a;
    te(() => e.locationStrategy, s), xe(() => {
      r.value = void 0;
    }), typeof e.locationStrategy == "function" ? r.value = (o = e.locationStrategy(t, e, n)) == null ? void 0 : o.updateLocation : r.value = (a = Hf[e.locationStrategy](t, e, n)) == null ? void 0 : a.updateLocation;
  }), window.addEventListener("resize", i, {
    passive: !0
  }), xe(() => {
    window.removeEventListener("resize", i), r.value = void 0;
  }));
  function i(s) {
    var o;
    (o = r.value) == null || o.call(r, s);
  }
  return {
    contentStyles: n,
    updateLocation: r
  };
}
function IS() {
}
function CS(e) {
  const t = ia(e);
  return t.x -= parseFloat(e.style.left || 0), t.y -= parseFloat(e.style.top || 0), t;
}
function kS(e, t, n) {
  Eb(e.activatorEl.value) && Object.assign(n.value, {
    position: "fixed"
  });
  const {
    preferredAnchor: i,
    preferredOrigin: s
  } = ra(() => {
    const m = oo(t.location, e.isRtl.value), g = t.origin === "overlap" ? m : t.origin === "auto" ? As(m) : oo(t.origin, e.isRtl.value);
    return m.side === g.side && m.align === Ns(g).align ? {
      preferredAnchor: Bl(m),
      preferredOrigin: Bl(g)
    } : {
      preferredAnchor: m,
      preferredOrigin: g
    };
  }), [o, a, l, c] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((m) => y(() => {
    const g = parseFloat(t[m]);
    return isNaN(g) ? 1 / 0 : g;
  })), d = y(() => {
    if (Array.isArray(t.offset))
      return t.offset;
    if (typeof t.offset == "string") {
      const m = t.offset.split(" ").map(parseFloat);
      return m.length < 2 && m.push(0), m;
    }
    return typeof t.offset == "number" ? [t.offset, 0] : [0, 0];
  });
  let u = !1;
  const f = new ResizeObserver(() => {
    u && h();
  });
  te([e.activatorEl, e.contentEl], (m, g) => {
    let [w, C] = m, [E, p] = g;
    E && f.unobserve(E), w && f.observe(w), p && f.unobserve(p), C && f.observe(C);
  }, {
    immediate: !0
  }), xe(() => {
    f.disconnect();
  });
  function h() {
    if (u = !1, requestAnimationFrame(() => {
      requestAnimationFrame(() => u = !0);
    }), !e.activatorEl.value || !e.contentEl.value)
      return;
    const m = e.activatorEl.value.getBoundingClientRect(), g = CS(e.contentEl.value), w = Ui(e.contentEl.value), C = 12;
    w.length || (w.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (g.x += parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), g.y += parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
    const E = w.reduce((P, k) => {
      const R = k.getBoundingClientRect(), x = new Un({
        x: k === document.documentElement ? 0 : R.x,
        y: k === document.documentElement ? 0 : R.y,
        width: k.clientWidth,
        height: k.clientHeight
      });
      return P ? new Un({
        x: Math.max(P.left, x.left),
        y: Math.max(P.top, x.top),
        width: Math.min(P.right, x.right) - Math.max(P.left, x.left),
        height: Math.min(P.bottom, x.bottom) - Math.max(P.top, x.top)
      }) : x;
    }, void 0);
    E.x += C, E.y += C, E.width -= C * 2, E.height -= C * 2;
    let p = {
      anchor: i.value,
      origin: s.value
    };
    function O(P) {
      const k = new Un(g), R = nc(P.anchor, m), x = nc(P.origin, k);
      let {
        x: j,
        y: G
      } = wS(R, x);
      switch (P.anchor.side) {
        case "top":
          G -= d.value[0];
          break;
        case "bottom":
          G += d.value[0];
          break;
        case "left":
          j -= d.value[0];
          break;
        case "right":
          j += d.value[0];
          break;
      }
      switch (P.anchor.align) {
        case "top":
          G -= d.value[1];
          break;
        case "bottom":
          G += d.value[1];
          break;
        case "left":
          j -= d.value[1];
          break;
        case "right":
          j += d.value[1];
          break;
      }
      return k.x += j, k.y += G, k.width = Math.min(k.width, l.value), k.height = Math.min(k.height, c.value), {
        overflows: Ul(k, E),
        x: j,
        y: G
      };
    }
    let A = 0, N = 0;
    const I = {
      x: 0,
      y: 0
    }, _ = {
      x: !1,
      y: !1
    };
    let b = -1;
    for (; ; ) {
      if (b++ > 10) {
        vb("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: P,
        y: k,
        overflows: R
      } = O(p);
      A += P, N += k, g.x += P, g.y += k;
      {
        const x = Fl(p.anchor), j = R.x.before || R.x.after, G = R.y.before || R.y.after;
        let M = !1;
        if (["x", "y"].forEach((ee) => {
          if (ee === "x" && j && !_.x || ee === "y" && G && !_.y) {
            const Z = {
              anchor: {
                ...p.anchor
              },
              origin: {
                ...p.origin
              }
            }, $ = ee === "x" ? x === "y" ? Ns : As : x === "y" ? As : Ns;
            Z.anchor = $(Z.anchor), Z.origin = $(Z.origin);
            const {
              overflows: W
            } = O(Z);
            (W[ee].before <= R[ee].before && W[ee].after <= R[ee].after || W[ee].before + W[ee].after < (R[ee].before + R[ee].after) / 2) && (p = Z, M = _[ee] = !0);
          }
        }), M)
          continue;
      }
      R.x.before && (A += R.x.before, g.x += R.x.before), R.x.after && (A -= R.x.after, g.x -= R.x.after), R.y.before && (N += R.y.before, g.y += R.y.before), R.y.after && (N -= R.y.after, g.y -= R.y.after);
      {
        const x = Ul(g, E);
        I.x = E.width - x.x.before - x.x.after, I.y = E.height - x.y.before - x.y.after, A += x.x.before, g.x += x.x.before, N += x.y.before, g.y += x.y.before;
      }
      break;
    }
    const S = Fl(p.anchor);
    return Object.assign(n.value, {
      "--v-overlay-anchor-origin": `${p.anchor.side} ${p.anchor.align}`,
      transformOrigin: `${p.origin.side} ${p.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: Y(rc(N)),
      left: Y(rc(A)),
      minWidth: Y(S === "y" ? Math.min(o.value, m.width) : o.value),
      maxWidth: Y(ic(so(I.x, o.value === 1 / 0 ? 0 : o.value, l.value))),
      maxHeight: Y(ic(so(I.y, a.value === 1 / 0 ? 0 : a.value, c.value)))
    }), {
      available: I,
      contentBox: g
    };
  }
  return te(() => [i.value, s.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight], () => h()), Oe(() => {
    const m = h();
    if (!m)
      return;
    const {
      available: g,
      contentBox: w
    } = m;
    w.height > g.y && requestAnimationFrame(() => {
      h(), requestAnimationFrame(() => {
        h();
      });
    });
  }), {
    updateLocation: h
  };
}
function rc(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio;
}
function ic(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio;
}
let vo = !0;
const Wi = [];
function TS(e) {
  !vo || Wi.length ? (Wi.push(e), mo()) : (vo = !1, e(), mo());
}
let sc = -1;
function mo() {
  cancelAnimationFrame(sc), sc = requestAnimationFrame(() => {
    const e = Wi.shift();
    e && e(), Wi.length ? mo() : vo = !0;
  });
}
const wi = {
  none: null,
  close: NS,
  block: PS,
  reposition: RS
}, OS = z({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (e) => typeof e == "function" || e in wi
  }
}, "v-overlay-scroll-strategies");
function AS(e, t) {
  if (!He)
    return;
  let n;
  Gn(async () => {
    n == null || n.stop(), t.isActive.value && e.scrollStrategy && (n = Lr(), await Oe(), n.active && n.run(() => {
      var r;
      typeof e.scrollStrategy == "function" ? e.scrollStrategy(t, e, n) : (r = wi[e.scrollStrategy]) == null || r.call(wi, t, e, n);
    }));
  }), xe(() => {
    n == null || n.stop();
  });
}
function NS(e) {
  function t(n) {
    e.isActive.value = !1;
  }
  jf(e.activatorEl.value ?? e.contentEl.value, t);
}
function PS(e, t) {
  var o;
  const n = (o = e.root.value) == null ? void 0 : o.offsetParent, r = [.../* @__PURE__ */ new Set([...Ui(e.activatorEl.value, t.contained ? n : void 0), ...Ui(e.contentEl.value, t.contained ? n : void 0)])].filter((a) => !a.classList.contains("v-overlay-scroll-blocked")), i = window.innerWidth - document.documentElement.offsetWidth, s = ((a) => aa(a) && a)(n || document.documentElement);
  s && e.root.value.classList.add("v-overlay--scroll-blocked"), r.forEach((a, l) => {
    a.style.setProperty("--v-body-scroll-x", Y(-a.scrollLeft)), a.style.setProperty("--v-body-scroll-y", Y(-a.scrollTop)), a.style.setProperty("--v-scrollbar-offset", Y(i)), a.classList.add("v-overlay-scroll-blocked");
  }), xe(() => {
    r.forEach((a, l) => {
      const c = parseFloat(a.style.getPropertyValue("--v-body-scroll-x")), d = parseFloat(a.style.getPropertyValue("--v-body-scroll-y"));
      a.style.removeProperty("--v-body-scroll-x"), a.style.removeProperty("--v-body-scroll-y"), a.style.removeProperty("--v-scrollbar-offset"), a.classList.remove("v-overlay-scroll-blocked"), a.scrollLeft = -c, a.scrollTop = -d;
    }), s && e.root.value.classList.remove("v-overlay--scroll-blocked");
  });
}
function RS(e, t, n) {
  let r = !1, i = -1, s = -1;
  function o(a) {
    TS(() => {
      var d, u;
      const l = performance.now();
      (u = (d = e.updateLocation).value) == null || u.call(d, a), r = (performance.now() - l) / (1e3 / 60) > 2;
    });
  }
  s = (typeof requestIdleCallback > "u" ? (a) => a() : requestIdleCallback)(() => {
    n.run(() => {
      jf(e.activatorEl.value ?? e.contentEl.value, (a) => {
        r ? (cancelAnimationFrame(i), i = requestAnimationFrame(() => {
          i = requestAnimationFrame(() => {
            o(a);
          });
        })) : o(a);
      });
    });
  }), xe(() => {
    typeof cancelIdleCallback < "u" && cancelIdleCallback(s), cancelAnimationFrame(i);
  });
}
function jf(e, t) {
  const n = [document, ...Ui(e)];
  n.forEach((r) => {
    r.addEventListener("scroll", t, {
      passive: !0
    });
  }), xe(() => {
    n.forEach((r) => {
      r.removeEventListener("scroll", t);
    });
  });
}
function xS() {
  if (!He)
    return D(!1);
  const {
    ssr: e
  } = kf();
  if (e) {
    const t = D(!1);
    return qt(() => {
      t.value = !0;
    }), t;
  } else
    return D(!0);
}
function Ca() {
  const t = Ue("useScopeId").vnode.scopeId;
  return {
    scopeId: t ? {
      [t]: ""
    } : void 0
  };
}
const oc = Symbol.for("vuetify:stack"), rr = In([]);
function VS(e, t, n) {
  const r = Ue("useStack"), i = !n, s = me(oc, void 0), o = In({
    activeChildren: /* @__PURE__ */ new Set()
  });
  Je(oc, o);
  const a = D(+t.value);
  wn(e, () => {
    var u;
    const d = (u = rr.at(-1)) == null ? void 0 : u[1];
    a.value = d ? d + 10 : +t.value, i && rr.push([r.uid, a.value]), s == null || s.activeChildren.add(r.uid), xe(() => {
      if (i) {
        const f = B(rr).findIndex((h) => h[0] === r.uid);
        rr.splice(f, 1);
      }
      s == null || s.activeChildren.delete(r.uid);
    });
  });
  const l = D(!0);
  i && Gn(() => {
    var u;
    const d = ((u = rr.at(-1)) == null ? void 0 : u[0]) === r.uid;
    setTimeout(() => l.value = d);
  });
  const c = y(() => !o.activeChildren.size);
  return {
    globalTop: $r(l),
    localTop: c,
    stackStyles: y(() => ({
      zIndex: a.value
    }))
  };
}
function DS(e) {
  return {
    teleportTarget: y(() => {
      const n = e.value;
      if (n === !0 || !He)
        return;
      const r = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n;
      if (r == null) {
        Q(`Unable to locate target ${n}`);
        return;
      }
      let i = r.querySelector(":scope > .v-overlay-container");
      return i || (i = document.createElement("div"), i.className = "v-overlay-container", r.appendChild(i)), i;
    })
  };
}
function LS() {
  return !0;
}
function Wf(e, t, n) {
  if (!e || zf(e, n) === !1)
    return !1;
  const r = Dd(t);
  if (typeof ShadowRoot < "u" && r instanceof ShadowRoot && r.host === e.target)
    return !1;
  const i = (typeof n.value == "object" && n.value.include || (() => []))();
  return i.push(t), !i.some((s) => s == null ? void 0 : s.contains(e.target));
}
function zf(e, t) {
  return (typeof t.value == "object" && t.value.closeConditional || LS)(e);
}
function $S(e, t, n) {
  const r = typeof n.value == "function" ? n.value : n.value.handler;
  t._clickOutside.lastMousedownWasOutside && Wf(e, t, n) && setTimeout(() => {
    zf(e, n) && r && r(e);
  }, 0);
}
function ac(e, t) {
  const n = Dd(e);
  t(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && t(n);
}
const MS = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(e, t) {
    const n = (i) => $S(i, e, t), r = (i) => {
      e._clickOutside.lastMousedownWasOutside = Wf(i, e, t);
    };
    ac(e, (i) => {
      i.addEventListener("click", n, !0), i.addEventListener("mousedown", r, !0);
    }), e._clickOutside || (e._clickOutside = {
      lastMousedownWasOutside: !0
    }), e._clickOutside[t.instance.$.uid] = {
      onClick: n,
      onMousedown: r
    };
  },
  unmounted(e, t) {
    e._clickOutside && (ac(e, (n) => {
      var s;
      if (!n || !((s = e._clickOutside) != null && s[t.instance.$.uid]))
        return;
      const {
        onClick: r,
        onMousedown: i
      } = e._clickOutside[t.instance.$.uid];
      n.removeEventListener("click", r, !0), n.removeEventListener("mousedown", i, !0);
    }), delete e._clickOutside[t.instance.$.uid]);
  }
};
function BS(e) {
  const {
    modelValue: t,
    color: n,
    ...r
  } = e;
  return v(Ct, {
    name: "fade-transition",
    appear: !0
  }, {
    default: () => [e.modelValue && v("div", re({
      class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
      style: e.color.backgroundColorStyles.value
    }, r), null)]
  });
}
const ka = z({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: !0
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [String, Boolean],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...yS(),
  ...An(),
  ...Ff(),
  ...SS(),
  ...OS(),
  ...Ie(),
  ...ss()
}, "v-overlay"), zi = H()({
  name: "VOverlay",
  directives: {
    ClickOutside: MS
  },
  inheritAttrs: !1,
  props: {
    _disableGlobalStack: Boolean,
    ...ka()
  },
  emits: {
    "click:outside": (e) => !0,
    "update:modelValue": (e) => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: r,
      emit: i
    } = t;
    const s = be(e, "modelValue"), o = y({
      get: () => s.value,
      set: (Z) => {
        Z && e.disabled || (s.value = Z);
      }
    }), {
      teleportTarget: a
    } = DS(y(() => e.attach || e.contained)), {
      themeClasses: l
    } = Ve(e), {
      rtlClasses: c,
      isRtl: d
    } = Jr(), {
      hasContent: u,
      onAfterLeave: f
    } = Uf(e, o), h = zn(y(() => typeof e.scrim == "string" ? e.scrim : null)), {
      globalTop: m,
      localTop: g,
      stackStyles: w
    } = VS(o, U(e, "zIndex"), e._disableGlobalStack), {
      activatorEl: C,
      activatorRef: E,
      activatorEvents: p,
      contentEvents: O,
      scrimEvents: A
    } = _S(e, {
      isActive: o,
      isTop: g
    }), {
      dimensionStyles: N
    } = Nn(e), I = xS(), {
      scopeId: _
    } = Ca();
    te(() => e.disabled, (Z) => {
      Z && (o.value = !1);
    });
    const b = D(), S = D(), {
      contentStyles: P,
      updateLocation: k
    } = ES(e, {
      isRtl: d,
      contentEl: S,
      activatorEl: C,
      isActive: o
    });
    AS(e, {
      root: b,
      contentEl: S,
      activatorEl: C,
      isActive: o,
      updateLocation: k
    });
    function R(Z) {
      i("click:outside", Z), e.persistent ? ee() : o.value = !1;
    }
    function x() {
      return o.value && m.value;
    }
    He && te(o, (Z) => {
      Z ? window.addEventListener("keydown", j) : window.removeEventListener("keydown", j);
    }, {
      immediate: !0
    });
    function j(Z) {
      Z.key === "Escape" && m.value && (e.persistent ? ee() : o.value = !1);
    }
    const G = nw();
    wn(() => e.closeOnBack, () => {
      rw(G, (Z) => {
        m.value && o.value ? (Z(!1), e.persistent ? ee() : o.value = !1) : Z();
      });
    });
    const M = D();
    te(() => o.value && (e.absolute || e.contained) && a.value == null, (Z) => {
      if (Z) {
        const $ = Sb(b.value);
        $ && $ !== document.scrollingElement && (M.value = $.scrollTop);
      }
    });
    function ee() {
      e.noClickAnimation || S.value && cn(S.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: Rr
      });
    }
    return J(() => {
      var Z;
      return v(Pe, null, [(Z = n.activator) == null ? void 0 : Z.call(n, {
        isActive: o.value,
        props: re({
          ref: E
        }, vs(p.value), e.activatorProps)
      }), I.value && v(Dv, {
        disabled: !a.value,
        to: a.value
      }, {
        default: () => [u.value && v("div", re({
          class: ["v-overlay", {
            "v-overlay--absolute": e.absolute || e.contained,
            "v-overlay--active": o.value,
            "v-overlay--contained": e.contained
          }, l.value, c.value],
          style: [w.value, {
            top: Y(M.value)
          }],
          ref: b
        }, _, r), [v(BS, re({
          color: h,
          modelValue: o.value && !!e.scrim
        }, vs(A.value)), null), v(St, {
          appear: !0,
          persisted: !0,
          transition: e.transition,
          target: C.value,
          onAfterLeave: () => {
            f(), i("afterLeave");
          }
        }, {
          default: () => {
            var $;
            return [Ae(v("div", re({
              ref: S,
              class: ["v-overlay__content", e.contentClass],
              style: [N.value, P.value]
            }, vs(O.value), e.contentProps), [($ = n.default) == null ? void 0 : $.call(n, {
              isActive: o
            })]), [[qn, o.value], [Tt("click-outside"), {
              handler: R,
              closeConditional: x,
              include: () => [C.value]
            }]])];
          }
        })])]
      })]);
    }), {
      activatorEl: C,
      animateClick: ee,
      contentEl: S,
      globalTop: m,
      localTop: g,
      updateLocation: k
    };
  }
}), li = H()({
  name: "VTooltip",
  props: {
    id: String,
    text: String,
    ...ta(ka({
      closeOnBack: !1,
      location: "end",
      locationStrategy: "connected",
      minWidth: 0,
      offset: 10,
      openOnClick: !1,
      openOnHover: !0,
      origin: "auto",
      scrim: !1,
      scrollStrategy: "reposition",
      transition: !1
    }), ["absolute", "persistent", "eager"])
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = be(e, "modelValue"), {
      scopeId: i
    } = Ca(), s = vt(), o = y(() => e.id || `v-tooltip-${s}`), a = D(), l = y(() => e.location.split(" ").length > 1 ? e.location : e.location + " center"), c = y(() => e.origin === "auto" || e.origin === "overlap" || e.origin.split(" ").length > 1 || e.location.split(" ").length > 1 ? e.origin : e.origin + " center"), d = y(() => e.transition ? e.transition : r.value ? "scale-transition" : "fade-transition"), u = y(() => re({
      "aria-describedby": o.value
    }, e.activatorProps));
    return J(() => {
      const [f] = zi.filterProps(e);
      return v(zi, re({
        ref: a,
        class: ["v-tooltip"],
        id: o.value
      }, f, {
        modelValue: r.value,
        "onUpdate:modelValue": (h) => r.value = h,
        transition: d.value,
        absolute: !0,
        location: l.value,
        origin: c.value,
        persistent: !0,
        role: "tooltip",
        eager: !0,
        activatorProps: u.value,
        _disableGlobalStack: !0
      }, i), {
        activator: n.activator,
        default: function() {
          var w;
          for (var h = arguments.length, m = new Array(h), g = 0; g < h; g++)
            m[g] = arguments[g];
          return ((w = n.default) == null ? void 0 : w.call(n, ...m)) ?? e.text;
        }
      });
    }), ds({}, a);
  }
}), FS = { class: "caption" }, US = { key: 0 }, HS = {
  key: 0,
  class: "ml-2"
}, jS = {
  __name: "LoginWithProvider",
  setup(e) {
    const t = Xe(), { loginWithGoogle: n, loginWithFacebook: r, loginWithSaml: i, SET_SHOW_LOGIN_WITH_PHONE: s } = t, { config: o, isLoginWithProvidersActive: a, isOnlySingleProvider: l } = Tn(t);
    return (c, d) => T(a) ? (F(), X(qe, {
      key: 0,
      class: "text-center ma-0 pa-0"
    }, {
      default: V(() => [
        ye("div", FS, [
          T(o).email ? (F(), Ne("span", US, "or ")) : se("", !0),
          q("login with")
        ]),
        v(qe, null, {
          default: V(() => [
            T(o).google ? (F(), X(le, {
              key: 0,
              class: "mr-2",
              color: "#db3236",
              variant: "outlined",
              icon: !T(l),
              tooltip: "Authenticate with Gmail Account",
              onClick: d[0] || (d[0] = (u) => T(n)())
            }, {
              default: V(() => [
                v(pe, null, {
                  default: V(() => [
                    q("mdi-google")
                  ]),
                  _: 1
                }),
                v(li, {
                  activator: "parent",
                  location: "bottom",
                  text: "Authenticate with Gmail Account"
                })
              ]),
              _: 1
            }, 8, ["icon"])) : se("", !0),
            T(o).facebook ? (F(), X(le, {
              key: 1,
              class: "mr-2",
              color: "#3b5998",
              variant: "outlined",
              icon: !T(l),
              onClick: d[1] || (d[1] = (u) => T(r)())
            }, {
              default: V(() => [
                v(pe, null, {
                  default: V(() => [
                    q("mdi-facebook")
                  ]),
                  _: 1
                }),
                v(li, {
                  activator: "parent",
                  location: "bottom",
                  text: "Authenticate with Facebook Account"
                })
              ]),
              _: 1
            }, 8, ["icon"])) : se("", !0),
            T(o).phone ? (F(), X(le, {
              key: 2,
              class: "mr-2",
              color: "primary",
              variant: "outlined",
              icon: !T(l),
              onClick: d[2] || (d[2] = (u) => T(s)(!0))
            }, {
              default: V(() => [
                v(pe, null, {
                  default: V(() => [
                    q("mdi-cellphone")
                  ]),
                  _: 1
                }),
                v(li, {
                  activator: "parent",
                  location: "bottom",
                  text: "Authenticate with Text Message To Your Phone"
                })
              ]),
              _: 1
            }, 8, ["icon"])) : se("", !0),
            T(o).saml ? (F(), X(le, {
              key: 3,
              color: "secondary",
              variant: "outlined",
              icon: !T(l),
              onClick: d[3] || (d[3] = (u) => T(i)())
            }, {
              default: V(() => [
                v(pe, null, {
                  default: V(() => [
                    q("mdi-onepassword")
                  ]),
                  _: 1
                }),
                T(l) ? (F(), Ne("span", HS, it(T(o).saml_text), 1)) : se("", !0),
                v(li, {
                  activator: "parent",
                  location: "bottom",
                  text: "Authenticate with SAML provider"
                })
              ]),
              _: 1
            }, 8, ["icon"])) : se("", !0)
          ]),
          _: 1
        })
      ]),
      _: 1
    })) : se("", !0);
  }
};
const WS = H()({
  name: "VDialog",
  props: {
    fullscreen: Boolean,
    retainFocus: {
      type: Boolean,
      default: !0
    },
    scrollable: Boolean,
    ...ka({
      origin: "center center",
      scrollStrategy: "block",
      transition: {
        component: Ab
      },
      zIndex: 2400
    })
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = be(e, "modelValue"), {
      scopeId: i
    } = Ca(), s = D();
    function o(l) {
      var u, f;
      const c = l.relatedTarget, d = l.target;
      if (c !== d && ((u = s.value) != null && u.contentEl) && // We're the topmost dialog
      ((f = s.value) != null && f.globalTop) && // It isn't the document or the dialog body
      ![document, s.value.contentEl].includes(d) && // It isn't inside the dialog body
      !s.value.contentEl.contains(d)) {
        const h = [...s.value.contentEl.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])')].filter((w) => !w.hasAttribute("disabled") && !w.matches('[tabindex="-1"]'));
        if (!h.length)
          return;
        const m = h[0], g = h[h.length - 1];
        c === m ? g.focus() : m.focus();
      }
    }
    He && te(() => r.value && e.retainFocus, (l) => {
      l ? document.addEventListener("focusin", o) : document.removeEventListener("focusin", o);
    }, {
      immediate: !0
    }), te(r, async (l) => {
      var c, d;
      await Oe(), l ? (c = s.value.contentEl) == null || c.focus({
        preventScroll: !0
      }) : (d = s.value.activatorEl) == null || d.focus({
        preventScroll: !0
      });
    });
    const a = y(() => re({
      "aria-haspopup": "dialog",
      "aria-expanded": String(r.value)
    }, e.activatorProps));
    return J(() => {
      const [l] = zi.filterProps(e);
      return v(zi, re({
        ref: s,
        class: ["v-dialog", {
          "v-dialog--fullscreen": e.fullscreen,
          "v-dialog--scrollable": e.scrollable
        }]
      }, l, {
        modelValue: r.value,
        "onUpdate:modelValue": (c) => r.value = c,
        "aria-modal": "true",
        activatorProps: a.value,
        role: "dialog"
      }, i), {
        activator: n.activator,
        default: function() {
          for (var c = arguments.length, d = new Array(c), u = 0; u < c; u++)
            d[u] = arguments[u];
          return v(Ge, {
            root: !0
          }, {
            default: () => {
              var f;
              return [(f = n.default) == null ? void 0 : f.call(n, ...d)];
            }
          });
        }
      });
    }), ds({}, s);
  }
});
function lc(e) {
  const n = Math.abs(e);
  return Math.sign(e) * (n / ((1 / 0.501 - 2) * (1 - n) + 1));
}
function cc(e) {
  let {
    selectedElement: t,
    containerSize: n,
    contentSize: r,
    isRtl: i,
    currentScrollOffset: s,
    isHorizontal: o
  } = e;
  const a = o ? t.clientWidth : t.clientHeight, l = o ? t.offsetLeft : t.offsetTop, c = i && o ? r - l - a : l, d = n + s, u = a + c, f = a * 0.4;
  return c <= s ? s = Math.max(c - f, 0) : d <= u && (s = Math.min(s - (d - u - f), r - n)), s;
}
function zS(e) {
  let {
    selectedElement: t,
    containerSize: n,
    contentSize: r,
    isRtl: i,
    isHorizontal: s
  } = e;
  const o = s ? t.clientWidth : t.clientHeight, a = s ? t.offsetLeft : t.offsetTop, l = i && s ? r - a - o / 2 - n / 2 : a + o / 2 - n / 2;
  return Math.min(r - n, Math.max(0, l));
}
const GS = Symbol.for("vuetify:v-slide-group"), Gf = z({
  centerActive: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: GS
  },
  nextIcon: {
    type: oe,
    default: "$next"
  },
  prevIcon: {
    type: oe,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["always", "desktop", "mobile"].includes(e)
  },
  ..._e(),
  ...af({
    selectedClass: "v-slide-group-item--active"
  })
}, "v-slide-group"), uc = H()({
  name: "VSlideGroup",
  props: Gf(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isRtl: r
    } = Jr(), {
      mobile: i
    } = kf(), s = ha(e, e.symbol), o = D(!1), a = D(0), l = D(0), c = D(0), d = y(() => e.direction === "horizontal"), {
      resizeRef: u,
      contentRect: f
    } = ho(), {
      resizeRef: h,
      contentRect: m
    } = ho(), g = y(() => s.selected.value.length ? s.items.value.findIndex(($) => $.id === s.selected.value[0]) : -1), w = y(() => s.selected.value.length ? s.items.value.findIndex(($) => $.id === s.selected.value[s.selected.value.length - 1]) : -1);
    if (He) {
      let $ = -1;
      te(() => [s.selected.value, f.value, m.value, d.value], () => {
        cancelAnimationFrame($), $ = requestAnimationFrame(() => {
          if (f.value && m.value) {
            const W = d.value ? "width" : "height";
            l.value = f.value[W], c.value = m.value[W], o.value = l.value + 1 < c.value;
          }
          if (g.value >= 0 && h.value) {
            const W = h.value.children[w.value];
            g.value === 0 || !o.value ? a.value = 0 : e.centerActive ? a.value = zS({
              selectedElement: W,
              containerSize: l.value,
              contentSize: c.value,
              isRtl: r.value,
              isHorizontal: d.value
            }) : o.value && (a.value = cc({
              selectedElement: W,
              containerSize: l.value,
              contentSize: c.value,
              isRtl: r.value,
              currentScrollOffset: a.value,
              isHorizontal: d.value
            }));
          }
        });
      });
    }
    const C = D(!1);
    let E = 0, p = 0;
    function O($) {
      const W = d.value ? "clientX" : "clientY";
      p = (r.value && d.value ? -1 : 1) * a.value, E = $.touches[0][W], C.value = !0;
    }
    function A($) {
      if (!o.value)
        return;
      const W = d.value ? "clientX" : "clientY", ae = r.value && d.value ? -1 : 1;
      a.value = ae * (p + E - $.touches[0][W]);
    }
    function N($) {
      const W = c.value - l.value;
      a.value < 0 || !o.value ? a.value = 0 : a.value >= W && (a.value = W), C.value = !1;
    }
    function I() {
      u.value && (u.value[d.value ? "scrollLeft" : "scrollTop"] = 0);
    }
    const _ = D(!1);
    function b($) {
      if (_.value = !0, !(!o.value || !h.value)) {
        for (const W of $.composedPath())
          for (const ae of h.value.children)
            if (ae === W) {
              a.value = cc({
                selectedElement: ae,
                containerSize: l.value,
                contentSize: c.value,
                isRtl: r.value,
                currentScrollOffset: a.value,
                isHorizontal: d.value
              });
              return;
            }
      }
    }
    function S($) {
      _.value = !1;
    }
    function P($) {
      var W;
      !_.value && !($.relatedTarget && ((W = h.value) != null && W.contains($.relatedTarget))) && R();
    }
    function k($) {
      h.value && (d.value ? $.key === "ArrowRight" ? R(r.value ? "prev" : "next") : $.key === "ArrowLeft" && R(r.value ? "next" : "prev") : $.key === "ArrowDown" ? R("next") : $.key === "ArrowUp" && R("prev"), $.key === "Home" ? R("first") : $.key === "End" && R("last"));
    }
    function R($) {
      var W, ae, Qe, Ze, en;
      if (h.value)
        if (!$)
          (W = [...h.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter((Xf) => !Xf.hasAttribute("disabled"))[0]) == null || W.focus();
        else if ($ === "next") {
          const ce = (ae = h.value.querySelector(":focus")) == null ? void 0 : ae.nextElementSibling;
          ce ? ce.focus() : R("first");
        } else if ($ === "prev") {
          const ce = (Qe = h.value.querySelector(":focus")) == null ? void 0 : Qe.previousElementSibling;
          ce ? ce.focus() : R("last");
        } else
          $ === "first" ? (Ze = h.value.firstElementChild) == null || Ze.focus() : $ === "last" && ((en = h.value.lastElementChild) == null || en.focus());
    }
    function x($) {
      const W = a.value + ($ === "prev" ? -1 : 1) * l.value;
      a.value = so(W, 0, c.value - l.value);
    }
    const j = y(() => {
      let $ = a.value > c.value - l.value ? -(c.value - l.value) + lc(c.value - l.value - a.value) : -a.value;
      a.value <= 0 && ($ = lc(-a.value));
      const W = r.value && d.value ? -1 : 1;
      return {
        transform: `translate${d.value ? "X" : "Y"}(${W * $}px)`,
        transition: C.value ? "none" : "",
        willChange: C.value ? "transform" : ""
      };
    }), G = y(() => ({
      next: s.next,
      prev: s.prev,
      select: s.select,
      isSelected: s.isSelected
    })), M = y(() => {
      switch (e.showArrows) {
        case "always":
          return !0;
        case "desktop":
          return !i.value;
        case !0:
          return o.value || Math.abs(a.value) > 0;
        case "mobile":
          return i.value || o.value || Math.abs(a.value) > 0;
        default:
          return !i.value && (o.value || Math.abs(a.value) > 0);
      }
    }), ee = y(() => Math.abs(a.value) > 0), Z = y(() => c.value > Math.abs(a.value) + l.value);
    return J(() => v(e.tag, {
      class: ["v-slide-group", {
        "v-slide-group--vertical": !d.value,
        "v-slide-group--has-affixes": M.value,
        "v-slide-group--is-overflowing": o.value
      }],
      tabindex: _.value || s.selected.value.length ? -1 : 0,
      onFocus: P
    }, {
      default: () => {
        var $, W, ae;
        return [M.value && v("div", {
          key: "prev",
          class: ["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !ee.value
          }],
          onClick: () => x("prev")
        }, [(($ = n.prev) == null ? void 0 : $.call(n, G.value)) ?? v(ql, null, {
          default: () => [v(pe, {
            icon: r.value ? e.nextIcon : e.prevIcon
          }, null)]
        })]), v("div", {
          key: "container",
          ref: u,
          class: "v-slide-group__container",
          onScroll: I
        }, [v("div", {
          ref: h,
          class: "v-slide-group__content",
          style: j.value,
          onTouchstartPassive: O,
          onTouchmovePassive: A,
          onTouchendPassive: N,
          onFocusin: b,
          onFocusout: S,
          onKeydown: k
        }, [(W = n.default) == null ? void 0 : W.call(n, G.value)])]), M.value && v("div", {
          key: "next",
          class: ["v-slide-group__next", {
            "v-slide-group__next--disabled": !Z.value
          }],
          onClick: () => x("next")
        }, [((ae = n.next) == null ? void 0 : ae.call(n, G.value)) ?? v(ql, null, {
          default: () => [v(pe, {
            icon: r.value ? e.prevIcon : e.nextIcon
          }, null)]
        })])];
      }
    })), {
      selected: s.selected,
      scrollTo: x,
      scrollOffset: a,
      focus: R
    };
  }
});
const qf = Symbol.for("vuetify:v-tabs"), cr = H()({
  name: "VTab",
  props: {
    fixed: Boolean,
    title: String,
    sliderColor: String,
    hideSlider: Boolean,
    direction: {
      type: String,
      default: "horizontal"
    },
    ...ta(gf({
      selectedClass: "v-tab--selected",
      variant: "text"
    }), ["active", "block", "flat", "location", "position", "symbol"])
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: r
    } = t;
    const {
      textColorClasses: i,
      textColorStyles: s
    } = ot(e, "sliderColor"), o = y(() => e.direction === "horizontal"), a = D(!1), l = D(), c = D();
    function d(u) {
      var h, m;
      let {
        value: f
      } = u;
      if (a.value = f, f) {
        const g = (m = (h = l.value) == null ? void 0 : h.$el.parentElement) == null ? void 0 : m.querySelector(".v-tab--selected .v-tab__slider"), w = c.value;
        if (!g || !w)
          return;
        const C = getComputedStyle(g).color, E = g.getBoundingClientRect(), p = w.getBoundingClientRect(), O = o.value ? "x" : "y", A = o.value ? "X" : "Y", N = o.value ? "right" : "bottom", I = o.value ? "width" : "height", _ = E[O], b = p[O], S = _ > b ? E[N] - p[N] : E[O] - p[O], P = Math.sign(S) > 0 ? o.value ? "right" : "bottom" : Math.sign(S) < 0 ? o.value ? "left" : "top" : "center", R = (Math.abs(S) + (Math.sign(S) < 0 ? E[I] : p[I])) / Math.max(E[I], p[I]), x = E[I] / p[I], j = 1.5;
        cn(w, {
          backgroundColor: [C, ""],
          transform: [`translate${A}(${S}px) scale${A}(${x})`, `translate${A}(${S / j}px) scale${A}(${(R - 1) / j + 1})`, ""],
          transformOrigin: Array(3).fill(P)
        }, {
          duration: 225,
          easing: Rr
        });
      }
    }
    return J(() => {
      const [u] = le.filterProps(e);
      return v(le, re({
        _as: "VTab",
        symbol: qf,
        ref: l,
        class: ["v-tab"],
        tabindex: a.value ? 0 : -1,
        role: "tab",
        "aria-selected": String(a.value),
        active: !1,
        block: e.fixed,
        maxWidth: e.fixed ? 300 : void 0,
        rounded: 0
      }, u, r, {
        "onGroup:selected": d
      }), {
        default: () => [n.default ? n.default() : e.title, !e.hideSlider && v("div", {
          ref: c,
          class: ["v-tab__slider", i.value],
          style: s.value
        }, null)]
      });
    }), {};
  }
});
function qS(e) {
  return e ? e.map((t) => typeof t == "string" ? {
    title: t,
    value: t
  } : t) : [];
}
const KS = H()({
  name: "VTabs",
  props: {
    alignTabs: {
      type: String,
      default: "start"
    },
    color: String,
    fixedTabs: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    stacked: Boolean,
    bgColor: String,
    grow: Boolean,
    height: {
      type: [Number, String],
      default: void 0
    },
    hideSlider: Boolean,
    sliderColor: String,
    ...Gf({
      mandatory: "force"
    }),
    ...lt(),
    ..._e()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = be(e, "modelValue"), i = y(() => qS(e.items)), {
      densityClasses: s
    } = mt(e), {
      backgroundColorClasses: o,
      backgroundColorStyles: a
    } = zn(U(e, "bgColor"));
    return On({
      VTab: {
        color: U(e, "color"),
        direction: U(e, "direction"),
        stacked: U(e, "stacked"),
        fixed: U(e, "fixedTabs"),
        sliderColor: U(e, "sliderColor"),
        hideSlider: U(e, "hideSlider")
      }
    }), J(() => {
      const [l] = uc.filterProps(e);
      return v(uc, re(l, {
        modelValue: r.value,
        "onUpdate:modelValue": (c) => r.value = c,
        class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
          "v-tabs--fixed-tabs": e.fixedTabs,
          "v-tabs--grow": e.grow,
          "v-tabs--stacked": e.stacked
        }, s.value, o.value],
        style: [{
          "--v-tabs-height": Y(e.height)
        }, a.value],
        role: "tablist",
        symbol: qf
      }), {
        default: () => [n.default ? n.default() : i.value.map((c) => v(cr, re(c, {
          key: c.title
        }), null))]
      });
    }), {};
  }
});
const JS = (e) => {
  const {
    touchstartX: t,
    touchendX: n,
    touchstartY: r,
    touchendY: i
  } = e, s = 0.5, o = 16;
  e.offsetX = n - t, e.offsetY = i - r, Math.abs(e.offsetY) < s * Math.abs(e.offsetX) && (e.left && n < t - o && e.left(e), e.right && n > t + o && e.right(e)), Math.abs(e.offsetX) < s * Math.abs(e.offsetY) && (e.up && i < r - o && e.up(e), e.down && i > r + o && e.down(e));
};
function YS(e, t) {
  var r;
  const n = e.changedTouches[0];
  t.touchstartX = n.clientX, t.touchstartY = n.clientY, (r = t.start) == null || r.call(t, {
    originalEvent: e,
    ...t
  });
}
function XS(e, t) {
  var r;
  const n = e.changedTouches[0];
  t.touchendX = n.clientX, t.touchendY = n.clientY, (r = t.end) == null || r.call(t, {
    originalEvent: e,
    ...t
  }), JS(t);
}
function QS(e, t) {
  var r;
  const n = e.changedTouches[0];
  t.touchmoveX = n.clientX, t.touchmoveY = n.clientY, (r = t.move) == null || r.call(t, {
    originalEvent: e,
    ...t
  });
}
function ZS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end
  };
  return {
    touchstart: (n) => YS(n, t),
    touchend: (n) => XS(n, t),
    touchmove: (n) => QS(n, t)
  };
}
function eE(e, t) {
  var a;
  const n = t.value, r = n != null && n.parent ? e.parentElement : e, i = (n == null ? void 0 : n.options) ?? {
    passive: !0
  }, s = (a = t.instance) == null ? void 0 : a.$.uid;
  if (!r || !s)
    return;
  const o = ZS(t.value);
  r._touchHandlers = r._touchHandlers ?? /* @__PURE__ */ Object.create(null), r._touchHandlers[s] = o, Ad(o).forEach((l) => {
    r.addEventListener(l, o[l], i);
  });
}
function tE(e, t) {
  var s, o;
  const n = (s = t.value) != null && s.parent ? e.parentElement : e, r = (o = t.instance) == null ? void 0 : o.$.uid;
  if (!(n != null && n._touchHandlers) || !r)
    return;
  const i = n._touchHandlers[r];
  Ad(i).forEach((a) => {
    n.removeEventListener(a, i[a]);
  }), delete n._touchHandlers[r];
}
const Kf = {
  mounted: eE,
  unmounted: tE
}, nE = Kf, Jf = Symbol.for("vuetify:v-window"), Yf = Symbol.for("vuetify:v-window-group"), rE = z({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || e === "hover"
  },
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    default: "force"
  },
  ..._e(),
  ...Ie()
}, "v-window"), iE = H()({
  name: "VWindow",
  directives: {
    Touch: Kf
  },
  props: rE(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: r
    } = Ve(e), {
      isRtl: i
    } = Jr(), {
      t: s
    } = va(), o = ha(e, Yf), a = D(), l = y(() => i.value ? !e.reverse : e.reverse), c = D(!1), d = y(() => {
      const O = e.direction === "vertical" ? "y" : "x", N = (l.value ? !c.value : c.value) ? "-reverse" : "";
      return `v-window-${O}${N}-transition`;
    }), u = D(0), f = D(void 0), h = y(() => o.items.value.findIndex((O) => o.selected.value.includes(O.id)));
    te(h, (O, A) => {
      const N = o.items.value.length, I = N - 1;
      N <= 2 ? c.value = O < A : O === I && A === 0 ? c.value = !0 : O === 0 && A === I ? c.value = !1 : c.value = O < A;
    }), Je(Jf, {
      transition: d,
      isReversed: c,
      transitionCount: u,
      transitionHeight: f,
      rootRef: a
    });
    const m = y(() => e.continuous || h.value !== 0), g = y(() => e.continuous || h.value !== o.items.value.length - 1);
    function w() {
      m.value && o.prev();
    }
    function C() {
      g.value && o.next();
    }
    const E = y(() => {
      const O = [], A = {
        icon: i.value ? e.nextIcon : e.prevIcon,
        class: `v-window__${l.value ? "right" : "left"}`,
        onClick: o.prev,
        ariaLabel: s("$vuetify.carousel.prev")
      };
      O.push(m.value ? n.prev ? n.prev({
        props: A
      }) : v(le, A, null) : v("div", null, null));
      const N = {
        icon: i.value ? e.prevIcon : e.nextIcon,
        class: `v-window__${l.value ? "left" : "right"}`,
        onClick: o.next,
        ariaLabel: s("$vuetify.carousel.next")
      };
      return O.push(g.value ? n.next ? n.next({
        props: N
      }) : v(le, N, null) : v("div", null, null)), O;
    }), p = y(() => e.touch === !1 ? e.touch : {
      ...{
        left: () => {
          l.value ? w() : C();
        },
        right: () => {
          l.value ? C() : w();
        },
        start: (A) => {
          let {
            originalEvent: N
          } = A;
          N.stopPropagation();
        }
      },
      ...e.touch === !0 ? {} : e.touch
    });
    return J(() => Ae(v(e.tag, {
      ref: a,
      class: ["v-window", {
        "v-window--show-arrows-on-hover": e.showArrows === "hover"
      }, r.value]
    }, {
      default: () => {
        var O, A;
        return [v("div", {
          class: "v-window__container",
          style: {
            height: f.value
          }
        }, [(O = n.default) == null ? void 0 : O.call(n, {
          group: o
        }), e.showArrows !== !1 && v("div", {
          class: "v-window__controls"
        }, [E.value])]), (A = n.additional) == null ? void 0 : A.call(n, {
          group: o
        })];
      }
    }), [[Tt("touch"), p.value]])), {
      group: o
    };
  }
}), ci = H()({
  name: "VWindowItem",
  directives: {
    Touch: nE
  },
  props: {
    reverseTransition: {
      type: [Boolean, String],
      default: void 0
    },
    transition: {
      type: [Boolean, String],
      default: void 0
    },
    ...lf(),
    ...Ff()
  },
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const r = me(Jf), i = cf(e, Yf), {
      isBooted: s
    } = zd();
    if (!r || !i)
      throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const o = D(!1), a = y(() => r.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1);
    function l() {
      !o.value || !r || (o.value = !1, r.transitionCount.value > 0 && (r.transitionCount.value -= 1, r.transitionCount.value === 0 && (r.transitionHeight.value = void 0)));
    }
    function c() {
      var m;
      o.value || !r || (o.value = !0, r.transitionCount.value === 0 && (r.transitionHeight.value = Y((m = r.rootRef.value) == null ? void 0 : m.clientHeight)), r.transitionCount.value += 1);
    }
    function d() {
      l();
    }
    function u(m) {
      o.value && Oe(() => {
        !a.value || !o.value || !r || (r.transitionHeight.value = Y(m.clientHeight));
      });
    }
    const f = y(() => {
      const m = r.isReversed.value ? e.reverseTransition : e.transition;
      return a.value ? {
        name: typeof m != "string" ? r.transition.value : m,
        onBeforeEnter: c,
        onAfterEnter: l,
        onEnterCancelled: d,
        onBeforeLeave: c,
        onAfterLeave: l,
        onLeaveCancelled: d,
        onEnter: u
      } : !1;
    }), {
      hasContent: h
    } = Uf(e, i.isSelected);
    return J(() => v(St, {
      transition: f.value,
      disabled: !s.value
    }, {
      default: () => {
        var m;
        return [Ae(v("div", {
          class: ["v-window-item", i.selectedClass.value]
        }, [h.value && ((m = n.default) == null ? void 0 : m.call(n))]), [[qn, i.isSelected.value]])];
      }
    })), {};
  }
}), sE = /* @__PURE__ */ ye("br", null, null, -1), oE = /* @__PURE__ */ ye("br", null, null, -1), aE = { key: 0 }, lE = { key: 1 }, cE = {
  __name: "AuthGuard",
  setup(e) {
    const t = Xe(), { initializeGuard: n, SET_PASSWORD_RESET_SCREEN_SHOWN: r } = t, {
      tab: i,
      config: s,
      isLoading: o,
      isLoginWithPhoneShown: a,
      isUserRegistrationAllowed: l,
      isEmailVerificationScrenShown: c,
      isResetPasswordScreenShown: d
    } = Tn(t), u = B_(), f = y(() => s.debug), h = y(() => u.path), m = y({
      get: () => t.is_authguard_dialog_shown,
      set: (g) => t.is_authguard_dialog_shown = g
    });
    return qt(() => {
      n();
    }), Sv(() => {
    }), Wc(() => {
    }), te(h, (g, w) => {
      typeof w > "u" || (f.value && console.log("[ auth guard ]: vue router current route change: [", w, "] -> [", g, "]"), Qo());
    }), (g, w) => (F(), Ne("div", null, [
      q(" is_authguard_dialog_shown: " + it(T(t).is_authguard_dialog_shown), 1),
      sE,
      q(" is_authguard_dialog_persistent: " + it(T(t).is_authguard_dialog_persistent), 1),
      oE,
      q(" dialog: " + it(T(m)) + " ", 1),
      v(WS, {
        modelValue: T(m),
        "onUpdate:modelValue": w[3] || (w[3] = (C) => K(m) ? m.value = C : null),
        persistent: T(t).is_authguard_dialog_persistent,
        "retain-focus": !1,
        "overlay-opacity": "0.95",
        "content-class": "elevation-0"
      }, {
        default: V(() => [
          v(qe, {
            style: { "max-width": "500px" },
            class: "mb-5"
          }, {
            default: V(() => [
              v(En, {
                flat: "",
                outlined: ""
              }, {
                default: V(() => [
                  v(vf, { indeterminate: T(o) }, null, 8, ["indeterminate"]),
                  T(c) ? (F(), Ne("div", aE, [
                    v(vS)
                  ])) : (F(), Ne("div", lE, [
                    v(KS, {
                      value: T(i),
                      grow: "",
                      onChange: w[1] || (w[1] = (C) => i.value = C)
                    }, {
                      default: V(() => [
                        T(a) ? se("", !0) : (F(), X(cr, {
                          key: 0,
                          onClick: w[0] || (w[0] = (C) => i.value = 0)
                        }, {
                          default: V(() => [
                            q(" Sign In ")
                          ]),
                          _: 1
                        })),
                        T(a) ? (F(), X(cr, { key: 1 }, {
                          default: V(() => [
                            q(" Sign In ")
                          ]),
                          _: 1
                        })) : se("", !0),
                        !T(d) && T(l) ? (F(), X(cr, { key: 2 }, {
                          default: V(() => [
                            q(" Register ")
                          ]),
                          _: 1
                        })) : se("", !0),
                        (T(d) || !T(l)) && T(s).email ? (F(), X(cr, { key: 3 }, {
                          default: V(() => [
                            q(" Reset Password ")
                          ]),
                          _: 1
                        })) : se("", !0)
                      ]),
                      _: 1
                    }, 8, ["value"]),
                    v(Ht, null, {
                      default: V(() => [
                        v(iE, {
                          value: T(i),
                          onChange: w[2] || (w[2] = (C) => i.value = C)
                        }, {
                          default: V(() => [
                            T(a) ? se("", !0) : (F(), X(ci, {
                              key: 0,
                              class: "pt-5"
                            }, {
                              default: V(() => [
                                v(zw)
                              ]),
                              _: 1
                            })),
                            T(a) ? (F(), X(ci, {
                              key: 1,
                              class: "pt-5"
                            }, {
                              default: V(() => [
                                v(tS)
                              ]),
                              _: 1
                            })) : se("", !0),
                            !T(d) && T(l) ? (F(), X(ci, {
                              key: 2,
                              class: "pt-5"
                            }, {
                              default: V(() => [
                                v(Gw)
                              ]),
                              _: 1
                            })) : se("", !0),
                            (T(d) || !T(l)) && !T(s).email ? (F(), X(ci, { key: 3 }, {
                              default: V(() => [
                                v(Jw)
                              ]),
                              _: 1
                            })) : se("", !0)
                          ]),
                          _: 1
                        }, 8, ["value"])
                      ]),
                      _: 1
                    })
                  ])),
                  T(c) ? se("", !0) : (F(), X(Sn, { key: 2 }, {
                    default: V(() => [
                      v(jS)
                    ]),
                    _: 1
                  }))
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue", "persistent"])
    ]));
  }
}, uE = (e, t, n) => {
  const r = Xe(), i = r.config.debug, s = e.meta.requiresAuth, o = t.meta.requiresAuth;
  i && console.log("[ auth guard ]: vue router AuthMiddleware"), s && !o ? r.is_from_public_to_auth = !0 : r.is_from_public_to_auth = !1, s ? r.is_route_public = !1 : r.is_route_public = !0;
  const a = Qo();
  return i && console.log("[ auth guard ]: is route ALLOWED: [", a, "]"), s && a || !s ? n() : n(!1);
}, dE = {
  install: (e, t = {}) => {
    const n = { ...lb, ...t }, { firebase: r, debug: i } = n;
    i && (console.log("[ auth guard ]: wrapper initialization..."), r === null && console.error("[ auth guard ]: ERROR: firebase instance missing in AuthenticationGuard config!")), e.config.globalProperties.$pinia || (console.log("[ auth guard ]: pinia store not detected - creating..."), e.use(Tm()));
    const s = Xe();
    s.config = n, e.directive("mask", ob), e.component("AuthenticationGuard", cE);
  }
};
export {
  uE as AuthMiddleware,
  dE as default
};
